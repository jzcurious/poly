namespace poly {
    template <class D> concept has_cid = requires (D d) { d.cid; };
    using cid_t = unsigned long;
}
namespace std {
    typedef unsigned long size_t;
    typedef long ptrdiff_t;
    typedef decltype(nullptr) nullptr_t;
    extern "C++" inline void __terminate() noexcept __attribute__((always_inline)) {
        void terminate() noexcept;
        terminate();
    }

}
namespace std {
    inline namespace __cxx11 {
    }
}
namespace __gnu_cxx {
    inline namespace __cxx11 {
    }
}
namespace std {
    inline constexpr bool __is_constant_evaluated() noexcept {
        return __builtin_is_constant_evaluated();
    }
}
namespace std {
    template <typename> class allocator
    template<> class allocator<char8_t> : public __allocator_base<char8_t> {
    public:
        typedef char8_t value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<char8_t>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<char8_t> &__a) noexcept : __allocator_base<char8_t>(__a) __attribute__((always_inline)) {
        }
        allocator<char8_t> &operator=(const allocator<char8_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<char8_t>(const allocator<char8_t> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<char8_t>() noexcept __attribute__((always_inline)) {
        }
        constexpr char8_t *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(char8_t), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<char8_t *>(::operator new(__n));
            }
            return this->__allocator_base<char8_t>::allocate(__n, 0);
        }
        constexpr void deallocate(char8_t *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char8_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<char8_t> &, const allocator<char8_t> &) noexcept __attribute__((always_inline));
    }
    template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef char16_t value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<char16_t>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a) __attribute__((always_inline)) {
        }
        allocator<char16_t> &operator=(const allocator<char16_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<char16_t>(const allocator<char16_t> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<char16_t>() noexcept __attribute__((always_inline)) {
        }
        constexpr char16_t *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(char16_t), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<char16_t *>(::operator new(__n));
            }
            return this->__allocator_base<char16_t>::allocate(__n, 0);
        }
        constexpr void deallocate(char16_t *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char16_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<char16_t> &, const allocator<char16_t> &) noexcept __attribute__((always_inline));
    }
    template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef char32_t value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<char32_t>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a) __attribute__((always_inline)) {
        }
        allocator<char32_t> &operator=(const allocator<char32_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<char32_t>(const allocator<char32_t> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<char32_t>() noexcept __attribute__((always_inline)) {
        }
        constexpr char32_t *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(char32_t), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<char32_t *>(::operator new(__n));
            }
            return this->__allocator_base<char32_t>::allocate(__n, 0);
        }
        constexpr void deallocate(char32_t *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char32_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<char32_t> &, const allocator<char32_t> &) noexcept __attribute__((always_inline));
    }
    template<> class allocator<int> : public __allocator_base<int> {
    public:
        typedef int value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<int>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<int> &__a) noexcept : __allocator_base<int>(__a) __attribute__((always_inline)) {
        }
        allocator<int> &operator=(const allocator<int> &) noexcept = default        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<int>(const allocator<int> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<int>() noexcept __attribute__((always_inline)) {
        }
        constexpr int *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(int), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<int *>(::operator new(__n));
            }
            return this->__allocator_base<int>::allocate(__n, 0);
        }
        constexpr void deallocate(int *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<int>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<int> &, const allocator<int> &) noexcept __attribute__((always_inline));
    }
    template<> class allocator<Base<ChildA, ChildB, ChildC> *> : public __allocator_base<Base<ChildA, ChildB, ChildC> *> {
    public:
        typedef Base<ChildA, ChildB, ChildC> *value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<Base<ChildA, ChildB, ChildC> *>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<Base<ChildA, ChildB, ChildC> *> &__a) noexcept : __allocator_base<Base<ChildA, ChildB, ChildC> *>(__a) __attribute__((always_inline)) {
        }
        allocator<Base<ChildA, ChildB, ChildC> *> &operator=(const allocator<Base<ChildA, ChildB, ChildC> *> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<Base<ChildA, ChildB, ChildC> *>(const allocator<Base<ChildA, ChildB, ChildC> *> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<Base<ChildA, ChildB, ChildC> *>() noexcept __attribute__((always_inline)) {
        }
        constexpr Base<ChildA, ChildB, ChildC> **allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(Base<ChildA, ChildB, ChildC> *), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<Base<ChildA, ChildB, ChildC> **>(::operator new(__n));
            }
            return this->__allocator_base<Base<ChildA, ChildB, ChildC> *>::allocate(__n, 0);
        }
        constexpr void deallocate(Base<ChildA, ChildB, ChildC> **__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<Base<ChildA, ChildB, ChildC> *>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<Base<ChildA, ChildB, ChildC> *> &, const allocator<Base<ChildA, ChildB, ChildC> *> &) noexcept __attribute__((always_inline));
    };
    template<> class allocator<void>;
    template <typename, typename> struct uses_allocator;
    template <typename> struct allocator_traits
    template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]] {
            return __rhs;
        }
    }
    template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<char8_t>> {
        using allocator_type = allocator<char8_t>;
        using value_type = char8_t;
        using pointer = char8_t *;
        using const_pointer = const char8_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<int>> {
        using allocator_type = allocator<int>;
        using value_type = int;
        using pointer = int *;
        using const_pointer = const int *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<Base<ChildA, ChildB, ChildC> *>> {
        using allocator_type = allocator<Base<ChildA, ChildB, ChildC> *>;
        using value_type = Base<ChildA, ChildB, ChildC> *;
        using pointer = Base<ChildA, ChildB, ChildC> **;
        using const_pointer = Base<ChildA, ChildB, ChildC> *const *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    };
}
namespace std {
    template <class _CharT> struct char_traits;
    template<> struct char_traits<char>;
    template<> struct char_traits<wchar_t>;
    template<> struct char_traits<char8_t>;
    template<> struct char_traits<char16_t>;
    template<> struct char_traits<char32_t>;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string
        template<> class basic_string<char, std::char_traits<char>, std::allocator<char>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char>>::rebind<char>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char> traits_type;
            typedef typename char_traits<char>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char, char_traits<char>, allocator<char>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char, char_traits<char>, allocator<char>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<char>, char_traits<char>>)
                    ;
                return __p;
            }
            typedef basic_string_view<char, char_traits<char>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const _Tp &, const char *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<char> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char)
            };
            union {
                char _M_local_buf[16];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<char, char_traits<char>, allocator<char>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char *>(const char *__beg, const char *__end, std::input_iterator_tag);
            template<> constexpr void _M_construct<char *>(char *__beg, char *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<const char *>(const char *__beg, const char *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            template<> constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<char *>(char *__beg, char *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_construct(size_type __n, char __c) {
                if (__n > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__n, size_type(0)));
                    this->_M_capacity(__n);
                } else
                    this->_M_use_local_data();
                if (__n)
                    this->_S_assign(this->_M_data(), __n, __c);
                this->_M_set_length(__n);
            }
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = char();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const char *__s) const noexcept {
                return (less<const char *>()(__s, this->_M_data()) || less<const char *>()(this->_M_data() + this->size(), __s));
            }
            static constexpr void _S_copy(char *__d, const char *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char *__d, const char *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static constexpr void _S_assign(char *__d, size_type __n, char __c) {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }
            template <class _Iterator> static constexpr void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<const char *>(char *__p, const char *__k1, const char *__k2);
            template<> static constexpr void _S_copy_chars<char *>(char *__p, char *__k1, char *__k2);
            static constexpr void _S_copy_chars(char *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char *__p, char *__k1, char *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(char *__p, const char *__k1, const char *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<char> &);
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_mutate(size_type __pos, size_type __len1, const char *__s, size_type __len2) {
                const size_type __how_much = this->length() - __pos - __len1;
                size_type __new_capacity = this->length() + __len2 - __len1;
                pointer __r = this->_M_create(__new_capacity, this->capacity());
                if (__pos)
                    this->_S_copy(__r, this->_M_data(), __pos);
                if (__s && __len2)
                    this->_S_copy(__r + __pos, __s, __len2);
                if (__how_much)
                    this->_S_copy(__r + __pos + __len2, this->_M_data() + __pos + __len1, __how_much);
                this->_M_dispose();
                this->_M_data(__r);
                this->_M_capacity(__new_capacity);
            }
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::value) : _M_dataplus(this->_M_local_data()) {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr explicit basic_string(const std::allocator<char> &__a) noexcept : _M_dataplus(this->_M_local_data(), __a) {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr basic_string(const basic_string<char> &__str);
            constexpr basic_string(const basic_string<char> &__str, size_type __pos, const std::allocator<char> &__a);
            constexpr basic_string(const basic_string<char> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<char> &__str, size_type __pos, size_type __n, const std::allocator<char> &__a);
            constexpr basic_string(const char *__s, size_type __n, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<char>>> constexpr basic_string(const char *__s, const std::allocator<char> &__a);
            template<> constexpr basic_string<std::allocator<char>>(const char *__s, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                const char *__end = __s + traits_type::length(__s);
                this->_M_construct(__s, __end, forward_iterator_tag());
            }
;
            template <typename = _RequireAllocator<allocator<char>>> constexpr basic_string(size_type __n, char __c, const std::allocator<char> &__a);
            template<> constexpr basic_string<std::allocator<char>>(size_type __n, char __c, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
                this->_M_construct(__n, __c);
            }
;
            constexpr basic_string(basic_string<char> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator())) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            constexpr basic_string(initializer_list<char> __l, const std::allocator<char> &__a);
            constexpr basic_string(const basic_string<char> &__str, const std::allocator<char> &__a);
            constexpr basic_string(basic_string<char> &&__str, const std::allocator<char> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
            template<> constexpr basic_string<char *, void>(char *__beg, char *__end, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a), _M_string_length(0) {
                this->_M_construct(__beg, __end, std::__iterator_category(__beg));
            }
;
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<char> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char> &__a);
            constexpr ~basic_string<char>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<char> &operator=(const basic_string<char> &__str);
            constexpr basic_string<char> &operator=(const char *__s);
            constexpr basic_string<char> &operator=(char __c);
            constexpr basic_string<char> &operator=(basic_string<char> &&__str);
            constexpr basic_string<char> &operator=(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]] {
                return this->_M_string_length;
            }
            constexpr size_type length() const noexcept [[nodiscard("")]] {
                return this->_M_string_length;
            }
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, char __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]] {
                return this->_M_is_local() ? size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::reserve(size_type __res) {
                const size_type __capacity = this->capacity();
                if (__res <= __capacity)
                    return;
                pointer __tmp = this->_M_create(__res, __capacity);
                this->_S_copy(__tmp, this->_M_data(), this->length() + 1);
                this->_M_dispose();
                this->_M_data(__tmp);
                this->_M_capacity(__res);
            }
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept {
                this->_M_set_length(0);
            }
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]] {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                ;
                return this->_M_data()[__pos];
            }
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<char> &operator+=(const basic_string<char> &__str);
            constexpr basic_string<char> &operator+=(const char *__s);
            constexpr basic_string<char> &operator+=(char __c) {
                this->push_back(__c);
                return *this;
            }
            constexpr basic_string<char> &operator+=(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<char> &append(const basic_string<char> &__str) {
                return this->append(__str._M_data(), __str.size());
            }
            constexpr basic_string<char> &append(const basic_string<char> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char> &append(const char *__s, size_type __n) {
                ;
                this->_M_check_length(size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr basic_string<char> &append(const char *__s) {
                ;
                const size_type __n = traits_type::length(__s);
                this->_M_check_length(size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr basic_string<char> &append(size_type __n, char __c);
            constexpr basic_string<char> &append(initializer_list<char> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(char __c) {
                const size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, size_type(0), 0, size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            constexpr basic_string<char> &assign(const basic_string<char> &__str);
            constexpr basic_string<char> &assign(basic_string<char> &&__str);
            constexpr basic_string<char> &assign(const basic_string<char> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char> &assign(const char *__s, size_type __n);
            constexpr basic_string<char> &assign(const char *__s);
            constexpr basic_string<char> &assign(size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<char> &assign(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<char> __l);
            constexpr basic_string<char> &insert(size_type __pos1, const basic_string<char> &__str) {
                return this->replace(__pos1, size_type(0), __str._M_data(), __str.size());
            }
            constexpr basic_string<char> &insert(size_type __pos1, const basic_string<char> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<char> &insert(size_type __pos, const char *__s, size_type __n);
            constexpr basic_string<char> &insert(size_type __pos, const char *__s) {
                ;
                return this->replace(__pos, size_type(0), __s, traits_type::length(__s));
            }
            constexpr basic_string<char> &insert(size_type __pos, size_type __n, char __c);
            constexpr iterator insert(__const_iterator __p, char __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<char> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<char> &replace(size_type __pos, size_type __n, const basic_string<char> &__str);
            constexpr basic_string<char> &replace(size_type __pos1, size_type __n1, const basic_string<char> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s, size_type __n2) {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            constexpr basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s);
            constexpr basic_string<char> &replace(size_type __pos, size_type __n1, size_type __n2, char __c);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<char> &__str);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s, size_type __n);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, char *__k1, char *__k2);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__k1, const char *__k2);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<char> &replace(const_iterator __i1, const_iterator __i2, initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<char> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char __c);
            void _M_replace_cold(pointer __p, size_type __len1, const char *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<char> &basic_string<char, char_traits<char>, allocator<char>>::_M_replace(size_type __pos, size_type __len1, const char *__s, const size_type __len2) {
                this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
                const size_type __old_size = this->size();
                const size_type __new_size = __old_size + __len2 - __len1;
                if (__new_size <= this->capacity()) {
                    pointer __p = this->_M_data() + __pos;
                    const size_type __how_much = __old_size - __pos - __len1;
                    if (std::is_constant_evaluated()) {
                        auto __newp = _S_allocate(this->_M_get_allocator(), __new_size);
                        _S_copy(__newp, this->_M_data(), __pos);
                        _S_copy(__newp + __pos, __s, __len2);
                        _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
                        _S_copy(this->_M_data(), __newp, __new_size);
                        this->_M_get_allocator().deallocate(__newp, __new_size);
                    } else if (__builtin_expect(this->_M_disjunct(__s), true)) {
                        if (__how_much && __len1 != __len2)
                            this->_S_move(__p + __len2, __p + __len1, __how_much);
                        if (__len2)
                            this->_S_copy(__p, __s, __len2);
                    } else
                        this->_M_replace_cold(__p, __len1, __s, __len2, __how_much);
                } else
                    this->_M_mutate(__pos, __len1, __s, __len2);
                this->_M_set_length(__new_size);
                return *this;
            }
            constexpr basic_string<char> &basic_string<char, char_traits<char>, allocator<char>>::_M_append(const char *__s, size_type __n) {
                const size_type __len = __n + this->size();
                if (__len <= this->capacity()) {
                    if (__n)
                        this->_S_copy(this->_M_data() + this->size(), __s, __n);
                } else
                    this->_M_mutate(this->size(), size_type(0), __s, __n);
                this->_M_set_length(__len);
                return *this;
            }
        public:
            constexpr size_type basic_string<char, char_traits<char>, allocator<char>>::copy(char *__s, size_type __n, size_type __pos = 0) const {
                this->_M_check(__pos, "basic_string::copy");
                __n = this->_M_limit(__pos, __n);
                ;
                if (__n)
                    _S_copy(__s, this->_M_data() + __pos, __n);
                return __n;
            }
            constexpr void swap(basic_string<char> &__s) noexcept;
            constexpr const char *c_str() const noexcept [[nodiscard("")]] {
                return this->_M_data();
            }
            constexpr const char *data() const noexcept [[nodiscard("")]];
            constexpr char *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]] {
                return this->_M_get_allocator();
            }
            constexpr size_type find(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const char *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<char> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<char> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<char> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<char> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const char *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<char, char_traits<char>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(char __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const char *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<char, char_traits<char>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(char __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const char *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
        template<> class basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t>>::rebind<wchar_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef typename char_traits<wchar_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<wchar_t>, char_traits<wchar_t>>)
                    ;
                return __p;
            }
            typedef basic_string_view<wchar_t, char_traits<wchar_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>>, __not_<is_convertible<const _Tp &, const wchar_t *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<wchar_t> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(wchar_t)
            };
            union {
                wchar_t _M_local_buf[4];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], wchar_t());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::input_iterator_tag);
            template<> constexpr void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<wchar_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            template<> constexpr void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<wchar_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(size_type __req, wchar_t __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = wchar_t();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const;
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept;
            bool _M_disjunct(const wchar_t *__s) const noexcept;
            static constexpr void _S_copy(wchar_t *__d, const wchar_t *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(wchar_t *__d, const wchar_t *__s, size_type __n);
            static constexpr void _S_assign(wchar_t *__d, size_type __n, wchar_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<wchar_t *>(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
            template<> static constexpr void _S_copy_chars<const wchar_t *>(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2);
            static constexpr void _S_copy_chars(wchar_t *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(wchar_t *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<wchar_t> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const wchar_t *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<wchar_t> &__a) noexcept;
            constexpr basic_string(const basic_string<wchar_t> &__str);
            constexpr basic_string(const basic_string<wchar_t> &__str, size_type __pos, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<wchar_t> &__str, size_type __pos, size_type __n, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const wchar_t *__s, size_type __n, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<wchar_t>>> constexpr basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            template<> constexpr basic_string<std::allocator<wchar_t>>(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            template <typename = _RequireAllocator<allocator<wchar_t>>> constexpr basic_string(size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
            constexpr basic_string(basic_string<wchar_t> &&__str) noexcept;
            constexpr basic_string(initializer_list<wchar_t> __l, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const basic_string<wchar_t> &__str, const std::allocator<wchar_t> &__a);
            constexpr basic_string(basic_string<wchar_t> &&__str, const std::allocator<wchar_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
            template<> constexpr basic_string<wchar_t *, void>(wchar_t *__beg, wchar_t *__end, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a), _M_string_length(0) {
                this->_M_construct(__beg, __end, std::__iterator_category(__beg));
            }
;
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<wchar_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<wchar_t> &__a);
            constexpr ~basic_string<wchar_t>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<wchar_t> &operator=(const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &operator=(const wchar_t *__s);
            constexpr basic_string<wchar_t> &operator=(wchar_t __c);
            constexpr basic_string<wchar_t> &operator=(basic_string<wchar_t> &&__str);
            constexpr basic_string<wchar_t> &operator=(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]];
            constexpr size_type length() const noexcept [[nodiscard("")]];
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, wchar_t __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]];
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]];
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<wchar_t> &operator+=(const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &operator+=(const wchar_t *__s);
            constexpr basic_string<wchar_t> &operator+=(wchar_t __c);
            constexpr basic_string<wchar_t> &operator+=(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<wchar_t> &append(const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &append(const basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<wchar_t> &append(const wchar_t *__s, size_type __n);
            constexpr basic_string<wchar_t> &append(const wchar_t *__s);
            constexpr basic_string<wchar_t> &append(size_type __n, wchar_t __c);
            constexpr basic_string<wchar_t> &append(initializer_list<wchar_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<wchar_t> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(wchar_t __c);
            constexpr basic_string<wchar_t> &assign(const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &assign(basic_string<wchar_t> &&__str);
            constexpr basic_string<wchar_t> &assign(const basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<wchar_t> &assign(const wchar_t *__s, size_type __n);
            constexpr basic_string<wchar_t> &assign(const wchar_t *__s);
            constexpr basic_string<wchar_t> &assign(size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<wchar_t> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<wchar_t> &assign(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<wchar_t> __l);
            constexpr basic_string<wchar_t> &insert(size_type __pos1, const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &insert(size_type __pos1, const basic_string<wchar_t> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s, size_type __n);
            constexpr basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s);
            constexpr basic_string<wchar_t> &insert(size_type __pos, size_type __n, wchar_t __c);
            constexpr iterator insert(__const_iterator __p, wchar_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<wchar_t> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<wchar_t> &replace(size_type __pos, size_type __n, const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const basic_string<wchar_t> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2);
            constexpr basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s);
            constexpr basic_string<wchar_t> &replace(size_type __pos, size_type __n1, size_type __n2, wchar_t __c);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s, size_type __n);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<wchar_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, wchar_t __c);
            void _M_replace_cold(pointer __p, size_type __len1, const wchar_t *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<wchar_t> &_M_replace(size_type __pos, size_type __len1, const wchar_t *__s, const size_type __len2);
            constexpr basic_string<wchar_t> &_M_append(const wchar_t *__s, size_type __n);
        public:
            constexpr size_type copy(wchar_t *__s, size_type __n, size_type __pos) const;
            constexpr void swap(basic_string<wchar_t> &__s) noexcept;
            constexpr const wchar_t *c_str() const noexcept [[nodiscard("")]] {
                return this->_M_data();
            }
            constexpr const wchar_t *data() const noexcept [[nodiscard("")]];
            constexpr wchar_t *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]];
            constexpr size_type find(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const wchar_t *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<wchar_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<wchar_t> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<wchar_t> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<wchar_t> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const wchar_t *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const wchar_t *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<wchar_t, char_traits<wchar_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(wchar_t __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const wchar_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<wchar_t, char_traits<wchar_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(wchar_t __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const wchar_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
        template<> class basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char8_t>>::rebind<char8_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char8_t> traits_type;
            typedef typename char_traits<char8_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<char8_t>, char_traits<char8_t>>)
                    ;
                return __p;
            }
            typedef basic_string_view<char8_t, char_traits<char8_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>>, __not_<is_convertible<const _Tp &, const char8_t *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<char8_t> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char8_t)
            };
            union {
                char8_t _M_local_buf[16];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char8_t());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char8_t *>(const char8_t *__beg, const char8_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>::_M_construct<const char8_t *>(const char8_t *__beg, const char8_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char8_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(size_type __req, char8_t __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = char8_t();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const;
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept;
            bool _M_disjunct(const char8_t *__s) const noexcept;
            static constexpr void _S_copy(char8_t *__d, const char8_t *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char8_t *__d, const char8_t *__s, size_type __n);
            static constexpr void _S_assign(char8_t *__d, size_type __n, char8_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char8_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<const char8_t *>(char8_t *__p, const char8_t *__k1, const char8_t *__k2);
            static constexpr void _S_copy_chars(char8_t *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, char8_t *__k1, char8_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, const char8_t *__k1, const char8_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<char8_t> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const char8_t *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char8_t> &__a) noexcept;
            constexpr basic_string(const basic_string<char8_t> &__str);
            constexpr basic_string(const basic_string<char8_t> &__str, size_type __pos, const std::allocator<char8_t> &__a);
            constexpr basic_string(const basic_string<char8_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<char8_t> &__str, size_type __pos, size_type __n, const std::allocator<char8_t> &__a);
            constexpr basic_string(const char8_t *__s, size_type __n, const std::allocator<char8_t> &__a = std::allocator<char8_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<char8_t>>> constexpr basic_string(const char8_t *__s, const std::allocator<char8_t> &__a);
            template<> constexpr basic_string<std::allocator<char8_t>>(const char8_t *__s, const std::allocator<char8_t> &__a);
            template <typename = _RequireAllocator<allocator<char8_t>>> constexpr basic_string(size_type __n, char8_t __c, const std::allocator<char8_t> &__a);
            constexpr basic_string(basic_string<char8_t> &&__str) noexcept;
            constexpr basic_string(initializer_list<char8_t> __l, const std::allocator<char8_t> &__a);
            constexpr basic_string(const basic_string<char8_t> &__str, const std::allocator<char8_t> &__a);
            constexpr basic_string(basic_string<char8_t> &&__str, const std::allocator<char8_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char8_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<char8_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char8_t> &__a);
            constexpr ~basic_string<char8_t>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<char8_t> &operator=(const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &operator=(const char8_t *__s);
            constexpr basic_string<char8_t> &operator=(char8_t __c);
            constexpr basic_string<char8_t> &operator=(basic_string<char8_t> &&__str);
            constexpr basic_string<char8_t> &operator=(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]];
            constexpr size_type length() const noexcept [[nodiscard("")]];
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, char8_t __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]];
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]];
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<char8_t> &operator+=(const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &operator+=(const char8_t *__s);
            constexpr basic_string<char8_t> &operator+=(char8_t __c);
            constexpr basic_string<char8_t> &operator+=(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<char8_t> &append(const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &append(const basic_string<char8_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char8_t> &append(const char8_t *__s, size_type __n);
            constexpr basic_string<char8_t> &append(const char8_t *__s);
            constexpr basic_string<char8_t> &append(size_type __n, char8_t __c);
            constexpr basic_string<char8_t> &append(initializer_list<char8_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char8_t> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(char8_t __c);
            constexpr basic_string<char8_t> &assign(const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &assign(basic_string<char8_t> &&__str);
            constexpr basic_string<char8_t> &assign(const basic_string<char8_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char8_t> &assign(const char8_t *__s, size_type __n);
            constexpr basic_string<char8_t> &assign(const char8_t *__s);
            constexpr basic_string<char8_t> &assign(size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char8_t> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<char8_t> &assign(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<char8_t> __l);
            constexpr basic_string<char8_t> &insert(size_type __pos1, const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &insert(size_type __pos1, const basic_string<char8_t> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<char8_t> &insert(size_type __pos, const char8_t *__s, size_type __n);
            constexpr basic_string<char8_t> &insert(size_type __pos, const char8_t *__s);
            constexpr basic_string<char8_t> &insert(size_type __pos, size_type __n, char8_t __c);
            constexpr iterator insert(__const_iterator __p, char8_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<char8_t> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<char8_t> &replace(size_type __pos, size_type __n, const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &replace(size_type __pos1, size_type __n1, const basic_string<char8_t> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<char8_t> &replace(size_type __pos, size_type __n1, const char8_t *__s, size_type __n2);
            constexpr basic_string<char8_t> &replace(size_type __pos, size_type __n1, const char8_t *__s);
            constexpr basic_string<char8_t> &replace(size_type __pos, size_type __n1, size_type __n2, char8_t __c);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const char8_t *__s, size_type __n);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const char8_t *__s);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char8_t> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, char8_t *__k1, char8_t *__k2);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const char8_t *__k1, const char8_t *__k2);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<char8_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<char8_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<char8_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<char8_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char8_t __c);
            void _M_replace_cold(pointer __p, size_type __len1, const char8_t *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<char8_t> &_M_replace(size_type __pos, size_type __len1, const char8_t *__s, const size_type __len2);
            constexpr basic_string<char8_t> &_M_append(const char8_t *__s, size_type __n);
        public:
            constexpr size_type copy(char8_t *__s, size_type __n, size_type __pos) const;
            constexpr void swap(basic_string<char8_t> &__s) noexcept;
            constexpr const char8_t *c_str() const noexcept [[nodiscard("")]];
            constexpr const char8_t *data() const noexcept [[nodiscard("")]];
            constexpr char8_t *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]];
            constexpr size_type find(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const char8_t *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<char8_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<char8_t> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<char8_t> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<char8_t> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const char8_t *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char8_t *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char8_t *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<char8_t, char_traits<char8_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(char8_t __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const char8_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<char8_t, char_traits<char8_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(char8_t __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const char8_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
        template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t>>::rebind<char16_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<char16_t>, char_traits<char16_t>>)
                    ;
                return __p;
            }
            typedef basic_string_view<char16_t, char_traits<char16_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>, __not_<is_convertible<const _Tp &, const char16_t *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<char16_t> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char16_t());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char16_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(size_type __req, char16_t __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = char16_t();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const;
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static constexpr void _S_copy(char16_t *__d, const char16_t *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char16_t *__d, const char16_t *__s, size_type __n);
            static constexpr void _S_assign(char16_t *__d, size_type __n, char16_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<const char16_t *>(char16_t *__p, const char16_t *__k1, const char16_t *__k2);
            static constexpr void _S_copy_chars(char16_t *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<char16_t> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const char16_t *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            constexpr basic_string(const basic_string<char16_t> &__str);
            constexpr basic_string(const basic_string<char16_t> &__str, size_type __pos, const std::allocator<char16_t> &__a);
            constexpr basic_string(const basic_string<char16_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<char16_t> &__str, size_type __pos, size_type __n, const std::allocator<char16_t> &__a);
            constexpr basic_string(const char16_t *__s, size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<char16_t>>> constexpr basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            template<> constexpr basic_string<std::allocator<char16_t>>(const char16_t *__s, const std::allocator<char16_t> &__a);
            template <typename = _RequireAllocator<allocator<char16_t>>> constexpr basic_string(size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            constexpr basic_string(basic_string<char16_t> &&__str) noexcept;
            constexpr basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            constexpr basic_string(const basic_string<char16_t> &__str, const std::allocator<char16_t> &__a);
            constexpr basic_string(basic_string<char16_t> &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char16_t> &__a);
            constexpr ~basic_string<char16_t>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<char16_t> &operator=(const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &operator=(const char16_t *__s);
            constexpr basic_string<char16_t> &operator=(char16_t __c);
            constexpr basic_string<char16_t> &operator=(basic_string<char16_t> &&__str);
            constexpr basic_string<char16_t> &operator=(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]];
            constexpr size_type length() const noexcept [[nodiscard("")]];
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, char16_t __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]];
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]];
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<char16_t> &operator+=(const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &operator+=(const char16_t *__s);
            constexpr basic_string<char16_t> &operator+=(char16_t __c);
            constexpr basic_string<char16_t> &operator+=(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<char16_t> &append(const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &append(const basic_string<char16_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char16_t> &append(const char16_t *__s, size_type __n);
            constexpr basic_string<char16_t> &append(const char16_t *__s);
            constexpr basic_string<char16_t> &append(size_type __n, char16_t __c);
            constexpr basic_string<char16_t> &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char16_t> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(char16_t __c);
            constexpr basic_string<char16_t> &assign(const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &assign(basic_string<char16_t> &&__str);
            constexpr basic_string<char16_t> &assign(const basic_string<char16_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char16_t> &assign(const char16_t *__s, size_type __n);
            constexpr basic_string<char16_t> &assign(const char16_t *__s);
            constexpr basic_string<char16_t> &assign(size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char16_t> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<char16_t> &assign(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<char16_t> __l);
            constexpr basic_string<char16_t> &insert(size_type __pos1, const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &insert(size_type __pos1, const basic_string<char16_t> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<char16_t> &insert(size_type __pos, const char16_t *__s, size_type __n);
            constexpr basic_string<char16_t> &insert(size_type __pos, const char16_t *__s);
            constexpr basic_string<char16_t> &insert(size_type __pos, size_type __n, char16_t __c);
            constexpr iterator insert(__const_iterator __p, char16_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<char16_t> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<char16_t> &replace(size_type __pos, size_type __n, const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &replace(size_type __pos1, size_type __n1, const basic_string<char16_t> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<char16_t> &replace(size_type __pos, size_type __n1, const char16_t *__s, size_type __n2);
            constexpr basic_string<char16_t> &replace(size_type __pos, size_type __n1, const char16_t *__s);
            constexpr basic_string<char16_t> &replace(size_type __pos, size_type __n1, size_type __n2, char16_t __c);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const char16_t *__s, size_type __n);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const char16_t *__s);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char16_t> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, char16_t *__k1, char16_t *__k2);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<char16_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<char16_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<char16_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<char16_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char16_t __c);
            void _M_replace_cold(pointer __p, size_type __len1, const char16_t *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<char16_t> &_M_replace(size_type __pos, size_type __len1, const char16_t *__s, const size_type __len2);
            constexpr basic_string<char16_t> &_M_append(const char16_t *__s, size_type __n);
        public:
            constexpr size_type copy(char16_t *__s, size_type __n, size_type __pos) const;
            constexpr void swap(basic_string<char16_t> &__s) noexcept;
            constexpr const char16_t *c_str() const noexcept [[nodiscard("")]];
            constexpr const char16_t *data() const noexcept [[nodiscard("")]];
            constexpr char16_t *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]];
            constexpr size_type find(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const char16_t *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<char16_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<char16_t> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<char16_t> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<char16_t> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const char16_t *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char16_t *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char16_t *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<char16_t, char_traits<char16_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(char16_t __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const char16_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<char16_t, char_traits<char16_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(char16_t __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const char16_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
        template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t>>::rebind<char32_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<char32_t>, char_traits<char32_t>>)
                    ;
                return __p;
            }
            typedef basic_string_view<char32_t, char_traits<char32_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>, __not_<is_convertible<const _Tp &, const char32_t *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<char32_t> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char32_t());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char32_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(size_type __req, char32_t __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = char32_t();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const;
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static constexpr void _S_copy(char32_t *__d, const char32_t *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char32_t *__d, const char32_t *__s, size_type __n);
            static constexpr void _S_assign(char32_t *__d, size_type __n, char32_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<const char32_t *>(char32_t *__p, const char32_t *__k1, const char32_t *__k2);
            static constexpr void _S_copy_chars(char32_t *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<char32_t> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const char32_t *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            constexpr basic_string(const basic_string<char32_t> &__str);
            constexpr basic_string(const basic_string<char32_t> &__str, size_type __pos, const std::allocator<char32_t> &__a);
            constexpr basic_string(const basic_string<char32_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<char32_t> &__str, size_type __pos, size_type __n, const std::allocator<char32_t> &__a);
            constexpr basic_string(const char32_t *__s, size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<char32_t>>> constexpr basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            template<> constexpr basic_string<std::allocator<char32_t>>(const char32_t *__s, const std::allocator<char32_t> &__a);
            template <typename = _RequireAllocator<allocator<char32_t>>> constexpr basic_string(size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            constexpr basic_string(basic_string<char32_t> &&__str) noexcept;
            constexpr basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            constexpr basic_string(const basic_string<char32_t> &__str, const std::allocator<char32_t> &__a);
            constexpr basic_string(basic_string<char32_t> &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char32_t> &__a);
            constexpr ~basic_string<char32_t>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<char32_t> &operator=(const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &operator=(const char32_t *__s);
            constexpr basic_string<char32_t> &operator=(char32_t __c);
            constexpr basic_string<char32_t> &operator=(basic_string<char32_t> &&__str);
            constexpr basic_string<char32_t> &operator=(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]];
            constexpr size_type length() const noexcept [[nodiscard("")]];
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, char32_t __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]];
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]];
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<char32_t> &operator+=(const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &operator+=(const char32_t *__s);
            constexpr basic_string<char32_t> &operator+=(char32_t __c);
            constexpr basic_string<char32_t> &operator+=(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<char32_t> &append(const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &append(const basic_string<char32_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char32_t> &append(const char32_t *__s, size_type __n);
            constexpr basic_string<char32_t> &append(const char32_t *__s);
            constexpr basic_string<char32_t> &append(size_type __n, char32_t __c);
            constexpr basic_string<char32_t> &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char32_t> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(char32_t __c);
            constexpr basic_string<char32_t> &assign(const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &assign(basic_string<char32_t> &&__str);
            constexpr basic_string<char32_t> &assign(const basic_string<char32_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char32_t> &assign(const char32_t *__s, size_type __n);
            constexpr basic_string<char32_t> &assign(const char32_t *__s);
            constexpr basic_string<char32_t> &assign(size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char32_t> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<char32_t> &assign(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<char32_t> __l);
            constexpr basic_string<char32_t> &insert(size_type __pos1, const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &insert(size_type __pos1, const basic_string<char32_t> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<char32_t> &insert(size_type __pos, const char32_t *__s, size_type __n);
            constexpr basic_string<char32_t> &insert(size_type __pos, const char32_t *__s);
            constexpr basic_string<char32_t> &insert(size_type __pos, size_type __n, char32_t __c);
            constexpr iterator insert(__const_iterator __p, char32_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<char32_t> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<char32_t> &replace(size_type __pos, size_type __n, const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &replace(size_type __pos1, size_type __n1, const basic_string<char32_t> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<char32_t> &replace(size_type __pos, size_type __n1, const char32_t *__s, size_type __n2);
            constexpr basic_string<char32_t> &replace(size_type __pos, size_type __n1, const char32_t *__s);
            constexpr basic_string<char32_t> &replace(size_type __pos, size_type __n1, size_type __n2, char32_t __c);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const char32_t *__s, size_type __n);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const char32_t *__s);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char32_t> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, char32_t *__k1, char32_t *__k2);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<char32_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<char32_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<char32_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<char32_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char32_t __c);
            void _M_replace_cold(pointer __p, size_type __len1, const char32_t *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<char32_t> &_M_replace(size_type __pos, size_type __len1, const char32_t *__s, const size_type __len2);
            constexpr basic_string<char32_t> &_M_append(const char32_t *__s, size_type __n);
        public:
            constexpr size_type copy(char32_t *__s, size_type __n, size_type __pos) const;
            constexpr void swap(basic_string<char32_t> &__s) noexcept;
            constexpr const char32_t *c_str() const noexcept [[nodiscard("")]];
            constexpr const char32_t *data() const noexcept [[nodiscard("")]];
            constexpr char32_t *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]];
            constexpr size_type find(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const char32_t *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<char32_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<char32_t> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<char32_t> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<char32_t> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const char32_t *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char32_t *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char32_t *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<char32_t, char_traits<char32_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(char32_t __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const char32_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<char32_t, char_traits<char32_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(char32_t __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const char32_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;
    typedef basic_string<char8_t> u8string;
    typedef basic_string<char16_t> u16string;
    typedef basic_string<char32_t> u32string;
}
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;
typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
typedef unsigned int wint_t;
typedef struct {
    int __count;
    union {
        unsigned int __wch;
        char __wchb[4];
    } __value;
} __mbstate_t;
typedef __mbstate_t mbstate_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct __locale_struct {
    struct __locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern "C" {
    struct tm;
    extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true) __attribute__((nonnull(1, 2)));
    extern size_t wcslcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true) __attribute__((nonnull(1, 2)));
    extern size_t wcslcat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);
    extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true);
    extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) noexcept(true);
    extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) noexcept(true);
    extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);
    extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) noexcept(true);
    extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) noexcept(true);
    extern wchar_t *wcsdup(const wchar_t *__s) noexcept(true) __attribute__((malloc));
    extern wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) noexcept(true) __attribute__((pure));
    extern size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) noexcept(true) __attribute__((pure));
    extern wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) noexcept(true) __attribute__((pure));
    extern wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) noexcept(true) __attribute__((pure));
    extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) noexcept(true);
    extern size_t wcslen(const wchar_t *__s) noexcept(true) __attribute__((pure));
    extern wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) noexcept(true) __attribute__((pure));
    extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) noexcept(true) __attribute__((pure));
    extern wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) noexcept(true) __attribute__((pure));
    extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true) __attribute__((pure));
    extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true);
    extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) noexcept(true);
    extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern wint_t btowc(int __c) noexcept(true);
    extern int wctob(wint_t __c) noexcept(true);
    extern int mbsinit(const mbstate_t *__ps) noexcept(true) __attribute__((pure));
    extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n, mbstate_t *__restrict __p) noexcept(true);
    extern size_t wcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t __mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern int wcwidth(wchar_t __c) noexcept(true);
    extern int wcswidth(const wchar_t *__s, size_t __n) noexcept(true);
    extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float32 wcstof32(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float64 wcstof64(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float32x wcstof32x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float64x wcstof64x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern long wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long long wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long long wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long long wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long long wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_wcstol");
    extern unsigned long wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_wcstoul");
    extern long long wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_wcstoll");
    extern unsigned long long wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_wcstoull");
    extern long long wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_wcstoll");
    extern unsigned long long wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_wcstoull");
    extern long wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern unsigned long wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern long long wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern unsigned long long wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern long wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true) asm("__isoc23_wcstol_l");
    extern unsigned long wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true) asm("__isoc23_wcstoul_l");
    extern long long wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true) asm("__isoc23_wcstoll_l");
    extern unsigned long long wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true) asm("__isoc23_wcstoull_l");
    extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float32 wcstof32_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float64 wcstof64_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float32x wcstof32x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float64x wcstof64x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true);
    extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true);
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern int fwide(__FILE *__fp, int __mode) noexcept(true);
    extern int fwprintf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wprintf(const wchar_t *__restrict __format, ...);
    extern int swprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, ...) noexcept(true);
    extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wscanf(const wchar_t *__restrict __format, ...);
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept(true);
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) asm("__isoc23_fwscanf");
    extern int wscanf(const wchar_t *__restrict __format, ...) asm("__isoc23_wscanf");
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept(true) asm("__isoc23_swscanf");
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc23_vfwscanf");
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc23_vwscanf");
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true) asm("__isoc23_vswscanf");
    extern wint_t fgetwc(__FILE *__stream);
    extern wint_t getwc(__FILE *__stream);
    extern wint_t getwchar();
    extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar(wchar_t __wc);
    extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
    extern wint_t getwc_unlocked(__FILE *__stream);
    extern wint_t getwchar_unlocked();
    extern wint_t fgetwc_unlocked(__FILE *__stream);
    extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar_unlocked(wchar_t __wc);
    extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws_unlocked(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp) noexcept(true);
    extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) noexcept(true);
}
namespace std {
    using ::mbstate_t;
}
extern "C++" {
    namespace std {
        using ::wint_t;
        using ::btowc;
        using ::fgetwc;
        using ::fgetws;
        using ::fputwc;
        using ::fputws;
        using ::fwide;
        using ::fwprintf;
        using ::fwscanf;
        using ::getwc;
        using ::getwchar;
        using ::mbrlen;
        using ::mbrtowc;
        using ::mbsinit;
        using ::mbsrtowcs;
        using ::putwc;
        using ::putwchar;
        using ::swprintf;
        using ::swscanf;
        using ::ungetwc;
        using ::vfwprintf;
        using ::vfwscanf;
        using ::vswprintf;
        using ::vswscanf;
        using ::vwprintf;
        using ::vwscanf;
        using ::wcrtomb;
        using ::wcscat;
        using ::wcscmp;
        using ::wcscoll;
        using ::wcscpy;
        using ::wcscspn;
        using ::wcsftime;
        using ::wcslen;
        using ::wcsncat;
        using ::wcsncmp;
        using ::wcsncpy;
        using ::wcsrtombs;
        using ::wcsspn;
        using ::wcstod;
        using ::wcstof;
        using ::wcstok;
        using ::wcstol;
        using ::wcstoul;
        using ::wcsxfrm;
        using ::wctob;
        using ::wmemcmp;
        using ::wmemcpy;
        using ::wmemmove;
        using ::wmemset;
        using ::wprintf;
        using ::wscanf;
        using ::wcschr;
        using ::wcspbrk;
        using ::wcsrchr;
        using ::wcsstr;
        using ::wmemchr;
        inline wchar_t *wcschr(wchar_t *__p, wchar_t __c) {
            return wcschr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2) {
            return wcspbrk(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wcsrchr(wchar_t *__p, wchar_t __c) {
            return wcsrchr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2) {
            return wcsstr(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wmemchr(wchar_t *__p, wchar_t __c, size_t __n) {
            return wmemchr(const_cast<const wchar_t *>(__p), __c, __n);
        }
    }
}
namespace __gnu_cxx {
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::__gnu_cxx::wcstold;
    using ::__gnu_cxx::wcstoll;
    using ::__gnu_cxx::wcstoull;
}
namespace std {
    using std::wcstof;
    using std::vfwscanf;
    using std::vswscanf;
    using std::vwscanf;
    using std::wcstold;
    using std::wcstoll;
    using std::wcstoull;
}
namespace std {
    typedef long streamoff;
    typedef ptrdiff_t streamsize;
    template <typename _StateT> class fpos {
    private:
        streamoff _M_off;
        _StateT _M_state;
    public:
        fpos<_StateT>() : _M_off(0), _M_state() {
        }
        fpos<_StateT>(streamoff __off) : _M_off(__off), _M_state() {
        }
        fpos<_StateT>(const fpos<_StateT> &) = default
        fpos<_StateT> &operator=(const fpos<_StateT> &) = default
        ~fpos<_StateT>() = default
        operator streamoff() const {
            return this->_M_off;
        }
        void state(_StateT __st) {
            this->_M_state = __st;
        }
        _StateT state() const {
            return this->_M_state;
        }
        fpos<_StateT> &operator+=(streamoff __off) {
            this->_M_off += __off;
            return *this;
        }
        fpos<_StateT> &operator-=(streamoff __off) {
            this->_M_off -= __off;
            return *this;
        }
        fpos<_StateT> operator+(streamoff __off) const {
            fpos<_StateT> __pos(*this);
            __pos += __off;
            return __pos;
        }
        fpos<_StateT> operator-(streamoff __off) const {
            fpos<_StateT> __pos(*this);
            __pos -= __off;
            return __pos;
        }
        streamoff operator-(const fpos<_StateT> &__other) const {
            return this->_M_off - __other._M_off;
        }
    };
    template <typename _StateT> inline bool operator==(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs) {
        return streamoff(__lhs) == streamoff(__rhs);
    }
    template <typename _StateT> inline bool operator!=(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs) {
        return streamoff(__lhs) != streamoff(__rhs);
    }
    typedef fpos<mbstate_t> streampos;
    typedef fpos<mbstate_t> wstreampos;
    typedef fpos<mbstate_t> u8streampos;
    typedef fpos<mbstate_t> u16streampos;
    typedef fpos<mbstate_t> u32streampos;
}
namespace std {
    class ios_base;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringbuf;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_istringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_ostringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringstream;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_filebuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ifstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ofstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_fstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    typedef basic_ios<char> ios;
    typedef basic_streambuf<char> streambuf;
    typedef basic_istream<char> istream;
    typedef basic_ostream<char> ostream;
    typedef basic_iostream<char> iostream;
    typedef basic_stringbuf<char> stringbuf;
    typedef basic_istringstream<char> istringstream;
    typedef basic_ostringstream<char> ostringstream;
    typedef basic_stringstream<char> stringstream;
    typedef basic_filebuf<char> filebuf;
    typedef basic_ifstream<char> ifstream;
    typedef basic_ofstream<char> ofstream;
    typedef basic_fstream<char> fstream;
    typedef basic_ios<wchar_t> wios;
    typedef basic_streambuf<wchar_t> wstreambuf;
    typedef basic_istream<wchar_t> wistream;
    typedef basic_ostream<wchar_t> wostream;
    typedef basic_iostream<wchar_t> wiostream;
    typedef basic_stringbuf<wchar_t> wstringbuf;
    typedef basic_istringstream<wchar_t> wistringstream;
    typedef basic_ostringstream<wchar_t> wostringstream;
    typedef basic_stringstream<wchar_t> wstringstream;
    typedef basic_filebuf<wchar_t> wfilebuf;
    typedef basic_ifstream<wchar_t> wifstream;
    typedef basic_ofstream<wchar_t> wofstream;
    typedef basic_fstream<wchar_t> wfstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Allocator = allocator<_CharT>> class basic_syncbuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Allocator = allocator<_CharT>> class basic_osyncstream;
    using syncbuf = basic_syncbuf<char>;
    using osyncstream = basic_osyncstream<char>;
    using wsyncbuf = basic_syncbuf<wchar_t>;
    using wosyncstream = basic_osyncstream<wchar_t>;
}
extern "C++" {
    namespace std {
        class exception {
        public:
            exception() noexcept {
            }
            virtual ~exception() noexcept;
            exception(const exception &) = default
            exception &operator=(const exception &) = default
            exception(exception &&) = default
            exception &operator=(exception &&) = default
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class bad_exception : public exception {
        public:
            bad_exception() noexcept : exception() {
            }
            virtual ~bad_exception() noexcept;
            virtual const char *what() const noexcept;
        };
        typedef void (*terminate_handler)();
        terminate_handler set_terminate(terminate_handler) noexcept;
        terminate_handler get_terminate() noexcept;
        void terminate() noexcept;
        typedef void (*unexpected_handler)() __attribute__((deprecated("")));
        unexpected_handler set_unexpected(unexpected_handler) noexcept __attribute__((deprecated("")));
        unexpected_handler get_unexpected() noexcept __attribute__((deprecated("")));
        void unexpected() __attribute__((deprecated("")));
        bool uncaught_exception() noexcept __attribute__((deprecated("use 'std::uncaught_exceptions()' instead"))) __attribute__((pure));
        int uncaught_exceptions() noexcept __attribute__((pure));
    }
    namespace __gnu_cxx {
        void __verbose_terminate_handler();
    }
}
typedef long ptrdiff_t;
typedef unsigned long size_t;
typedef unsigned long rsize_t;
typedef struct {
    long long __clang_max_align_nonce1 __attribute__((aligned(__alignof(long long))));
    long double __clang_max_align_nonce2 __attribute__((aligned(__alignof(long double))));
} max_align_t;
namespace std {
    class type_info;
}
namespace __cxxabiv1 {
    struct __cxa_refcounted_exception;
    extern "C" {
        void *__cxa_allocate_exception(size_t) noexcept;
        void __cxa_free_exception(void *) noexcept;
        __cxa_refcounted_exception *__cxa_init_primary_exception(void *__object, std::type_info *__tinfo, void (*__dest)(void *)) noexcept;
    }
}
namespace std {
    size_t _Hash_bytes(const void *__ptr, size_t __len, size_t __seed);
    size_t _Fnv_hash_bytes(const void *__ptr, size_t __len, size_t __seed);
}
extern "C++" {
    namespace __cxxabiv1 {
        class __class_type_info;
    }
    namespace std {
        class type_info {
        public:
            virtual ~type_info() noexcept;
            const char *name() const noexcept {
                return this->__name[0] == '*' ? this->__name + 1 : this->__name;
            }
            bool before(const type_info &__arg) const noexcept;
            bool operator==(const type_info &__arg) const noexcept;
            size_t hash_code() const noexcept {
                return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast<size_t>(3339675911UL));
            }
            virtual bool __is_pointer_p() const;
            virtual bool __is_function_p() const;
            virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
            virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target, void **__obj_ptr) const;
        protected:
            const char *__name;
            explicit type_info(const char *__n) : __name(__n) {
            }
        private:
            type_info &operator=(const type_info &) = delete
            type_info(const type_info &) = delete
        };
        inline bool type_info::before(const type_info &__arg) const noexcept {
            if (this->__name[0] != '*' || __arg.__name[0] != '*')
                return __builtin_strcmp(this->__name, __arg.__name) < 0;
            return this->__name < __arg.__name;
        }
        inline bool type_info::operator==(const type_info &__arg) const noexcept {
            if (std::__is_constant_evaluated())
                return this == &__arg;
            if (this->__name == __arg.__name)
                return true;
            return this->__name[0] != '*' && __builtin_strcmp(this->__name, __arg.name()) == 0;
        }
        class bad_cast : public exception {
        public:
            bad_cast() noexcept : exception() {
            }
            virtual ~bad_cast() noexcept;
            virtual const char *what() const noexcept;
        };
        class bad_typeid : public exception {
        public:
            bad_typeid() noexcept : exception() {
            }
            virtual ~bad_typeid() noexcept;
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class bad_alloc : public exception {
        public:
            bad_alloc() throw() : exception() {
            }
            bad_alloc(const bad_alloc &) = default
            bad_alloc &operator=(const bad_alloc &) = default
            virtual ~bad_alloc() throw();
            virtual const char *what() const throw();
        };
        class bad_array_new_length : public bad_alloc {
        public:
            bad_array_new_length() throw() : bad_alloc() {
            }
            virtual ~bad_array_new_length() throw();
            virtual const char *what() const throw();
        };
        enum class align_val_t : size_t {
        };
        struct nothrow_t {
            explicit nothrow_t() = default
        };
        extern const nothrow_t nothrow;
        typedef void (*new_handler)();
        new_handler set_new_handler(new_handler) throw();
        new_handler get_new_handler() noexcept;
    }
    void *operator new(std::size_t) [[nodiscard("")]];
    void *operator new[](std::size_t) [[nodiscard("")]];
    void operator delete(void *) noexcept;
    void operator delete[](void *) noexcept;
    void *operator new(std::size_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void *operator new[](std::size_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void operator delete(void *, const std::nothrow_t &) noexcept;
    void operator delete[](void *, const std::nothrow_t &) noexcept;
    void *operator new(std::size_t, std::align_val_t) [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void *operator new(std::size_t, std::align_val_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void operator delete(void *, std::align_val_t) noexcept;
    void operator delete(void *, std::align_val_t, const std::nothrow_t &) noexcept;
    void *operator new[](std::size_t, std::align_val_t) [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void *operator new[](std::size_t, std::align_val_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void operator delete[](void *, std::align_val_t) noexcept;
    void operator delete[](void *, std::align_val_t, const std::nothrow_t &) noexcept;
    inline void *operator new(std::size_t, void *__p) noexcept [[nodiscard("")]] {
        return __p;
    }
    inline void *operator new[](std::size_t, void *__p) noexcept [[nodiscard("")]] {
        return __p;
    }
    inline void operator delete(void *, void *) noexcept {
    }
    inline void operator delete[](void *, void *) noexcept {
    }
}
namespace std {
    template <typename _Tp> constexpr _Tp *launder(_Tp *__p) noexcept [[nodiscard("")]] {
        return __builtin_launder(__p);
    }
    template <typename _Ret, typename ..._Args, bool _NE> void launder(_Ret (*)(_Args...) noexcept(_NE)) = delete
    template <typename _Ret, typename ..._Args, bool _NE> void launder(_Ret (*)(_Args..., ...) noexcept(_NE)) = delete
    void launder(void *) = delete
    void launder(const void *) = delete
    void launder(volatile void *) = delete
    void launder(const volatile void *) = delete
}
namespace std {
    struct destroying_delete_t {
        explicit destroying_delete_t() noexcept = default
    };
    constexpr destroying_delete_t destroying_delete{};
}
namespace std {
    template <typename _Tp> class reference_wrapper;
    template <typename _Tp, _Tp __v> struct integral_constant {
        static constexpr _Tp value = __v;
        typedef _Tp value_type;
        typedef integral_constant<_Tp, __v> type;
        constexpr operator value_type() const noexcept {
            return value;
        }
        constexpr value_type operator()() const noexcept {
            return value;
        }
    };
    template<> struct integral_constant<bool, true> {
        static constexpr bool value = true;
        typedef bool value_type;
        typedef integral_constant<bool, true> type;
        constexpr operator value_type() const noexcept {
            return value;
        }
        constexpr value_type operator()() const noexcept;
    };
    template<> struct integral_constant<bool, false> {
        static constexpr bool value = false;
        typedef bool value_type;
        typedef integral_constant<bool, false> type;
        constexpr operator value_type() const noexcept;
        constexpr value_type operator()() const noexcept;
    };
    template<> struct integral_constant<unsigned long, 0> {
        static constexpr unsigned long value;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 0UL> type;
        constexpr operator value_type() const noexcept;
        constexpr value_type operator()() const noexcept;
    };
    template<> struct integral_constant<unsigned long, 2> {
        static constexpr unsigned long value;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 2UL> type;
        constexpr operator value_type() const noexcept;
        constexpr value_type operator()() const noexcept;
    };
    using true_type = integral_constant<bool, true>;
    using false_type = integral_constant<bool, false>;
    template <bool __v> using __bool_constant = integral_constant<bool, __v>;
    template <bool __v> using bool_constant = integral_constant<bool, __v>;
    template <bool, typename _Tp = void> struct enable_if {
    };
    template<> struct enable_if<true, double> {
        typedef double type;
    };
    template<> struct enable_if<true, void> {
        typedef void type;
    };
    template<> struct enable_if<true, const char *const &> {
        typedef const char *const &type;
    };
    template<> struct enable_if<false, void> {
    };
    template<> struct enable_if<true, const char &> {
        typedef const char &type;
    };
    template<> struct enable_if<true, const unsigned long &> {
        typedef const unsigned long &type;
    };
    template<> struct enable_if<true, const wchar_t *const &> {
        typedef const wchar_t *const &type;
    };
    template<> struct enable_if<true, const wchar_t &> {
        typedef const wchar_t &type;
    };
    template<> struct enable_if<true, const char8_t *const &> {
        typedef const char8_t *const &type;
    };
    template<> struct enable_if<true, const char8_t &> {
        typedef const char8_t &type;
    };
    template<> struct enable_if<true, const char16_t *const &> {
        typedef const char16_t *const &type;
    };
    template<> struct enable_if<true, const char16_t &> {
        typedef const char16_t &type;
    };
    template<> struct enable_if<true, const char32_t *const &> {
        typedef const char32_t *const &type;
    };
    template<> struct enable_if<true, const char32_t &> {
        typedef const char32_t &type;
    };
    template<> struct enable_if<true, std::allocator<char>> {
        typedef std::allocator<char> type;
    };
    template<> struct enable_if<true, std::allocator<wchar_t>> {
        typedef std::allocator<wchar_t> type;
    };
    template<> struct enable_if<true, std::allocator<char8_t>> {
        typedef std::allocator<char8_t> type;
    };
    template<> struct enable_if<true, std::allocator<char16_t>> {
        typedef std::allocator<char16_t> type;
    };
    template<> struct enable_if<true, std::allocator<char32_t>> {
        typedef std::allocator<char32_t> type;
    };
    template<> struct enable_if<true, const std::error_category *const &> {
        typedef const std::error_category *const &type;
    };
    template<> struct enable_if<false, std::basic_string<char> &> {
    };
    template<> struct enable_if<true, const std::_Bit_iterator &> {
        typedef const std::_Bit_iterator &type;
    };
    template<> struct enable_if<false, bool> {
    };
    template<> struct enable_if<true, std::_Bit_reference &> {
        typedef std::_Bit_reference &type;
    };
    template<> struct enable_if<true, const std::_Bit_const_iterator &> {
        typedef const std::_Bit_const_iterator &type;
    };
    template<> struct enable_if<true, const bool &> {
        typedef const bool &type;
    };
    template<> struct enable_if<true, bool &> {
        typedef bool &type;
    };
    template <typename _Tp> struct enable_if<true, _Tp> {
        typedef _Tp type;
    };
    template <bool _Cond, typename _Tp = void> using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <bool> struct __conditional {
        template <typename _Tp, typename> using type = _Tp;
    };
    template<> struct __conditional<true> {
        template <typename _Tp, typename> using type = _Tp;
    };
    template<> struct __conditional<false> {
        template <typename, typename _Up> using type = _Up;
    };
    template <bool _Cond, typename _If, typename _Else> using __conditional_t = typename __conditional<_Cond>::template type<_If, _Else>;
    template <typename _Type> struct __type_identity {
        using type = _Type;
    };
    template<> struct __type_identity<std::allocator<char>> {
        using type = std::allocator<char>;
    };
    template<> struct __type_identity<std::_Bit_iterator> {
        using type = std::_Bit_iterator;
    };
    template<> struct __type_identity<std::_Bit_const_iterator> {
        using type = std::_Bit_const_iterator;
    };
    template<> struct __type_identity<unsigned long *> {
        using type = unsigned long *;
    };
    template<> struct __type_identity<std::allocator<int>> {
        using type = std::allocator<int>;
    };
    template<> struct __type_identity<int> {
        using type = int;
    };
    template<> struct __type_identity<std::allocator<Base<ChildA, ChildB, ChildC> *>> {
        using type = std::allocator<Base<ChildA, ChildB, ChildC> *>;
    };
    template<> struct __type_identity<Base<ChildA, ChildB, ChildC> *> {
        using type = Base<ChildA, ChildB, ChildC> *;
    };
    template<> struct __type_identity<const int *> {
        using type = const int *;
    };
    template<> struct __type_identity<int *> {
        using type = int *;
    };
    template<> struct __type_identity<Base<ChildA, ChildB, ChildC> *const *> {
        using type = Base<ChildA, ChildB, ChildC> *const *;
    };
    template<> struct __type_identity<Base<ChildA, ChildB, ChildC> **> {
        using type = Base<ChildA, ChildB, ChildC> **;
    };
    template <typename _Tp> using __type_identity_t = typename __type_identity<_Tp>::type;
    namespace __detail {
        template <typename _Tp, typename ...> using __first_t = _Tp;
        template <typename ..._Bn> auto __or_fn(int) -> __first_t<false_type, __enable_if_t<!bool(_Bn::value)>...>;
        template<> auto __or_fn<<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const char *>::value)>, __enable_if_t<!bool(is_reference<const char *>::value)>, __enable_if_t<!bool(is_void<const char *>::value)>>;
        template<> auto __or_fn<<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const char>::value)>, __enable_if_t<!bool(is_reference<const char>::value)>, __enable_if_t<!bool(is_void<const char>::value)>>;
        template<> auto __or_fn<<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<unsigned long>::value)>, __enable_if_t<!bool(is_reference<unsigned long>::value)>, __enable_if_t<!bool(is_void<unsigned long>::value)>>;
        template<> auto __or_fn<<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const wchar_t *>::value)>, __enable_if_t<!bool(is_reference<const wchar_t *>::value)>, __enable_if_t<!bool(is_void<const wchar_t *>::value)>>;
        template<> auto __or_fn<<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const wchar_t>::value)>, __enable_if_t<!bool(is_reference<const wchar_t>::value)>, __enable_if_t<!bool(is_void<const wchar_t>::value)>>;
        template<> auto __or_fn<<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const char8_t *>::value)>, __enable_if_t<!bool(is_reference<const char8_t *>::value)>, __enable_if_t<!bool(is_void<const char8_t *>::value)>>;
        template<> auto __or_fn<<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const char8_t>::value)>, __enable_if_t<!bool(is_reference<const char8_t>::value)>, __enable_if_t<!bool(is_void<const char8_t>::value)>>;
        template<> auto __or_fn<<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const char16_t *>::value)>, __enable_if_t<!bool(is_reference<const char16_t *>::value)>, __enable_if_t<!bool(is_void<const char16_t *>::value)>>;
        template<> auto __or_fn<<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const char16_t>::value)>, __enable_if_t<!bool(is_reference<const char16_t>::value)>, __enable_if_t<!bool(is_void<const char16_t>::value)>>;
        template<> auto __or_fn<<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const char32_t *>::value)>, __enable_if_t<!bool(is_reference<const char32_t *>::value)>, __enable_if_t<!bool(is_void<const char32_t *>::value)>>;
        template<> auto __or_fn<<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const char32_t>::value)>, __enable_if_t<!bool(is_reference<const char32_t>::value)>, __enable_if_t<!bool(is_void<const char32_t>::value)>>;
        template<> auto __or_fn<<std::is_reference<std::allocator<char>>, std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<allocator<char>>::value)>, __enable_if_t<!bool(is_function<allocator<char>>::value)>, __enable_if_t<!bool(is_void<allocator<char>>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<allocator<char>>::value)>>;
        template<> auto __or_fn<<std::is_function<std::_Bit_iterator>, std::is_reference<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<_Bit_iterator>::value)>, __enable_if_t<!bool(is_reference<_Bit_iterator>::value)>, __enable_if_t<!bool(is_void<_Bit_iterator>::value)>>;
        template<> auto __or_fn<<std::is_reference<std::_Bit_iterator>, std::is_function<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>, std::__is_array_unknown_bounds<std::_Bit_iterator>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<_Bit_iterator>::value)>, __enable_if_t<!bool(is_function<_Bit_iterator>::value)>, __enable_if_t<!bool(is_void<_Bit_iterator>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<_Bit_iterator>::value)>>;
        template<> auto __or_fn<<std::is_function<bool>, std::is_reference<bool>, std::is_void<bool>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<bool>::value)>, __enable_if_t<!bool(is_reference<bool>::value)>, __enable_if_t<!bool(is_void<bool>::value)>>;
        template<> auto __or_fn<<std::is_function<std::_Bit_const_iterator>, std::is_reference<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<_Bit_const_iterator>::value)>, __enable_if_t<!bool(is_reference<_Bit_const_iterator>::value)>, __enable_if_t<!bool(is_void<_Bit_const_iterator>::value)>>;
        template<> auto __or_fn<<std::is_reference<std::_Bit_const_iterator>, std::is_function<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>, std::__is_array_unknown_bounds<std::_Bit_const_iterator>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<_Bit_const_iterator>::value)>, __enable_if_t<!bool(is_function<_Bit_const_iterator>::value)>, __enable_if_t<!bool(is_void<_Bit_const_iterator>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<_Bit_const_iterator>::value)>>;
        template<> auto __or_fn<<std::is_reference<unsigned long *>, std::is_function<unsigned long *>, std::is_void<unsigned long *>, std::__is_array_unknown_bounds<unsigned long *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<unsigned long *>::value)>, __enable_if_t<!bool(is_function<unsigned long *>::value)>, __enable_if_t<!bool(is_void<unsigned long *>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<unsigned long *>::value)>>;
        template<> auto __or_fn<<std::is_function<const int>, std::is_reference<const int>, std::is_void<const int>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<const int>::value)>, __enable_if_t<!bool(is_reference<const int>::value)>, __enable_if_t<!bool(is_void<const int>::value)>>;
        template<> auto __or_fn<<std::is_function<int>, std::is_reference<int>, std::is_void<int>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<int>::value)>, __enable_if_t<!bool(is_reference<int>::value)>, __enable_if_t<!bool(is_void<int>::value)>>;
        template<> auto __or_fn<<std::is_void<int>, std::__is_array_unknown_bounds<int>, std::is_function<int>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_void<int>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<int>::value)>, __enable_if_t<!bool(is_function<int>::value)>>;
        template<> auto __or_fn<<std::is_reference<int>, std::is_function<int>, std::is_void<int>, std::__is_array_unknown_bounds<int>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<int>::value)>, __enable_if_t<!bool(is_function<int>::value)>, __enable_if_t<!bool(is_void<int>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<int>::value)>>;
        template<> auto __or_fn<<std::is_function<char>, std::is_reference<char>, std::is_void<char>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<char>::value)>, __enable_if_t<!bool(is_reference<char>::value)>, __enable_if_t<!bool(is_void<char>::value)>>;
        template<> auto __or_fn<<std::is_function<Base<ChildA, ChildB, ChildC> *const>, std::is_reference<Base<ChildA, ChildB, ChildC> *const>, std::is_void<Base<ChildA, ChildB, ChildC> *const>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<Base<ChildA, ChildB, ChildC> *const>::value)>, __enable_if_t<!bool(is_reference<Base<ChildA, ChildB, ChildC> *const>::value)>, __enable_if_t<!bool(is_void<Base<ChildA, ChildB, ChildC> *const>::value)>>;
        template<> auto __or_fn<<std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<Base<ChildA, ChildB, ChildC> *>::value)>, __enable_if_t<!bool(is_reference<Base<ChildA, ChildB, ChildC> *>::value)>, __enable_if_t<!bool(is_void<Base<ChildA, ChildB, ChildC> *>::value)>>;
        template<> auto __or_fn<<std::is_void<Base<ChildA, ChildB, ChildC> *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>, std::is_function<Base<ChildA, ChildB, ChildC> *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_void<Base<ChildA, ChildB, ChildC> *>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>::value)>, __enable_if_t<!bool(is_function<Base<ChildA, ChildB, ChildC> *>::value)>>;
        template<> auto __or_fn<<std::is_integral<Base<ChildA, ChildB, ChildC> *>, std::is_floating_point<Base<ChildA, ChildB, ChildC> *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_integral<Base<ChildA, ChildB, ChildC> *>::value)>, __enable_if_t<!bool(is_floating_point<Base<ChildA, ChildB, ChildC> *>::value)>>;
        template<> auto __or_fn<<std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<Base<ChildA, ChildB, ChildC> *>::value)>, __enable_if_t<!bool(is_function<Base<ChildA, ChildB, ChildC> *>::value)>, __enable_if_t<!bool(is_void<Base<ChildA, ChildB, ChildC> *>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>::value)>>;
        template<> auto __or_fn<<std::is_reference<std::allocator<int>>, std::is_function<std::allocator<int>>, std::is_void<std::allocator<int>>, std::__is_array_unknown_bounds<std::allocator<int>>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<allocator<int>>::value)>, __enable_if_t<!bool(is_function<allocator<int>>::value)>, __enable_if_t<!bool(is_void<allocator<int>>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<allocator<int>>::value)>>;
        template<> auto __or_fn<<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<wchar_t>::value)>, __enable_if_t<!bool(is_reference<wchar_t>::value)>, __enable_if_t<!bool(is_void<wchar_t>::value)>>;
        template<> auto __or_fn<<std::is_function<char8_t>, std::is_reference<char8_t>, std::is_void<char8_t>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<char8_t>::value)>, __enable_if_t<!bool(is_reference<char8_t>::value)>, __enable_if_t<!bool(is_void<char8_t>::value)>>;
        template<> auto __or_fn<<std::is_function<char16_t>, std::is_reference<char16_t>, std::is_void<char16_t>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<char16_t>::value)>, __enable_if_t<!bool(is_reference<char16_t>::value)>, __enable_if_t<!bool(is_void<char16_t>::value)>>;
        template<> auto __or_fn<<std::is_function<char32_t>, std::is_reference<char32_t>, std::is_void<char32_t>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_function<char32_t>::value)>, __enable_if_t<!bool(is_reference<char32_t>::value)>, __enable_if_t<!bool(is_void<char32_t>::value)>>;
        template<> auto __or_fn<<std::is_reference<const int *>, std::is_function<const int *>, std::is_void<const int *>, std::__is_array_unknown_bounds<const int *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<const int *>::value)>, __enable_if_t<!bool(is_function<const int *>::value)>, __enable_if_t<!bool(is_void<const int *>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<const int *>::value)>>;
        template<> auto __or_fn<<std::is_reference<int *>, std::is_function<int *>, std::is_void<int *>, std::__is_array_unknown_bounds<int *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<int *>::value)>, __enable_if_t<!bool(is_function<int *>::value)>, __enable_if_t<!bool(is_void<int *>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<int *>::value)>>;
        template<> auto __or_fn<<std::is_reference<Base<ChildA, ChildB, ChildC> *const *>, std::is_function<Base<ChildA, ChildB, ChildC> *const *>, std::is_void<Base<ChildA, ChildB, ChildC> *const *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *const *>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<Base<ChildA, ChildB, ChildC> *const *>::value)>, __enable_if_t<!bool(is_function<Base<ChildA, ChildB, ChildC> *const *>::value)>, __enable_if_t<!bool(is_void<Base<ChildA, ChildB, ChildC> *const *>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *const *>::value)>>;
        template<> auto __or_fn<<std::is_reference<Base<ChildA, ChildB, ChildC> **>, std::is_function<Base<ChildA, ChildB, ChildC> **>, std::is_void<Base<ChildA, ChildB, ChildC> **>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> **>>>(int) -> __first_t<false_type, __enable_if_t<!bool(is_reference<Base<ChildA, ChildB, ChildC> **>::value)>, __enable_if_t<!bool(is_function<Base<ChildA, ChildB, ChildC> **>::value)>, __enable_if_t<!bool(is_void<Base<ChildA, ChildB, ChildC> **>::value)>, __enable_if_t<!bool(__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> **>::value)>>;
        template <typename ..._Bn> auto __or_fn(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_integral<long>, std::is_floating_point<long>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<std::allocator<char>>, std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<std::_Bit_iterator>, std::is_reference<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<std::_Bit_iterator>, std::is_function<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>, std::__is_array_unknown_bounds<std::_Bit_iterator>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<bool>, std::is_reference<bool>, std::is_void<bool>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<std::_Bit_const_iterator>, std::is_reference<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<std::_Bit_const_iterator>, std::is_function<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>, std::__is_array_unknown_bounds<std::_Bit_const_iterator>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<unsigned long *>, std::is_function<unsigned long *>, std::is_void<unsigned long *>, std::__is_array_unknown_bounds<unsigned long *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<const int>, std::is_reference<const int>, std::is_void<const int>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<int>, std::is_reference<int>, std::is_void<int>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_void<int>, std::__is_array_unknown_bounds<int>, std::is_function<int>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_integral<int>, std::is_floating_point<int>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_arithmetic<int>, std::is_enum<int>, std::is_pointer<int>, std::is_member_pointer<int>, std::is_null_pointer<int>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<int>, std::is_scalar<int>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<int>, std::is_function<int>, std::is_void<int>, std::__is_array_unknown_bounds<int>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<char>, std::is_reference<char>, std::is_void<char>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<Base<ChildA, ChildB, ChildC> *const>, std::is_reference<Base<ChildA, ChildB, ChildC> *const>, std::is_void<Base<ChildA, ChildB, ChildC> *const>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_void<Base<ChildA, ChildB, ChildC> *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>, std::is_function<Base<ChildA, ChildB, ChildC> *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_integral<Base<ChildA, ChildB, ChildC> *>, std::is_floating_point<Base<ChildA, ChildB, ChildC> *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_arithmetic<Base<ChildA, ChildB, ChildC> *>, std::is_enum<Base<ChildA, ChildB, ChildC> *>, std::is_pointer<Base<ChildA, ChildB, ChildC> *>, std::is_member_pointer<Base<ChildA, ChildB, ChildC> *>, std::is_null_pointer<Base<ChildA, ChildB, ChildC> *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_scalar<Base<ChildA, ChildB, ChildC> *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<std::allocator<int>>, std::is_function<std::allocator<int>>, std::is_void<std::allocator<int>>, std::__is_array_unknown_bounds<std::allocator<int>>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<char8_t>, std::is_reference<char8_t>, std::is_void<char8_t>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<char16_t>, std::is_reference<char16_t>, std::is_void<char16_t>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_function<char32_t>, std::is_reference<char32_t>, std::is_void<char32_t>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<const int *>, std::is_function<const int *>, std::is_void<const int *>, std::__is_array_unknown_bounds<const int *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<int *>, std::is_function<int *>, std::is_void<int *>, std::__is_array_unknown_bounds<int *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<Base<ChildA, ChildB, ChildC> *const *>, std::is_function<Base<ChildA, ChildB, ChildC> *const *>, std::is_void<Base<ChildA, ChildB, ChildC> *const *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *const *>>>(...) -> true_type;
        template<> auto __or_fn<<std::is_reference<Base<ChildA, ChildB, ChildC> **>, std::is_function<Base<ChildA, ChildB, ChildC> **>, std::is_void<Base<ChildA, ChildB, ChildC> **>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> **>>>(...) -> true_type;
        template <typename ..._Bn> auto __and_fn(int) -> __first_t<true_type, __enable_if_t<bool(_Bn::value)>...>;
        template<> auto __and_fn<<std::is_convertible<const char &&, const char &>>>(int) -> __first_t<true_type, __enable_if_t<bool(is_convertible<const char &&, const char &>::value)>>;
        template<> auto __and_fn<<std::is_convertible<const wchar_t &&, const wchar_t &>>>(int) -> __first_t<true_type, __enable_if_t<bool(is_convertible<const wchar_t &&, const wchar_t &>::value)>>;
        template<> auto __and_fn<<std::is_convertible<const char8_t &&, const char8_t &>>>(int) -> __first_t<true_type, __enable_if_t<bool(is_convertible<const char8_t &&, const char8_t &>::value)>>;
        template<> auto __and_fn<<std::is_convertible<const char16_t &&, const char16_t &>>>(int) -> __first_t<true_type, __enable_if_t<bool(is_convertible<const char16_t &&, const char16_t &>::value)>>;
        template<> auto __and_fn<<std::is_convertible<const char32_t &&, const char32_t &>>>(int) -> __first_t<true_type, __enable_if_t<bool(is_convertible<const char32_t &&, const char32_t &>::value)>>;
        template<> auto __and_fn<<std::__not_<std::__is_tuple_like<std::_Bit_iterator>>, std::is_move_constructible<std::_Bit_iterator>, std::is_move_assignable<std::_Bit_iterator>>>(int) -> __first_t<true_type, __enable_if_t<bool(__not_<__is_tuple_like<_Bit_iterator>>::value)>, __enable_if_t<bool(is_move_constructible<_Bit_iterator>::value)>, __enable_if_t<bool(is_move_assignable<_Bit_iterator>::value)>>;
        template<> auto __and_fn<<std::is_convertible<std::_Bit_reference &&, std::_Bit_reference &&>, std::is_convertible<std::_Bit_reference &&, std::_Bit_reference &&>>>(int) -> __first_t<true_type, __enable_if_t<bool(is_convertible<_Bit_reference &&, _Bit_reference &&>::value)>, __enable_if_t<bool(is_convertible<_Bit_reference &&, _Bit_reference &&>::value)>>;
        template<> auto __and_fn<<std::__not_<std::__is_tuple_like<std::_Bit_const_iterator>>, std::is_move_constructible<std::_Bit_const_iterator>, std::is_move_assignable<std::_Bit_const_iterator>>>(int) -> __first_t<true_type, __enable_if_t<bool(__not_<__is_tuple_like<_Bit_const_iterator>>::value)>, __enable_if_t<bool(is_move_constructible<_Bit_const_iterator>::value)>, __enable_if_t<bool(is_move_assignable<_Bit_const_iterator>::value)>>;
        template<> auto __and_fn<<std::is_convertible<bool &&, const bool &>>>(int) -> __first_t<true_type, __enable_if_t<bool(is_convertible<bool &&, const bool &>::value)>>;
        template<> auto __and_fn<<std::is_convertible<bool &&, bool &&>, std::is_convertible<bool &&, bool &&>>>(int) -> __first_t<true_type, __enable_if_t<bool(is_convertible<bool &&, bool &&>::value)>, __enable_if_t<bool(is_convertible<bool &&, bool &&>::value)>>;
        template <typename ..._Bn> auto __and_fn(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char &&, const char &>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const wchar_t &&, const wchar_t &>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char8_t &&, const char8_t &>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char16_t &&, const char16_t &>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char32_t &&, const char32_t &>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const unsigned int &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const unsigned int *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const unsigned int &, const char *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char *const &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const char *const *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t>>, std::__not_<std::is_convertible<const wchar_t *const *, const std::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char8_t *const &, std::basic_string_view<char8_t>>, std::__not_<std::is_convertible<const char8_t *const *, const std::basic_string<char8_t> *>>, std::__not_<std::is_convertible<const char8_t *const &, const char8_t *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char16_t *const &, std::basic_string_view<char16_t>>, std::__not_<std::is_convertible<const char16_t *const *, const std::basic_string<char16_t> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char32_t *const &, std::basic_string_view<char32_t>>, std::__not_<std::is_convertible<const char32_t *const *, const std::basic_string<char32_t> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const std::allocator<char> &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const std::allocator<char> *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const std::allocator<char> &, const char *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const std::basic_string<char> &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const std::basic_string<char> *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const std::basic_string<char> &, const char *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<char *const &, std::basic_string_view<char>>, std::__not_<std::is_convertible<char *const *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const char *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char &, const char *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const int &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const int *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const int &, const char *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::__not_<std::__is_tuple_like<std::_Bit_iterator>>, std::is_move_constructible<std::_Bit_iterator>, std::is_move_assignable<std::_Bit_iterator>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<std::_Bit_reference &&, std::_Bit_reference &&>, std::is_convertible<std::_Bit_reference &&, std::_Bit_reference &&>>>(...) -> false_type;
        template<> auto __and_fn<<std::__not_<std::__is_tuple_like<std::_Bit_const_iterator>>, std::is_move_constructible<std::_Bit_const_iterator>, std::is_move_assignable<std::_Bit_const_iterator>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<bool &&, const bool &>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<bool &&, bool &&>, std::is_convertible<bool &&, bool &&>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<const char (&)[24], std::basic_string_view<char>>, std::__not_<std::is_convertible<const char (*)[24], const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char (&)[24], const char *>>>>(...) -> false_type;
        template<> auto __and_fn<<std::is_convertible<wchar_t *const &, std::basic_string_view<wchar_t>>, std::__not_<std::is_convertible<wchar_t *const *, const std::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>>(...) -> false_type;
    }
    template <typename ..._Bn> struct __or_ : decltype(__detail::__or_fn<_Bn...>(0)) {
    };
    template<> struct __or_<<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>> : decltype(__detail::__or_fn<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>(0)) {
    };
    template<> struct __or_<<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>> : decltype(__detail::__or_fn<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>(0)) {
    };
    template<> struct __or_<<std::is_integral<long>, std::is_floating_point<long>>> : decltype(__detail::__or_fn<std::is_integral<long>, std::is_floating_point<long>>(0)) {
    };
    template<> struct __or_<<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>> : decltype(__detail::__or_fn<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>(0)) {
    };
    template<> struct __or_<<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> : decltype(__detail::__or_fn<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>(0)) {
    };
    template<> struct __or_<<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> : decltype(__detail::__or_fn<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>(0)) {
    };
    template<> struct __or_<<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> : decltype(__detail::__or_fn<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>(0)) {
    };
    template<> struct __or_<<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>> : decltype(__detail::__or_fn<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>(0)) {
    };
    template<> struct __or_<<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> : decltype(__detail::__or_fn<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>(0)) {
    };
    template<> struct __or_<<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>> : decltype(__detail::__or_fn<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>(0)) {
    };
    template<> struct __or_<<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> : decltype(__detail::__or_fn<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>(0)) {
    };
    template<> struct __or_<<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>> : decltype(__detail::__or_fn<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>(0)) {
    };
    template<> struct __or_<<std::is_reference<std::allocator<char>>, std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : decltype(__detail::__or_fn<std::is_reference<std::allocator<char>>, std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>(0)) {
    };
    template<> struct __or_<<std::is_function<std::_Bit_iterator>, std::is_reference<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>>> : decltype(__detail::__or_fn<std::is_function<std::_Bit_iterator>, std::is_reference<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>>(0)) {
    };
    template<> struct __or_<<std::is_reference<std::_Bit_iterator>, std::is_function<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>, std::__is_array_unknown_bounds<std::_Bit_iterator>>> : decltype(__detail::__or_fn<std::is_reference<std::_Bit_iterator>, std::is_function<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>, std::__is_array_unknown_bounds<std::_Bit_iterator>>(0)) {
    };
    template<> struct __or_<<std::is_function<bool>, std::is_reference<bool>, std::is_void<bool>>> : decltype(__detail::__or_fn<std::is_function<bool>, std::is_reference<bool>, std::is_void<bool>>(0)) {
    };
    template<> struct __or_<<std::is_function<std::_Bit_const_iterator>, std::is_reference<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>>> : decltype(__detail::__or_fn<std::is_function<std::_Bit_const_iterator>, std::is_reference<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>>(0)) {
    };
    template<> struct __or_<<std::is_reference<std::_Bit_const_iterator>, std::is_function<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>, std::__is_array_unknown_bounds<std::_Bit_const_iterator>>> : decltype(__detail::__or_fn<std::is_reference<std::_Bit_const_iterator>, std::is_function<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>, std::__is_array_unknown_bounds<std::_Bit_const_iterator>>(0)) {
    };
    template<> struct __or_<<std::is_reference<unsigned long *>, std::is_function<unsigned long *>, std::is_void<unsigned long *>, std::__is_array_unknown_bounds<unsigned long *>>> : decltype(__detail::__or_fn<std::is_reference<unsigned long *>, std::is_function<unsigned long *>, std::is_void<unsigned long *>, std::__is_array_unknown_bounds<unsigned long *>>(0)) {
    };
    template<> struct __or_<<std::is_function<const int>, std::is_reference<const int>, std::is_void<const int>>> : decltype(__detail::__or_fn<std::is_function<const int>, std::is_reference<const int>, std::is_void<const int>>(0)) {
    };
    template<> struct __or_<<std::is_function<int>, std::is_reference<int>, std::is_void<int>>> : decltype(__detail::__or_fn<std::is_function<int>, std::is_reference<int>, std::is_void<int>>(0)) {
    };
    template<> struct __or_<<std::is_void<int>, std::__is_array_unknown_bounds<int>, std::is_function<int>>> : decltype(__detail::__or_fn<std::is_void<int>, std::__is_array_unknown_bounds<int>, std::is_function<int>>(0)) {
    };
    template<> struct __or_<<std::is_reference<int>, std::is_scalar<int>>> : decltype(__detail::__or_fn<std::is_reference<int>, std::is_scalar<int>>(0)) {
    };
    template<> struct __or_<<std::is_arithmetic<int>, std::is_enum<int>, std::is_pointer<int>, std::is_member_pointer<int>, std::is_null_pointer<int>>> : decltype(__detail::__or_fn<std::is_arithmetic<int>, std::is_enum<int>, std::is_pointer<int>, std::is_member_pointer<int>, std::is_null_pointer<int>>(0)) {
    };
    template<> struct __or_<<std::is_integral<int>, std::is_floating_point<int>>> : decltype(__detail::__or_fn<std::is_integral<int>, std::is_floating_point<int>>(0)) {
    };
    template<> struct __or_<<std::is_reference<int>, std::is_function<int>, std::is_void<int>, std::__is_array_unknown_bounds<int>>> : decltype(__detail::__or_fn<std::is_reference<int>, std::is_function<int>, std::is_void<int>, std::__is_array_unknown_bounds<int>>(0)) {
    };
    template<> struct __or_<<std::is_function<char>, std::is_reference<char>, std::is_void<char>>> : decltype(__detail::__or_fn<std::is_function<char>, std::is_reference<char>, std::is_void<char>>(0)) {
    };
    template<> struct __or_<<std::is_function<Base<ChildA, ChildB, ChildC> *const>, std::is_reference<Base<ChildA, ChildB, ChildC> *const>, std::is_void<Base<ChildA, ChildB, ChildC> *const>>> : decltype(__detail::__or_fn<std::is_function<Base<ChildA, ChildB, ChildC> *const>, std::is_reference<Base<ChildA, ChildB, ChildC> *const>, std::is_void<Base<ChildA, ChildB, ChildC> *const>>(0)) {
    };
    template<> struct __or_<<std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>>> : decltype(__detail::__or_fn<std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>>(0)) {
    };
    template<> struct __or_<<std::is_void<Base<ChildA, ChildB, ChildC> *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>, std::is_function<Base<ChildA, ChildB, ChildC> *>>> : decltype(__detail::__or_fn<std::is_void<Base<ChildA, ChildB, ChildC> *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>, std::is_function<Base<ChildA, ChildB, ChildC> *>>(0)) {
    };
    template<> struct __or_<<std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_scalar<Base<ChildA, ChildB, ChildC> *>>> : decltype(__detail::__or_fn<std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_scalar<Base<ChildA, ChildB, ChildC> *>>(0)) {
    };
    template<> struct __or_<<std::is_arithmetic<Base<ChildA, ChildB, ChildC> *>, std::is_enum<Base<ChildA, ChildB, ChildC> *>, std::is_pointer<Base<ChildA, ChildB, ChildC> *>, std::is_member_pointer<Base<ChildA, ChildB, ChildC> *>, std::is_null_pointer<Base<ChildA, ChildB, ChildC> *>>> : decltype(__detail::__or_fn<std::is_arithmetic<Base<ChildA, ChildB, ChildC> *>, std::is_enum<Base<ChildA, ChildB, ChildC> *>, std::is_pointer<Base<ChildA, ChildB, ChildC> *>, std::is_member_pointer<Base<ChildA, ChildB, ChildC> *>, std::is_null_pointer<Base<ChildA, ChildB, ChildC> *>>(0)) {
    };
    template<> struct __or_<<std::is_integral<Base<ChildA, ChildB, ChildC> *>, std::is_floating_point<Base<ChildA, ChildB, ChildC> *>>> : decltype(__detail::__or_fn<std::is_integral<Base<ChildA, ChildB, ChildC> *>, std::is_floating_point<Base<ChildA, ChildB, ChildC> *>>(0)) {
    };
    template<> struct __or_<<std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>>> : decltype(__detail::__or_fn<std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>>(0)) {
    };
    template<> struct __or_<<std::is_reference<std::allocator<int>>, std::is_function<std::allocator<int>>, std::is_void<std::allocator<int>>, std::__is_array_unknown_bounds<std::allocator<int>>>> : decltype(__detail::__or_fn<std::is_reference<std::allocator<int>>, std::is_function<std::allocator<int>>, std::is_void<std::allocator<int>>, std::__is_array_unknown_bounds<std::allocator<int>>>(0)) {
    };
    template<> struct __or_<<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>> : decltype(__detail::__or_fn<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>(0)) {
    };
    template<> struct __or_<<std::is_function<char8_t>, std::is_reference<char8_t>, std::is_void<char8_t>>> : decltype(__detail::__or_fn<std::is_function<char8_t>, std::is_reference<char8_t>, std::is_void<char8_t>>(0)) {
    };
    template<> struct __or_<<std::is_function<char16_t>, std::is_reference<char16_t>, std::is_void<char16_t>>> : decltype(__detail::__or_fn<std::is_function<char16_t>, std::is_reference<char16_t>, std::is_void<char16_t>>(0)) {
    };
    template<> struct __or_<<std::is_function<char32_t>, std::is_reference<char32_t>, std::is_void<char32_t>>> : decltype(__detail::__or_fn<std::is_function<char32_t>, std::is_reference<char32_t>, std::is_void<char32_t>>(0)) {
    };
    template<> struct __or_<<std::is_reference<const int *>, std::is_function<const int *>, std::is_void<const int *>, std::__is_array_unknown_bounds<const int *>>> : decltype(__detail::__or_fn<std::is_reference<const int *>, std::is_function<const int *>, std::is_void<const int *>, std::__is_array_unknown_bounds<const int *>>(0)) {
    };
    template<> struct __or_<<std::is_reference<int *>, std::is_function<int *>, std::is_void<int *>, std::__is_array_unknown_bounds<int *>>> : decltype(__detail::__or_fn<std::is_reference<int *>, std::is_function<int *>, std::is_void<int *>, std::__is_array_unknown_bounds<int *>>(0)) {
    };
    template<> struct __or_<<std::is_reference<Base<ChildA, ChildB, ChildC> *const *>, std::is_function<Base<ChildA, ChildB, ChildC> *const *>, std::is_void<Base<ChildA, ChildB, ChildC> *const *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *const *>>> : decltype(__detail::__or_fn<std::is_reference<Base<ChildA, ChildB, ChildC> *const *>, std::is_function<Base<ChildA, ChildB, ChildC> *const *>, std::is_void<Base<ChildA, ChildB, ChildC> *const *>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *const *>>(0)) {
    };
    template<> struct __or_<<std::is_reference<Base<ChildA, ChildB, ChildC> **>, std::is_function<Base<ChildA, ChildB, ChildC> **>, std::is_void<Base<ChildA, ChildB, ChildC> **>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> **>>> : decltype(__detail::__or_fn<std::is_reference<Base<ChildA, ChildB, ChildC> **>, std::is_function<Base<ChildA, ChildB, ChildC> **>, std::is_void<Base<ChildA, ChildB, ChildC> **>, std::__is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> **>>(0)) {
    };
    template <typename ..._Bn> struct __and_ : decltype(__detail::__and_fn<_Bn...>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char &&, const char &>>> : decltype(__detail::__and_fn<std::is_convertible<const char &&, const char &>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const wchar_t &&, const wchar_t &>>> : decltype(__detail::__and_fn<std::is_convertible<const wchar_t &&, const wchar_t &>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char8_t &&, const char8_t &>>> : decltype(__detail::__and_fn<std::is_convertible<const char8_t &&, const char8_t &>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char16_t &&, const char16_t &>>> : decltype(__detail::__and_fn<std::is_convertible<const char16_t &&, const char16_t &>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char32_t &&, const char32_t &>>> : decltype(__detail::__and_fn<std::is_convertible<const char32_t &&, const char32_t &>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const unsigned int &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const unsigned int *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const unsigned int &, const char *>>>> : decltype(__detail::__and_fn<std::is_convertible<const unsigned int &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const unsigned int *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const unsigned int &, const char *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char *const &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const char *const *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>> : decltype(__detail::__and_fn<std::is_convertible<const char *const &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const char *const *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t>>, std::__not_<std::is_convertible<const wchar_t *const *, const std::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>> : decltype(__detail::__and_fn<std::is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t>>, std::__not_<std::is_convertible<const wchar_t *const *, const std::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char8_t *const &, std::basic_string_view<char8_t>>, std::__not_<std::is_convertible<const char8_t *const *, const std::basic_string<char8_t> *>>, std::__not_<std::is_convertible<const char8_t *const &, const char8_t *>>>> : decltype(__detail::__and_fn<std::is_convertible<const char8_t *const &, std::basic_string_view<char8_t>>, std::__not_<std::is_convertible<const char8_t *const *, const std::basic_string<char8_t> *>>, std::__not_<std::is_convertible<const char8_t *const &, const char8_t *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char16_t *const &, std::basic_string_view<char16_t>>, std::__not_<std::is_convertible<const char16_t *const *, const std::basic_string<char16_t> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>> : decltype(__detail::__and_fn<std::is_convertible<const char16_t *const &, std::basic_string_view<char16_t>>, std::__not_<std::is_convertible<const char16_t *const *, const std::basic_string<char16_t> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char32_t *const &, std::basic_string_view<char32_t>>, std::__not_<std::is_convertible<const char32_t *const *, const std::basic_string<char32_t> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>> : decltype(__detail::__and_fn<std::is_convertible<const char32_t *const &, std::basic_string_view<char32_t>>, std::__not_<std::is_convertible<const char32_t *const *, const std::basic_string<char32_t> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const std::allocator<char> &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const std::allocator<char> *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const std::allocator<char> &, const char *>>>> : decltype(__detail::__and_fn<std::is_convertible<const std::allocator<char> &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const std::allocator<char> *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const std::allocator<char> &, const char *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const std::basic_string<char> &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const std::basic_string<char> *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const std::basic_string<char> &, const char *>>>> : decltype(__detail::__and_fn<std::is_convertible<const std::basic_string<char> &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const std::basic_string<char> *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const std::basic_string<char> &, const char *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<char *const &, std::basic_string_view<char>>, std::__not_<std::is_convertible<char *const *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>> : decltype(__detail::__and_fn<std::is_convertible<char *const &, std::basic_string_view<char>>, std::__not_<std::is_convertible<char *const *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const char *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char &, const char *>>>> : decltype(__detail::__and_fn<std::is_convertible<const char &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const char *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char &, const char *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const int &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const int *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const int &, const char *>>>> : decltype(__detail::__and_fn<std::is_convertible<const int &, std::basic_string_view<char>>, std::__not_<std::is_convertible<const int *, const std::basic_string<char> *>>, std::__not_<std::is_convertible<const int &, const char *>>>(0)) {
    };
    template<> struct __and_<<std::__not_<std::__is_tuple_like<std::_Bit_iterator>>, std::is_move_constructible<std::_Bit_iterator>, std::is_move_assignable<std::_Bit_iterator>>> : decltype(__detail::__and_fn<std::__not_<std::__is_tuple_like<std::_Bit_iterator>>, std::is_move_constructible<std::_Bit_iterator>, std::is_move_assignable<std::_Bit_iterator>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<std::_Bit_reference &&, std::_Bit_reference &&>, std::is_convertible<std::_Bit_reference &&, std::_Bit_reference &&>>> : decltype(__detail::__and_fn<std::is_convertible<std::_Bit_reference &&, std::_Bit_reference &&>, std::is_convertible<std::_Bit_reference &&, std::_Bit_reference &&>>(0)) {
    };
    template<> struct __and_<<std::__not_<std::__is_tuple_like<std::_Bit_const_iterator>>, std::is_move_constructible<std::_Bit_const_iterator>, std::is_move_assignable<std::_Bit_const_iterator>>> : decltype(__detail::__and_fn<std::__not_<std::__is_tuple_like<std::_Bit_const_iterator>>, std::is_move_constructible<std::_Bit_const_iterator>, std::is_move_assignable<std::_Bit_const_iterator>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<bool &&, const bool &>>> : decltype(__detail::__and_fn<std::is_convertible<bool &&, const bool &>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<bool &&, bool &&>, std::is_convertible<bool &&, bool &&>>> : decltype(__detail::__and_fn<std::is_convertible<bool &&, bool &&>, std::is_convertible<bool &&, bool &&>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<const char (&)[24], std::basic_string_view<char>>, std::__not_<std::is_convertible<const char (*)[24], const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char (&)[24], const char *>>>> : decltype(__detail::__and_fn<std::is_convertible<const char (&)[24], std::basic_string_view<char>>, std::__not_<std::is_convertible<const char (*)[24], const std::basic_string<char> *>>, std::__not_<std::is_convertible<const char (&)[24], const char *>>>(0)) {
    };
    template<> struct __and_<<std::is_convertible<wchar_t *const &, std::basic_string_view<wchar_t>>, std::__not_<std::is_convertible<wchar_t *const *, const std::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>> : decltype(__detail::__and_fn<std::is_convertible<wchar_t *const &, std::basic_string_view<wchar_t>>, std::__not_<std::is_convertible<wchar_t *const *, const std::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>(0)) {
    };
    template <typename _Pp> struct __not_ : __bool_constant<!bool(_Pp::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>> : __bool_constant<!bool(__or_<is_function<const char *>, is_reference<const char *>, is_void<const char *>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>> : __bool_constant<!bool(__or_<is_function<const char>, is_reference<const char>, is_void<const char>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>> : __bool_constant<!bool(__or_<is_function<unsigned long>, is_reference<unsigned long>, is_void<unsigned long>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> : __bool_constant<!bool(__or_<is_function<const wchar_t *>, is_reference<const wchar_t *>, is_void<const wchar_t *>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> : __bool_constant<!bool(__or_<is_function<const wchar_t>, is_reference<const wchar_t>, is_void<const wchar_t>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> : __bool_constant<!bool(__or_<is_function<const char8_t *>, is_reference<const char8_t *>, is_void<const char8_t *>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>> : __bool_constant<!bool(__or_<is_function<const char8_t>, is_reference<const char8_t>, is_void<const char8_t>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> : __bool_constant<!bool(__or_<is_function<const char16_t *>, is_reference<const char16_t *>, is_void<const char16_t *>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>> : __bool_constant<!bool(__or_<is_function<const char16_t>, is_reference<const char16_t>, is_void<const char16_t>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> : __bool_constant<!bool(__or_<is_function<const char32_t *>, is_reference<const char32_t *>, is_void<const char32_t *>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>> : __bool_constant<!bool(__or_<is_function<const char32_t>, is_reference<const char32_t>, is_void<const char32_t>>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char *const *, const std::basic_string<char> *>> : __bool_constant<!bool(is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char *const &, const char *>> : __bool_constant<!bool(is_convertible<const char *const &, const char *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const wchar_t *const *, const std::basic_string<wchar_t> *>> : __bool_constant<!bool(is_convertible<const wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const wchar_t *const &, const wchar_t *>> : __bool_constant<!bool(is_convertible<const wchar_t *const &, const wchar_t *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char8_t *const *, const std::basic_string<char8_t> *>> : __bool_constant<!bool(is_convertible<const char8_t *const *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char8_t *const &, const char8_t *>> : __bool_constant<!bool(is_convertible<const char8_t *const &, const char8_t *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char16_t *const *, const std::basic_string<char16_t> *>> : __bool_constant<!bool(is_convertible<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char16_t *const &, const char16_t *>> : __bool_constant<!bool(is_convertible<const char16_t *const &, const char16_t *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char32_t *const *, const std::basic_string<char32_t> *>> : __bool_constant<!bool(is_convertible<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char32_t *const &, const char32_t *>> : __bool_constant<!bool(is_convertible<const char32_t *const &, const char32_t *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const std::basic_string<char> *, const std::basic_string<char> *>> : __bool_constant<!bool(is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<char *const *, const std::basic_string<char> *>> : __bool_constant<!bool(is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<char *const &, const char *>> : __bool_constant<!bool(is_convertible<char *const &, const char *>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<std::_Bit_iterator>, std::is_reference<std::_Bit_iterator>, std::is_void<std::_Bit_iterator>>> : __bool_constant<!bool(__or_<is_function<_Bit_iterator>, is_reference<_Bit_iterator>, is_void<_Bit_iterator>>::value)> {
    };
    template<> struct __not_<std::__is_tuple_like<std::_Bit_iterator>> : __bool_constant<!bool(__is_tuple_like<_Bit_iterator>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<bool>, std::is_reference<bool>, std::is_void<bool>>> : __bool_constant<!bool(__or_<is_function<bool>, is_reference<bool>, is_void<bool>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<std::_Bit_const_iterator>, std::is_reference<std::_Bit_const_iterator>, std::is_void<std::_Bit_const_iterator>>> : __bool_constant<!bool(__or_<is_function<_Bit_const_iterator>, is_reference<_Bit_const_iterator>, is_void<_Bit_const_iterator>>::value)> {
    };
    template<> struct __not_<std::__is_tuple_like<std::_Bit_const_iterator>> : __bool_constant<!bool(__is_tuple_like<_Bit_const_iterator>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<const int>, std::is_reference<const int>, std::is_void<const int>>> : __bool_constant<!bool(__or_<is_function<const int>, is_reference<const int>, is_void<const int>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<int>, std::is_reference<int>, std::is_void<int>>> : __bool_constant<!bool(__or_<is_function<int>, is_reference<int>, is_void<int>>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char (*)[24], const std::basic_string<char> *>> : __bool_constant<!bool(is_convertible<const char (*)[24], const basic_string<char, char_traits<char>, allocator<char>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<const char (&)[24], const char *>> : __bool_constant<!bool(is_convertible<const char (&)[24], const char *>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<char>, std::is_reference<char>, std::is_void<char>>> : __bool_constant<!bool(__or_<is_function<char>, is_reference<char>, is_void<char>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<Base<ChildA, ChildB, ChildC> *const>, std::is_reference<Base<ChildA, ChildB, ChildC> *const>, std::is_void<Base<ChildA, ChildB, ChildC> *const>>> : __bool_constant<!bool(__or_<is_function<Base<ChildA, ChildB, ChildC> *const>, is_reference<Base<ChildA, ChildB, ChildC> *const>, is_void<Base<ChildA, ChildB, ChildC> *const>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<Base<ChildA, ChildB, ChildC> *>, std::is_reference<Base<ChildA, ChildB, ChildC> *>, std::is_void<Base<ChildA, ChildB, ChildC> *>>> : __bool_constant<!bool(__or_<is_function<Base<ChildA, ChildB, ChildC> *>, is_reference<Base<ChildA, ChildB, ChildC> *>, is_void<Base<ChildA, ChildB, ChildC> *>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>> : __bool_constant<!bool(__or_<is_function<wchar_t>, is_reference<wchar_t>, is_void<wchar_t>>::value)> {
    };
    template<> struct __not_<std::is_convertible<wchar_t *const *, const std::basic_string<wchar_t> *>> : __bool_constant<!bool(is_convertible<wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>::value)> {
    };
    template<> struct __not_<std::is_convertible<wchar_t *const &, const wchar_t *>> : __bool_constant<!bool(is_convertible<wchar_t *const &, const wchar_t *>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<char8_t>, std::is_reference<char8_t>, std::is_void<char8_t>>> : __bool_constant<!bool(__or_<is_function<char8_t>, is_reference<char8_t>, is_void<char8_t>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<char16_t>, std::is_reference<char16_t>, std::is_void<char16_t>>> : __bool_constant<!bool(__or_<is_function<char16_t>, is_reference<char16_t>, is_void<char16_t>>::value)> {
    };
    template<> struct __not_<std::__or_<std::is_function<char32_t>, std::is_reference<char32_t>, std::is_void<char32_t>>> : __bool_constant<!bool(__or_<is_function<char32_t>, is_reference<char32_t>, is_void<char32_t>>::value)> {
    };
    template <typename ..._Bn> constexpr bool __or_v = __or_<_Bn...>::value;
    template <typename ..._Bn> constexpr bool __and_v = __and_<_Bn...>::value;
    namespace __detail {
        template <typename, typename _B1, typename ..._Bn> struct __disjunction_impl {
            using type = _B1;
        };
        template <typename _B1, typename _B2, typename ..._Bn> struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...> {
            using type = typename __disjunction_impl<void, _B2, _Bn...>::type;
        };
        template <typename, typename _B1, typename ..._Bn> struct __conjunction_impl {
            using type = _B1;
        };
        template <typename _B1, typename _B2, typename ..._Bn> struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...> {
            using type = typename __conjunction_impl<void, _B2, _Bn...>::type;
        };
    }
    template <typename ..._Bn> struct conjunction : __detail::__conjunction_impl<void, _Bn...>::type {
    };
    template<> struct conjunction<> : true_type {
    };
    template <typename ..._Bn> struct disjunction : __detail::__disjunction_impl<void, _Bn...>::type {
    };
    template<> struct disjunction<> : false_type {
    };
    template <typename _Pp> struct negation : __not_<_Pp>::type {
    };
    template <typename ..._Bn> constexpr bool conjunction_v = conjunction<_Bn...>::value;
    template <typename ..._Bn> constexpr bool disjunction_v = disjunction<_Bn...>::value;
    template <typename _Pp> constexpr bool negation_v = negation<_Pp>::value;
    template <typename> struct is_reference
    template<> struct is_reference<const char *> : public false_type {
    }
    template<> struct is_reference<const char> : public false_type {
    }
    template<> struct is_reference<unsigned long> : public false_type {
    }
    template<> struct is_reference<const wchar_t *> : public false_type {
    }
    template<> struct is_reference<const wchar_t> : public false_type {
    }
    template<> struct is_reference<const char8_t *> : public false_type {
    }
    template<> struct is_reference<const char8_t> : public false_type {
    }
    template<> struct is_reference<const char16_t *> : public false_type {
    }
    template<> struct is_reference<const char16_t> : public false_type {
    }
    template<> struct is_reference<const char32_t *> : public false_type {
    }
    template<> struct is_reference<const char32_t> : public false_type {
    }
    template<> struct is_reference<std::allocator<char>> : public false_type {
    }
    template<> struct is_reference<std::_Bit_iterator> : public false_type {
    }
    template<> struct is_reference<bool> : public false_type {
    }
    template<> struct is_reference<std::_Bit_const_iterator> : public false_type {
    }
    template<> struct is_reference<unsigned long *> : public false_type {
    }
    template<> struct is_reference<const int> : public false_type {
    }
    template<> struct is_reference<int> : public false_type {
    }
    template<> struct is_reference<char> : public false_type {
    }
    template<> struct is_reference<Base<ChildA, ChildB, ChildC> *const> : public false_type {
    }
    template<> struct is_reference<Base<ChildA, ChildB, ChildC> *> : public false_type {
    }
    template<> struct is_reference<std::allocator<int>> : public false_type {
    }
    template<> struct is_reference<wchar_t> : public false_type {
    }
    template<> struct is_reference<char8_t> : public false_type {
    }
    template<> struct is_reference<char16_t> : public false_type {
    }
    template<> struct is_reference<char32_t> : public false_type {
    }
    template<> struct is_reference<const int *> : public false_type {
    }
    template<> struct is_reference<int *> : public false_type {
    }
    template<> struct is_reference<Base<ChildA, ChildB, ChildC> *const *> : public false_type {
    }
    template<> struct is_reference<Base<ChildA, ChildB, ChildC> **> : public false_type {
    };
    template <typename> struct is_function
    template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    }
    template<> struct is_function<const char> : public __bool_constant<!is_const<const const char>::value> {
    }
    template<> struct is_function<unsigned long> : public __bool_constant<!is_const<const unsigned long>::value> {
    }
    template<> struct is_function<const wchar_t *> : public __bool_constant<!is_const<const wchar_t *const>::value> {
    }
    template<> struct is_function<const wchar_t> : public __bool_constant<!is_const<const const wchar_t>::value> {
    }
    template<> struct is_function<const char8_t *> : public __bool_constant<!is_const<const char8_t *const>::value> {
    }
    template<> struct is_function<const char8_t> : public __bool_constant<!is_const<const const char8_t>::value> {
    }
    template<> struct is_function<const char16_t *> : public __bool_constant<!is_const<const char16_t *const>::value> {
    }
    template<> struct is_function<const char16_t> : public __bool_constant<!is_const<const const char16_t>::value> {
    }
    template<> struct is_function<const char32_t *> : public __bool_constant<!is_const<const char32_t *const>::value> {
    }
    template<> struct is_function<const char32_t> : public __bool_constant<!is_const<const const char32_t>::value> {
    }
    template<> struct is_function<std::allocator<char>> : public __bool_constant<!is_const<const allocator<char>>::value> {
    }
    template<> struct is_function<std::_Bit_iterator> : public __bool_constant<!is_const<const _Bit_iterator>::value> {
    }
    template<> struct is_function<bool> : public __bool_constant<!is_const<const bool>::value> {
    }
    template<> struct is_function<std::_Bit_const_iterator> : public __bool_constant<!is_const<const _Bit_const_iterator>::value> {
    }
    template<> struct is_function<unsigned long *> : public __bool_constant<!is_const<unsigned long *const>::value> {
    }
    template<> struct is_function<const int> : public __bool_constant<!is_const<const const int>::value> {
    }
    template<> struct is_function<int> : public __bool_constant<!is_const<const int>::value> {
    }
    template<> struct is_function<char> : public __bool_constant<!is_const<const char>::value> {
    }
    template<> struct is_function<Base<ChildA, ChildB, ChildC> *const> : public __bool_constant<!is_const<Base<ChildA, ChildB, ChildC> *const const>::value> {
    }
    template<> struct is_function<Base<ChildA, ChildB, ChildC> *> : public __bool_constant<!is_const<Base<ChildA, ChildB, ChildC> *const>::value> {
    }
    template<> struct is_function<std::allocator<int>> : public __bool_constant<!is_const<const allocator<int>>::value> {
    }
    template<> struct is_function<wchar_t> : public __bool_constant<!is_const<const wchar_t>::value> {
    }
    template<> struct is_function<char8_t> : public __bool_constant<!is_const<const char8_t>::value> {
    }
    template<> struct is_function<char16_t> : public __bool_constant<!is_const<const char16_t>::value> {
    }
    template<> struct is_function<char32_t> : public __bool_constant<!is_const<const char32_t>::value> {
    }
    template<> struct is_function<const int *> : public __bool_constant<!is_const<const int *const>::value> {
    }
    template<> struct is_function<int *> : public __bool_constant<!is_const<int *const>::value> {
    }
    template<> struct is_function<Base<ChildA, ChildB, ChildC> *const *> : public __bool_constant<!is_const<Base<ChildA, ChildB, ChildC> *const *const>::value> {
    }
    template<> struct is_function<Base<ChildA, ChildB, ChildC> **> : public __bool_constant<!is_const<Base<ChildA, ChildB, ChildC> **const>::value> {
    };
    template <typename> struct is_void
    template<> struct is_void<const char *> : public false_type {
    }
    template<> struct is_void<const char> : public false_type {
    }
    template<> struct is_void<unsigned long> : public false_type {
    }
    template<> struct is_void<const wchar_t *> : public false_type {
    }
    template<> struct is_void<const wchar_t> : public false_type {
    }
    template<> struct is_void<const char8_t *> : public false_type {
    }
    template<> struct is_void<const char8_t> : public false_type {
    }
    template<> struct is_void<const char16_t *> : public false_type {
    }
    template<> struct is_void<const char16_t> : public false_type {
    }
    template<> struct is_void<const char32_t *> : public false_type {
    }
    template<> struct is_void<const char32_t> : public false_type {
    }
    template<> struct is_void<char> : public false_type {
    }
    template<> struct is_void<wchar_t> : public false_type {
    }
    template<> struct is_void<char8_t> : public false_type {
    }
    template<> struct is_void<char16_t> : public false_type {
    }
    template<> struct is_void<char32_t> : public false_type {
    }
    template<> struct is_void<std::allocator<char>> : public false_type {
    }
    template<> struct is_void<std::_Bit_iterator> : public false_type {
    }
    template<> struct is_void<bool> : public false_type {
    }
    template<> struct is_void<std::_Bit_const_iterator> : public false_type {
    }
    template<> struct is_void<unsigned long *> : public false_type {
    }
    template<> struct is_void<const int> : public false_type {
    }
    template<> struct is_void<int> : public false_type {
    }
    template<> struct is_void<Base<ChildA, ChildB, ChildC> *const> : public false_type {
    }
    template<> struct is_void<Base<ChildA, ChildB, ChildC> *> : public false_type {
    }
    template<> struct is_void<float> : public false_type {
    }
    template<> struct is_void<std::vector<int>> : public false_type {
    }
    template<> struct is_void<std::allocator<int>> : public false_type {
    }
    template<> struct is_void<const int *> : public false_type {
    }
    template<> struct is_void<int *> : public false_type {
    }
    template<> struct is_void<Base<ChildA, ChildB, ChildC> *const *> : public false_type {
    }
    template<> struct is_void<Base<ChildA, ChildB, ChildC> **> : public false_type {
    };
    template <typename> struct remove_cv
    template<> struct remove_cv<wchar_t> {
        using type = __remove_cv(wchar_t);
    }
    template<> struct remove_cv<unsigned int> {
        using type = __remove_cv(unsigned int);
    }
    template<> struct remove_cv<char8_t> {
        using type = __remove_cv(char8_t);
    }
    template<> struct remove_cv<unsigned char> {
        using type = __remove_cv(unsigned char);
    }
    template<> struct remove_cv<char16_t> {
        using type = __remove_cv(char16_t);
    }
    template<> struct remove_cv<unsigned short> {
        using type = __remove_cv(unsigned short);
    }
    template<> struct remove_cv<char32_t> {
        using type = __remove_cv(char32_t);
    }
    template<> struct remove_cv<double> {
        using type = __remove_cv(double);
    }
    template<> struct remove_cv<std::ranges::__detail::__max_size_type> {
        using type = __remove_cv(std::ranges::__detail::__max_size_type);
    }
    template<> struct remove_cv<int> {
        using type = __remove_cv(int);
    }
    template<> struct remove_cv<unsigned __int128> {
        using type = __remove_cv(unsigned __int128);
    }
    template<> struct remove_cv<unsigned long> {
        using type = __remove_cv(unsigned long);
    }
    template<> struct remove_cv<std::ranges::__detail::__max_diff_type> {
        using type = __remove_cv(std::ranges::__detail::__max_diff_type);
    }
    template<> struct remove_cv<const char> {
        using type = __remove_cv(const char);
    }
    template<> struct remove_cv<long> {
        using type = __remove_cv(long);
    }
    template<> struct remove_cv<const char *> {
        using type = __remove_cv(const char *);
    }
    template<> struct remove_cv<const wchar_t> {
        using type = __remove_cv(const wchar_t);
    }
    template<> struct remove_cv<const wchar_t *> {
        using type = __remove_cv(const wchar_t *);
    }
    template<> struct remove_cv<const char8_t> {
        using type = __remove_cv(const char8_t);
    }
    template<> struct remove_cv<const char8_t *> {
        using type = __remove_cv(const char8_t *);
    }
    template<> struct remove_cv<const char16_t> {
        using type = __remove_cv(const char16_t);
    }
    template<> struct remove_cv<const char16_t *> {
        using type = __remove_cv(const char16_t *);
    }
    template<> struct remove_cv<const char32_t> {
        using type = __remove_cv(const char32_t);
    }
    template<> struct remove_cv<const char32_t *> {
        using type = __remove_cv(const char32_t *);
    }
    template<> struct remove_cv<std::_Bit_iterator> {
        using type = __remove_cv(std::_Bit_iterator);
    }
    template<> struct remove_cv<bool> {
        using type = __remove_cv(bool);
    }
    template<> struct remove_cv<std::_Bit_const_iterator> {
        using type = __remove_cv(std::_Bit_const_iterator);
    }
    template<> struct remove_cv<const int> {
        using type = __remove_cv(const int);
    }
    template<> struct remove_cv<char> {
        using type = __remove_cv(char);
    }
    template<> struct remove_cv<Base<ChildA, ChildB, ChildC> *> {
        using type = __remove_cv(Base<ChildA, ChildB, ChildC> *);
    }
    template<> struct remove_cv<Base<ChildA, ChildB, ChildC> *const> {
        using type = __remove_cv(Base<ChildA, ChildB, ChildC> *const);
    };
    template <typename> struct is_const
    template<> struct is_const<wchar_t> : public false_type {
    }
    template<> struct is_const<char8_t> : public false_type {
    }
    template<> struct is_const<char16_t> : public false_type {
    }
    template<> struct is_const<char32_t> : public false_type {
    }
    template<> struct is_const<unsigned int> : public false_type {
    }
    template<> struct is_const<unsigned char> : public false_type {
    }
    template<> struct is_const<unsigned short> : public false_type {
    }
    template<> struct is_const<const char *const> : public true_type {
    }
    template<> struct is_const<const char> : public true_type {
    }
    template<> struct is_const<char> : public false_type {
    }
    template<> struct is_const<const unsigned long> : public true_type {
    }
    template<> struct is_const<const wchar_t *const> : public true_type {
    }
    template<> struct is_const<const wchar_t> : public true_type {
    }
    template<> struct is_const<const char8_t *const> : public true_type {
    }
    template<> struct is_const<const char8_t> : public true_type {
    }
    template<> struct is_const<const char16_t *const> : public true_type {
    }
    template<> struct is_const<const char16_t> : public true_type {
    }
    template<> struct is_const<const char32_t *const> : public true_type {
    }
    template<> struct is_const<const char32_t> : public true_type {
    }
    template<> struct is_const<const std::error_category *const> : public true_type {
    }
    template<> struct is_const<const std::allocator<char>> : public true_type {
    }
    template<> struct is_const<const std::_Bit_iterator> : public true_type {
    }
    template<> struct is_const<const bool> : public true_type {
    }
    template<> struct is_const<const std::_Bit_reference> : public true_type {
    }
    template<> struct is_const<bool> : public false_type {
    }
    template<> struct is_const<std::_Bit_reference> : public false_type {
    }
    template<> struct is_const<const std::_Bit_const_iterator> : public true_type {
    }
    template<> struct is_const<unsigned long *const> : public true_type {
    }
    template<> struct is_const<const int> : public true_type {
    }
    template<> struct is_const<Base<ChildA, ChildB, ChildC> *const> : public true_type {
    }
    template<> struct is_const<const std::allocator<int>> : public true_type {
    }
    template<> struct is_const<const int *const> : public true_type {
    }
    template<> struct is_const<int *const> : public true_type {
    }
    template<> struct is_const<Base<ChildA, ChildB, ChildC> *const *const> : public true_type {
    }
    template<> struct is_const<Base<ChildA, ChildB, ChildC> **const> : public true_type {
    };
    template <typename> struct __is_array_unknown_bounds
    template<> struct __is_array_unknown_bounds<std::allocator<char>> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<std::_Bit_iterator> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<std::_Bit_const_iterator> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<unsigned long *> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<int> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<std::allocator<int>> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<const int *> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<int *> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *const *> : public false_type {
    }
    template<> struct __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> **> : public false_type {
    };
    template <typename _Tp, size_t = sizeof(_Tp)> constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<std::allocator<char>, 1UL>(__type_identity<allocator<char>>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<std::_Bit_iterator, 16UL>(__type_identity<_Bit_iterator>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<std::_Bit_const_iterator, 16UL>(__type_identity<_Bit_const_iterator>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<unsigned long *, 8UL>(__type_identity<unsigned long *>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<int, 4UL>(__type_identity<int>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<Base<ChildA, ChildB, ChildC> *, 8UL>(__type_identity<Base<ChildA, ChildB, ChildC> *>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<std::allocator<int>, 1UL>(__type_identity<allocator<int>>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<const int *, 8UL>(__type_identity<const int *>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<int *, 8UL>(__type_identity<int *>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<Base<ChildA, ChildB, ChildC> *const *, 8UL>(__type_identity<Base<ChildA, ChildB, ChildC> *const *>) {
        return {};
    }
    template<> constexpr true_type __is_complete_or_unbounded<Base<ChildA, ChildB, ChildC> **, 8UL>(__type_identity<Base<ChildA, ChildB, ChildC> **>) {
        return {};
    }
    template <typename _TypeIdentity, typename _NestedType = typename _TypeIdentity::type> constexpr typename __or_<is_reference<_NestedType>, is_function<_NestedType>, is_void<_NestedType>, __is_array_unknown_bounds<_NestedType>>::type __is_complete_or_unbounded(_TypeIdentity) {
        return {};
    }
    template<> constexpr typename __or_<is_reference<allocator<char>>, is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>::type __is_complete_or_unbounded<std::__type_identity<std::allocator<char>>, std::allocator<char>>(std::__type_identity<std::allocator<char>>)    template<> constexpr typename __or_<is_reference<_Bit_iterator>, is_function<_Bit_iterator>, is_void<_Bit_iterator>, __is_array_unknown_bounds<_Bit_iterator>>::type __is_complete_or_unbounded<std::__type_identity<std::_Bit_iterator>, std::_Bit_iterator>(std::__type_identity<std::_Bit_iterator>)    template<> constexpr typename __or_<is_reference<_Bit_const_iterator>, is_function<_Bit_const_iterator>, is_void<_Bit_const_iterator>, __is_array_unknown_bounds<_Bit_const_iterator>>::type __is_complete_or_unbounded<std::__type_identity<std::_Bit_const_iterator>, std::_Bit_const_iterator>(std::__type_identity<std::_Bit_const_iterator>)    template<> constexpr typename __or_<is_reference<unsigned long *>, is_function<unsigned long *>, is_void<unsigned long *>, __is_array_unknown_bounds<unsigned long *>>::type __is_complete_or_unbounded<std::__type_identity<unsigned long *>, unsigned long *>(std::__type_identity<unsigned long *>)    template<> constexpr typename __or_<is_reference<int>, is_function<int>, is_void<int>, __is_array_unknown_bounds<int>>::type __is_complete_or_unbounded<std::__type_identity<int>, int>(std::__type_identity<int>)    template<> constexpr typename __or_<is_reference<Base<ChildA, ChildB, ChildC> *>, is_function<Base<ChildA, ChildB, ChildC> *>, is_void<Base<ChildA, ChildB, ChildC> *>, __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *>>::type __is_complete_or_unbounded<std::__type_identity<Base<ChildA, ChildB, ChildC> *>, Base<ChildA, ChildB, ChildC> *>(std::__type_identity<Base<ChildA, ChildB, ChildC> *>)    template<> constexpr typename __or_<is_reference<allocator<int>>, is_function<allocator<int>>, is_void<allocator<int>>, __is_array_unknown_bounds<allocator<int>>>::type __is_complete_or_unbounded<std::__type_identity<std::allocator<int>>, std::allocator<int>>(std::__type_identity<std::allocator<int>>)    template<> constexpr typename __or_<is_reference<const int *>, is_function<const int *>, is_void<const int *>, __is_array_unknown_bounds<const int *>>::type __is_complete_or_unbounded<std::__type_identity<const int *>, const int *>(std::__type_identity<const int *>)    template<> constexpr typename __or_<is_reference<int *>, is_function<int *>, is_void<int *>, __is_array_unknown_bounds<int *>>::type __is_complete_or_unbounded<std::__type_identity<int *>, int *>(std::__type_identity<int *>)    template<> constexpr typename __or_<is_reference<Base<ChildA, ChildB, ChildC> *const *>, is_function<Base<ChildA, ChildB, ChildC> *const *>, is_void<Base<ChildA, ChildB, ChildC> *const *>, __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *const *>>::type __is_complete_or_unbounded<std::__type_identity<Base<ChildA, ChildB, ChildC> *const *>, Base<ChildA, ChildB, ChildC> *const *>(std::__type_identity<Base<ChildA, ChildB, ChildC> *const *>)    template<> constexpr typename __or_<is_reference<Base<ChildA, ChildB, ChildC> **>, is_function<Base<ChildA, ChildB, ChildC> **>, is_void<Base<ChildA, ChildB, ChildC> **>, __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> **>>::type __is_complete_or_unbounded<std::__type_identity<Base<ChildA, ChildB, ChildC> **>, Base<ChildA, ChildB, ChildC> **>(std::__type_identity<Base<ChildA, ChildB, ChildC> **>)    template <typename _Tp> using __remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename _Tp> struct is_void : public false_type {
    };
    template<> struct is_void<const char *> : public false_type {
    };
    template<> struct is_void<const char> : public false_type {
    };
    template<> struct is_void<unsigned long> : public false_type {
    };
    template<> struct is_void<const wchar_t *> : public false_type {
    };
    template<> struct is_void<const wchar_t> : public false_type {
    };
    template<> struct is_void<const char8_t *> : public false_type {
    };
    template<> struct is_void<const char8_t> : public false_type {
    };
    template<> struct is_void<const char16_t *> : public false_type {
    };
    template<> struct is_void<const char16_t> : public false_type {
    };
    template<> struct is_void<const char32_t *> : public false_type {
    };
    template<> struct is_void<const char32_t> : public false_type {
    };
    template<> struct is_void<char> : public false_type {
    };
    template<> struct is_void<wchar_t> : public false_type {
    };
    template<> struct is_void<char8_t> : public false_type {
    };
    template<> struct is_void<char16_t> : public false_type {
    };
    template<> struct is_void<char32_t> : public false_type {
    };
    template<> struct is_void<std::allocator<char>> : public false_type {
    };
    template<> struct is_void<std::_Bit_iterator> : public false_type {
    };
    template<> struct is_void<bool> : public false_type {
    };
    template<> struct is_void<std::_Bit_const_iterator> : public false_type {
    };
    template<> struct is_void<unsigned long *> : public false_type {
    };
    template<> struct is_void<const int> : public false_type {
    };
    template<> struct is_void<int> : public false_type {
    };
    template<> struct is_void<Base<ChildA, ChildB, ChildC> *const> : public false_type {
    };
    template<> struct is_void<Base<ChildA, ChildB, ChildC> *> : public false_type {
    };
    template<> struct is_void<float> : public false_type {
    };
    template<> struct is_void<std::vector<int>> : public false_type {
    };
    template<> struct is_void<std::allocator<int>> : public false_type {
    };
    template<> struct is_void<const int *> : public false_type {
    };
    template<> struct is_void<int *> : public false_type {
    };
    template<> struct is_void<Base<ChildA, ChildB, ChildC> *const *> : public false_type {
    };
    template<> struct is_void<Base<ChildA, ChildB, ChildC> **> : public false_type {
    };
    template<> struct is_void<void> : public true_type {
    };
    template<> struct is_void<const void> : public true_type {
    };
    template<> struct is_void<volatile void> : public true_type {
    };
    template<> struct is_void<const volatile void> : public true_type {
    };
    template <typename> struct __is_integral_helper : public false_type {
    };
    template<> struct __is_integral_helper<std::ranges::__detail::__max_size_type> : public false_type {
    };
    template<> struct __is_integral_helper<unsigned __int128> : public false_type {
    };
    template<> struct __is_integral_helper<std::ranges::__detail::__max_diff_type> : public false_type {
    };
    template<> struct __is_integral_helper<Base<ChildA, ChildB, ChildC> *> : public false_type {
    };
    template<> struct __is_integral_helper<bool> : public true_type {
    };
    template<> struct __is_integral_helper<char> : public true_type {
    };
    template<> struct __is_integral_helper<signed char> : public true_type {
    };
    template<> struct __is_integral_helper<unsigned char> : public true_type {
    };
    template<> struct __is_integral_helper<wchar_t> : public true_type {
    };
    template<> struct __is_integral_helper<char8_t> : public true_type {
    };
    template<> struct __is_integral_helper<char16_t> : public true_type {
    };
    template<> struct __is_integral_helper<char32_t> : public true_type {
    };
    template<> struct __is_integral_helper<short> : public true_type {
    };
    template<> struct __is_integral_helper<unsigned short> : public true_type {
    };
    template<> struct __is_integral_helper<int> : public true_type {
    };
    template<> struct __is_integral_helper<unsigned int> : public true_type {
    };
    template<> struct __is_integral_helper<long> : public true_type {
    };
    template<> struct __is_integral_helper<unsigned long> : public true_type {
    };
    template<> struct __is_integral_helper<long long> : public true_type {
    };
    template<> struct __is_integral_helper<unsigned long long> : public true_type {
    };
    template <typename _Tp> struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {
    };
    template<> struct is_integral<wchar_t> : public __is_integral_helper<__remove_cv_t<wchar_t>>::type {
    };
    template<> struct is_integral<unsigned int> : public __is_integral_helper<__remove_cv_t<unsigned int>>::type {
    };
    template<> struct is_integral<char8_t> : public __is_integral_helper<__remove_cv_t<char8_t>>::type {
    };
    template<> struct is_integral<unsigned char> : public __is_integral_helper<__remove_cv_t<unsigned char>>::type {
    };
    template<> struct is_integral<char16_t> : public __is_integral_helper<__remove_cv_t<char16_t>>::type {
    };
    template<> struct is_integral<unsigned short> : public __is_integral_helper<__remove_cv_t<unsigned short>>::type {
    };
    template<> struct is_integral<char32_t> : public __is_integral_helper<__remove_cv_t<char32_t>>::type {
    };
    template<> struct is_integral<std::ranges::__detail::__max_size_type> : public __is_integral_helper<__remove_cv_t<__max_size_type>>::type {
    };
    template<> struct is_integral<int> : public __is_integral_helper<__remove_cv_t<int>>::type {
    };
    template<> struct is_integral<unsigned __int128> : public __is_integral_helper<__remove_cv_t<unsigned __int128>>::type {
    };
    template<> struct is_integral<unsigned long> : public __is_integral_helper<__remove_cv_t<unsigned long>>::type {
    };
    template<> struct is_integral<std::ranges::__detail::__max_diff_type> : public __is_integral_helper<__remove_cv_t<__max_diff_type>>::type {
    };
    template<> struct is_integral<long> : public __is_integral_helper<__remove_cv_t<long>>::type {
    };
    template<> struct is_integral<Base<ChildA, ChildB, ChildC> *> : public __is_integral_helper<__remove_cv_t<Base<ChildA, ChildB, ChildC> *>>::type {
    };
    template <typename> struct __is_floating_point_helper : public false_type {
    };
    template<> struct __is_floating_point_helper<Base<ChildA, ChildB, ChildC> *> : public false_type {
    };
    template<> struct __is_floating_point_helper<float> : public true_type {
    };
    template<> struct __is_floating_point_helper<double> : public true_type {
    };
    template<> struct __is_floating_point_helper<long double> : public true_type {
    };
    template <typename _Tp> struct is_floating_point : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {
    };
    template<> struct is_floating_point<double> : public __is_floating_point_helper<__remove_cv_t<double>>::type {
    };
    template<> struct is_floating_point<Base<ChildA, ChildB, ChildC> *> : public __is_floating_point_helper<__remove_cv_t<Base<ChildA, ChildB, ChildC> *>>::type {
    };
    template <typename> struct is_array : public false_type {
    };
    template <typename _Tp, std::size_t _Size> struct is_array<_Tp[_Size]> : public true_type {
    };
    template <typename _Tp> struct is_array<_Tp[]> : public true_type {
    };
    template <typename> struct __is_pointer_helper : public false_type {
    };
    template<> struct __is_pointer_helper<Base<ChildA, ChildB, ChildC> *> : public true_type {
    };
    template <typename _Tp> struct __is_pointer_helper<_Tp *> : public true_type {
    };
    template <typename _Tp> struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template<> struct is_pointer<Base<ChildA, ChildB, ChildC> *> : public __is_pointer_helper<__remove_cv_t<Base<ChildA, ChildB, ChildC> *>>::type {
    };
    template <typename> struct is_lvalue_reference : public false_type {
    };
    template <typename _Tp> struct is_lvalue_reference<_Tp &> : public true_type {
    };
    template <typename> struct is_rvalue_reference : public false_type {
    };
    template <typename _Tp> struct is_rvalue_reference<_Tp &&> : public true_type {
    };
    template <typename> struct __is_member_object_pointer_helper : public false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public __not_<is_function<_Tp>>::type {
    };
    template <typename _Tp> struct is_member_object_pointer : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename> struct __is_member_function_pointer_helper : public false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public is_function<_Tp>::type {
    };
    template <typename _Tp> struct is_member_function_pointer : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename _Tp> struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {
    };
    template<> struct is_enum<wchar_t> : public integral_constant<bool, __is_enum(wchar_t)> {
    };
    template<> struct is_enum<unsigned int> : public integral_constant<bool, __is_enum(unsigned int)> {
    };
    template<> struct is_enum<char8_t> : public integral_constant<bool, __is_enum(char8_t)> {
    };
    template<> struct is_enum<unsigned char> : public integral_constant<bool, __is_enum(unsigned char)> {
    };
    template<> struct is_enum<char16_t> : public integral_constant<bool, __is_enum(char16_t)> {
    };
    template<> struct is_enum<unsigned short> : public integral_constant<bool, __is_enum(unsigned short)> {
    };
    template<> struct is_enum<char32_t> : public integral_constant<bool, __is_enum(char32_t)> {
    };
    template<> struct is_enum<Base<ChildA, ChildB, ChildC> *> : public integral_constant<bool, __is_enum(Base<ChildA, ChildB, ChildC> *)> {
    };
    template <typename _Tp> struct is_union : public integral_constant<bool, __is_union(_Tp)> {
    };
    template <typename _Tp> struct is_class : public integral_constant<bool, __is_class(_Tp)> {
    };
    template <typename _Tp> struct is_function : public __bool_constant<!is_const<const _Tp>::value> {
    };
    template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    };
    template<> struct is_function<const char> : public __bool_constant<!is_const<const const char>::value> {
    };
    template<> struct is_function<unsigned long> : public __bool_constant<!is_const<const unsigned long>::value> {
    };
    template<> struct is_function<const wchar_t *> : public __bool_constant<!is_const<const wchar_t *const>::value> {
    };
    template<> struct is_function<const wchar_t> : public __bool_constant<!is_const<const const wchar_t>::value> {
    };
    template<> struct is_function<const char8_t *> : public __bool_constant<!is_const<const char8_t *const>::value> {
    };
    template<> struct is_function<const char8_t> : public __bool_constant<!is_const<const const char8_t>::value> {
    };
    template<> struct is_function<const char16_t *> : public __bool_constant<!is_const<const char16_t *const>::value> {
    };
    template<> struct is_function<const char16_t> : public __bool_constant<!is_const<const const char16_t>::value> {
    };
    template<> struct is_function<const char32_t *> : public __bool_constant<!is_const<const char32_t *const>::value> {
    };
    template<> struct is_function<const char32_t> : public __bool_constant<!is_const<const const char32_t>::value> {
    };
    template<> struct is_function<std::allocator<char>> : public __bool_constant<!is_const<const allocator<char>>::value> {
    };
    template<> struct is_function<std::_Bit_iterator> : public __bool_constant<!is_const<const _Bit_iterator>::value> {
    };
    template<> struct is_function<bool> : public __bool_constant<!is_const<const bool>::value> {
    };
    template<> struct is_function<std::_Bit_const_iterator> : public __bool_constant<!is_const<const _Bit_const_iterator>::value> {
    };
    template<> struct is_function<unsigned long *> : public __bool_constant<!is_const<unsigned long *const>::value> {
    };
    template<> struct is_function<const int> : public __bool_constant<!is_const<const const int>::value> {
    };
    template<> struct is_function<int> : public __bool_constant<!is_const<const int>::value> {
    };
    template<> struct is_function<char> : public __bool_constant<!is_const<const char>::value> {
    };
    template<> struct is_function<Base<ChildA, ChildB, ChildC> *const> : public __bool_constant<!is_const<Base<ChildA, ChildB, ChildC> *const const>::value> {
    };
    template<> struct is_function<Base<ChildA, ChildB, ChildC> *> : public __bool_constant<!is_const<Base<ChildA, ChildB, ChildC> *const>::value> {
    };
    template<> struct is_function<std::allocator<int>> : public __bool_constant<!is_const<const allocator<int>>::value> {
    };
    template<> struct is_function<wchar_t> : public __bool_constant<!is_const<const wchar_t>::value> {
    };
    template<> struct is_function<char8_t> : public __bool_constant<!is_const<const char8_t>::value> {
    };
    template<> struct is_function<char16_t> : public __bool_constant<!is_const<const char16_t>::value> {
    };
    template<> struct is_function<char32_t> : public __bool_constant<!is_const<const char32_t>::value> {
    };
    template<> struct is_function<const int *> : public __bool_constant<!is_const<const int *const>::value> {
    };
    template<> struct is_function<int *> : public __bool_constant<!is_const<int *const>::value> {
    };
    template<> struct is_function<Base<ChildA, ChildB, ChildC> *const *> : public __bool_constant<!is_const<Base<ChildA, ChildB, ChildC> *const *const>::value> {
    };
    template<> struct is_function<Base<ChildA, ChildB, ChildC> **> : public __bool_constant<!is_const<Base<ChildA, ChildB, ChildC> **const>::value> {
    };
    template <typename _Tp> struct is_function<_Tp &> : public false_type {
    };
    template <typename _Tp> struct is_function<_Tp &&> : public false_type {
    };
    template <typename _Tp> struct is_null_pointer : public false_type {
    };
    template<> struct is_null_pointer<std::nullptr_t> : public true_type {
    };
    template<> struct is_null_pointer<const std::nullptr_t> : public true_type {
    };
    template<> struct is_null_pointer<volatile std::nullptr_t> : public true_type {
    };
    template<> struct is_null_pointer<const volatile std::nullptr_t> : public true_type {
    };
    template <typename _Tp> struct __attribute__((deprecated("use 'std::is_null_pointer' instead"))) __is_nullptr_t : public is_null_pointer<_Tp> {
    };
    template <typename _Tp> struct is_reference : public false_type {
    };
    template<> struct is_reference<const char *> : public false_type {
    };
    template<> struct is_reference<const char> : public false_type {
    };
    template<> struct is_reference<unsigned long> : public false_type {
    };
    template<> struct is_reference<const wchar_t *> : public false_type {
    };
    template<> struct is_reference<const wchar_t> : public false_type {
    };
    template<> struct is_reference<const char8_t *> : public false_type {
    };
    template<> struct is_reference<const char8_t> : public false_type {
    };
    template<> struct is_reference<const char16_t *> : public false_type {
    };
    template<> struct is_reference<const char16_t> : public false_type {
    };
    template<> struct is_reference<const char32_t *> : public false_type {
    };
    template<> struct is_reference<const char32_t> : public false_type {
    };
    template<> struct is_reference<std::allocator<char>> : public false_type {
    };
    template<> struct is_reference<std::_Bit_iterator> : public false_type {
    };
    template<> struct is_reference<bool> : public false_type {
    };
    template<> struct is_reference<std::_Bit_const_iterator> : public false_type {
    };
    template<> struct is_reference<unsigned long *> : public false_type {
    };
    template<> struct is_reference<const int> : public false_type {
    };
    template<> struct is_reference<int> : public false_type {
    };
    template<> struct is_reference<char> : public false_type {
    };
    template<> struct is_reference<Base<ChildA, ChildB, ChildC> *const> : public false_type {
    };
    template<> struct is_reference<Base<ChildA, ChildB, ChildC> *> : public false_type {
    };
    template<> struct is_reference<std::allocator<int>> : public false_type {
    };
    template<> struct is_reference<wchar_t> : public false_type {
    };
    template<> struct is_reference<char8_t> : public false_type {
    };
    template<> struct is_reference<char16_t> : public false_type {
    };
    template<> struct is_reference<char32_t> : public false_type {
    };
    template<> struct is_reference<const int *> : public false_type {
    };
    template<> struct is_reference<int *> : public false_type {
    };
    template<> struct is_reference<Base<ChildA, ChildB, ChildC> *const *> : public false_type {
    };
    template<> struct is_reference<Base<ChildA, ChildB, ChildC> **> : public false_type {
    };
    template <typename _Tp> struct is_reference<_Tp &> : public true_type {
    };
    template <typename _Tp> struct is_reference<_Tp &&> : public true_type {
    };
    template <typename _Tp> struct is_arithmetic : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {
    };
    template<> struct is_arithmetic<long> : public __or_<is_integral<long>, is_floating_point<long>>::type {
    };
    template<> struct is_arithmetic<int> : public __or_<is_integral<int>, is_floating_point<int>>::type {
    };
    template<> struct is_arithmetic<Base<ChildA, ChildB, ChildC> *> : public __or_<is_integral<Base<ChildA, ChildB, ChildC> *>, is_floating_point<Base<ChildA, ChildB, ChildC> *>>::type {
    };
    template <typename _Tp> struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, is_null_pointer<_Tp>>::type {
    };
    template <typename _Tp> struct is_object : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp>>>::type {
    };
    template<> struct is_object<const char *> : public __not_<__or_<is_function<const char *>, is_reference<const char *>, is_void<const char *>>>::type {
    };
    template<> struct is_object<const char> : public __not_<__or_<is_function<const char>, is_reference<const char>, is_void<const char>>>::type {
    };
    template<> struct is_object<unsigned long> : public __not_<__or_<is_function<unsigned long>, is_reference<unsigned long>, is_void<unsigned long>>>::type {
    };
    template<> struct is_object<const wchar_t *> : public __not_<__or_<is_function<const wchar_t *>, is_reference<const wchar_t *>, is_void<const wchar_t *>>>::type {
    };
    template<> struct is_object<const wchar_t> : public __not_<__or_<is_function<const wchar_t>, is_reference<const wchar_t>, is_void<const wchar_t>>>::type {
    };
    template<> struct is_object<const char8_t *> : public __not_<__or_<is_function<const char8_t *>, is_reference<const char8_t *>, is_void<const char8_t *>>>::type {
    };
    template<> struct is_object<const char8_t> : public __not_<__or_<is_function<const char8_t>, is_reference<const char8_t>, is_void<const char8_t>>>::type {
    };
    template<> struct is_object<const char16_t *> : public __not_<__or_<is_function<const char16_t *>, is_reference<const char16_t *>, is_void<const char16_t *>>>::type {
    };
    template<> struct is_object<const char16_t> : public __not_<__or_<is_function<const char16_t>, is_reference<const char16_t>, is_void<const char16_t>>>::type {
    };
    template<> struct is_object<const char32_t *> : public __not_<__or_<is_function<const char32_t *>, is_reference<const char32_t *>, is_void<const char32_t *>>>::type {
    };
    template<> struct is_object<const char32_t> : public __not_<__or_<is_function<const char32_t>, is_reference<const char32_t>, is_void<const char32_t>>>::type {
    };
    template<> struct is_object<std::_Bit_iterator> : public __not_<__or_<is_function<_Bit_iterator>, is_reference<_Bit_iterator>, is_void<_Bit_iterator>>>::type {
    };
    template<> struct is_object<bool> : public __not_<__or_<is_function<bool>, is_reference<bool>, is_void<bool>>>::type {
    };
    template<> struct is_object<std::_Bit_const_iterator> : public __not_<__or_<is_function<_Bit_const_iterator>, is_reference<_Bit_const_iterator>, is_void<_Bit_const_iterator>>>::type {
    };
    template<> struct is_object<const int> : public __not_<__or_<is_function<const int>, is_reference<const int>, is_void<const int>>>::type {
    };
    template<> struct is_object<int> : public __not_<__or_<is_function<int>, is_reference<int>, is_void<int>>>::type {
    };
    template<> struct is_object<char> : public __not_<__or_<is_function<char>, is_reference<char>, is_void<char>>>::type {
    };
    template<> struct is_object<Base<ChildA, ChildB, ChildC> *const> : public __not_<__or_<is_function<Base<ChildA, ChildB, ChildC> *const>, is_reference<Base<ChildA, ChildB, ChildC> *const>, is_void<Base<ChildA, ChildB, ChildC> *const>>>::type {
    };
    template<> struct is_object<Base<ChildA, ChildB, ChildC> *> : public __not_<__or_<is_function<Base<ChildA, ChildB, ChildC> *>, is_reference<Base<ChildA, ChildB, ChildC> *>, is_void<Base<ChildA, ChildB, ChildC> *>>>::type {
    };
    template<> struct is_object<wchar_t> : public __not_<__or_<is_function<wchar_t>, is_reference<wchar_t>, is_void<wchar_t>>>::type {
    };
    template<> struct is_object<char8_t> : public __not_<__or_<is_function<char8_t>, is_reference<char8_t>, is_void<char8_t>>>::type {
    };
    template<> struct is_object<char16_t> : public __not_<__or_<is_function<char16_t>, is_reference<char16_t>, is_void<char16_t>>>::type {
    };
    template<> struct is_object<char32_t> : public __not_<__or_<is_function<char32_t>, is_reference<char32_t>, is_void<char32_t>>>::type {
    };
    template <typename> struct is_member_pointer;
    template <typename _Tp> struct is_scalar : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>, is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type {
    };
    template<> struct is_scalar<int> : public __or_<is_arithmetic<int>, is_enum<int>, is_pointer<int>, is_member_pointer<int>, is_null_pointer<int>>::type {
    };
    template<> struct is_scalar<Base<ChildA, ChildB, ChildC> *> : public __or_<is_arithmetic<Base<ChildA, ChildB, ChildC> *>, is_enum<Base<ChildA, ChildB, ChildC> *>, is_pointer<Base<ChildA, ChildB, ChildC> *>, is_member_pointer<Base<ChildA, ChildB, ChildC> *>, is_null_pointer<Base<ChildA, ChildB, ChildC> *>>::type {
    };
    template <typename _Tp> struct is_compound : public __not_<is_fundamental<_Tp>>::type {
    };
    template <typename _Tp> struct __is_member_pointer_helper : public false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public true_type {
    };
    template <typename _Tp> struct is_member_pointer : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename, typename> struct is_same
    template<> struct is_same<int, int> : public integral_constant<bool, __is_same(int, int)> {
    }
    template<> struct is_same<Base<ChildA, ChildB, ChildC> *, Base<ChildA, ChildB, ChildC> *> : public integral_constant<bool, __is_same(Base<ChildA, ChildB, ChildC> *, Base<ChildA, ChildB, ChildC> *)> {
    }
    template<> struct is_same<long, int> : public integral_constant<bool, __is_same(long, int)> {
    }
    template<> struct is_same<unsigned long, int> : public integral_constant<bool, __is_same(unsigned long, int)> {
    }
    template<> struct is_same<long long, int> : public integral_constant<bool, __is_same(long long, int)> {
    }
    template<> struct is_same<unsigned long long, int> : public integral_constant<bool, __is_same(unsigned long long, int)> {
    }
    template<> struct is_same<float, int> : public integral_constant<bool, __is_same(float, int)> {
    }
    template<> struct is_same<double, int> : public integral_constant<bool, __is_same(double, int)> {
    }
    template<> struct is_same<long double, int> : public integral_constant<bool, __is_same(long double, int)> {
    };
    template <typename _Tp, typename ..._Types> using __is_one_of = __or_<is_same<_Tp, _Types>...>;
    template <typename _Tp> using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>, signed char, short, int, long, long long>;
    template <typename _Tp> using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
    template <typename _Tp> using __is_standard_integer = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;
    template <typename ...> using __void_t = void;
    template <typename> struct is_const : public false_type {
    };
    template<> struct is_const<wchar_t> : public false_type {
    };
    template<> struct is_const<char8_t> : public false_type {
    };
    template<> struct is_const<char16_t> : public false_type {
    };
    template<> struct is_const<char32_t> : public false_type {
    };
    template<> struct is_const<unsigned int> : public false_type {
    };
    template<> struct is_const<unsigned char> : public false_type {
    };
    template<> struct is_const<unsigned short> : public false_type {
    };
    template<> struct is_const<const char *const> : public true_type {
    };
    template<> struct is_const<const char> : public true_type {
    };
    template<> struct is_const<char> : public false_type {
    };
    template<> struct is_const<const unsigned long> : public true_type {
    };
    template<> struct is_const<const wchar_t *const> : public true_type {
    };
    template<> struct is_const<const wchar_t> : public true_type {
    };
    template<> struct is_const<const char8_t *const> : public true_type {
    };
    template<> struct is_const<const char8_t> : public true_type {
    };
    template<> struct is_const<const char16_t *const> : public true_type {
    };
    template<> struct is_const<const char16_t> : public true_type {
    };
    template<> struct is_const<const char32_t *const> : public true_type {
    };
    template<> struct is_const<const char32_t> : public true_type {
    };
    template<> struct is_const<const std::error_category *const> : public true_type {
    };
    template<> struct is_const<const std::allocator<char>> : public true_type {
    };
    template<> struct is_const<const std::_Bit_iterator> : public true_type {
    };
    template<> struct is_const<const bool> : public true_type {
    };
    template<> struct is_const<const std::_Bit_reference> : public true_type {
    };
    template<> struct is_const<bool> : public false_type {
    };
    template<> struct is_const<std::_Bit_reference> : public false_type {
    };
    template<> struct is_const<const std::_Bit_const_iterator> : public true_type {
    };
    template<> struct is_const<unsigned long *const> : public true_type {
    };
    template<> struct is_const<const int> : public true_type {
    };
    template<> struct is_const<Base<ChildA, ChildB, ChildC> *const> : public true_type {
    };
    template<> struct is_const<const std::allocator<int>> : public true_type {
    };
    template<> struct is_const<const int *const> : public true_type {
    };
    template<> struct is_const<int *const> : public true_type {
    };
    template<> struct is_const<Base<ChildA, ChildB, ChildC> *const *const> : public true_type {
    };
    template<> struct is_const<Base<ChildA, ChildB, ChildC> **const> : public true_type {
    };
    template <typename _Tp> struct is_const<const _Tp> : public true_type {
    };
    template <typename> struct is_volatile : public false_type {
    };
    template<> struct is_volatile<wchar_t> : public false_type {
    };
    template<> struct is_volatile<char8_t> : public false_type {
    };
    template<> struct is_volatile<char16_t> : public false_type {
    };
    template<> struct is_volatile<char32_t> : public false_type {
    };
    template<> struct is_volatile<unsigned int> : public false_type {
    };
    template<> struct is_volatile<unsigned char> : public false_type {
    };
    template<> struct is_volatile<unsigned short> : public false_type {
    };
    template<> struct is_volatile<const char *const> : public false_type {
    };
    template<> struct is_volatile<const char> : public false_type {
    };
    template<> struct is_volatile<char> : public false_type {
    };
    template<> struct is_volatile<const unsigned long> : public false_type {
    };
    template<> struct is_volatile<const wchar_t *const> : public false_type {
    };
    template<> struct is_volatile<const wchar_t> : public false_type {
    };
    template<> struct is_volatile<const char8_t *const> : public false_type {
    };
    template<> struct is_volatile<const char8_t> : public false_type {
    };
    template<> struct is_volatile<const char16_t *const> : public false_type {
    };
    template<> struct is_volatile<const char16_t> : public false_type {
    };
    template<> struct is_volatile<const char32_t *const> : public false_type {
    };
    template<> struct is_volatile<const char32_t> : public false_type {
    };
    template<> struct is_volatile<const std::error_category *const> : public false_type {
    };
    template<> struct is_volatile<const std::_Bit_iterator> : public false_type {
    };
    template<> struct is_volatile<const std::_Bit_reference> : public false_type {
    };
    template<> struct is_volatile<bool> : public false_type {
    };
    template<> struct is_volatile<std::_Bit_reference> : public false_type {
    };
    template<> struct is_volatile<const bool> : public false_type {
    };
    template<> struct is_volatile<const std::_Bit_const_iterator> : public false_type {
    };
    template <typename _Tp> struct is_volatile<volatile _Tp> : public true_type {
    };
    template <typename _Tp> struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct __attribute__((deprecated("use 'is_standard_layout && is_trivial' instead"))) is_pod : public integral_constant<bool, __is_pod(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct [[deprecated("")]] is_literal_type : public integral_constant<bool, __is_literal(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {
    };
    template <typename _Tp> struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {
    };
    template <typename _Tp> struct is_final : public integral_constant<bool, __is_final(_Tp)> {
    };
    template <typename _Tp> struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {
    };
    template <typename _Tp, bool = is_arithmetic<_Tp>::value> struct __is_signed_helper : public false_type {
    };
    template<> struct __is_signed_helper<long, true> : public integral_constant<bool, long(-1) < long(0)> {
    };
    template <typename _Tp> struct __is_signed_helper<_Tp, true> : public integral_constant<bool, _Tp(-1) < _Tp(0)> {
    };
    template <typename _Tp> struct is_signed : public __is_signed_helper<_Tp>::type {
    };
    template<> struct is_signed<long> : public __is_signed_helper<long>::type {
    };
    template <typename _Tp> struct is_unsigned : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type {
    };
    template <typename _Tp, typename _Up = _Tp &&> _Up __declval(int);
    template<> const std::ranges::__cust_swap::_Swap &__declval<const std::ranges::__cust_swap::_Swap &, const std::ranges::__cust_swap::_Swap &>(int);
    template<> const char &__declval<const char &, const char &>(int);
    template<> char &__declval<char &, char &>(int);
    template<> const wchar_t &__declval<const wchar_t &, const wchar_t &>(int);
    template<> wchar_t &__declval<wchar_t &, wchar_t &>(int);
    template<> const char8_t &__declval<const char8_t &, const char8_t &>(int);
    template<> char8_t &__declval<char8_t &, char8_t &>(int);
    template<> const char16_t &__declval<const char16_t &, const char16_t &>(int);
    template<> const char32_t &__declval<const char32_t &, const char32_t &>(int);
    template<> const char *&&__declval<const char *, const char *&&>(int);
    template<> const char *const &(&__declval<const char *const &(&)(), const char *const &(&)()>(int))();
    template<> const char *const &__declval<const char *const &, const char *const &>(int);
    template<> const char *&__declval<const char *&, const char *&>(int);
    template<> const char &(&__declval<const char &(&)(), const char &(&)()>(int))();
    template<> const char &&__declval<const char &&, const char &&>(int);
    template<> const char *const &&__declval<const char *const, const char *const &&>(int);
    template<> bool &&__declval<bool, bool &&>(int);
    template<> unsigned long &&__declval<unsigned long, unsigned long &&>(int);
    template<> unsigned long &__declval<unsigned long &, unsigned long &>(int);
    template<> const unsigned long &__declval<const unsigned long &, const unsigned long &>(int);
    template<> const unsigned long &&__declval<const unsigned long, const unsigned long &&>(int);
    template<> const unsigned long &(&__declval<const unsigned long &(&)(), const unsigned long &(&)()>(int))();
    template<> const wchar_t *&&__declval<const wchar_t *, const wchar_t *&&>(int);
    template<> const wchar_t *const &(&__declval<const wchar_t *const &(&)(), const wchar_t *const &(&)()>(int))();
    template<> const wchar_t *const &__declval<const wchar_t *const &, const wchar_t *const &>(int);
    template<> const wchar_t *&__declval<const wchar_t *&, const wchar_t *&>(int);
    template<> const wchar_t &(&__declval<const wchar_t &(&)(), const wchar_t &(&)()>(int))();
    template<> const wchar_t &&__declval<const wchar_t &&, const wchar_t &&>(int);
    template<> const wchar_t *const &&__declval<const wchar_t *const, const wchar_t *const &&>(int);
    template<> const char8_t *&&__declval<const char8_t *, const char8_t *&&>(int);
    template<> const char8_t *const &(&__declval<const char8_t *const &(&)(), const char8_t *const &(&)()>(int))();
    template<> const char8_t *const &__declval<const char8_t *const &, const char8_t *const &>(int);
    template<> const char8_t *&__declval<const char8_t *&, const char8_t *&>(int);
    template<> const char8_t &(&__declval<const char8_t &(&)(), const char8_t &(&)()>(int))();
    template<> const char8_t &&__declval<const char8_t &&, const char8_t &&>(int);
    template<> const char8_t *const &&__declval<const char8_t *const, const char8_t *const &&>(int);
    template<> const char16_t *&&__declval<const char16_t *, const char16_t *&&>(int);
    template<> const char16_t *const &(&__declval<const char16_t *const &(&)(), const char16_t *const &(&)()>(int))();
    template<> const char16_t *const &__declval<const char16_t *const &, const char16_t *const &>(int);
    template<> const char16_t *&__declval<const char16_t *&, const char16_t *&>(int);
    template<> const char16_t &(&__declval<const char16_t &(&)(), const char16_t &(&)()>(int))();
    template<> char16_t &__declval<char16_t &, char16_t &>(int);
    template<> const char16_t &&__declval<const char16_t &&, const char16_t &&>(int);
    template<> const char16_t *const &&__declval<const char16_t *const, const char16_t *const &&>(int);
    template<> const char32_t *&&__declval<const char32_t *, const char32_t *&&>(int);
    template<> const char32_t *const &(&__declval<const char32_t *const &(&)(), const char32_t *const &(&)()>(int))();
    template<> const char32_t *const &__declval<const char32_t *const &, const char32_t *const &>(int);
    template<> const char32_t *&__declval<const char32_t *&, const char32_t *&>(int);
    template<> const char32_t &(&__declval<const char32_t &(&)(), const char32_t &(&)()>(int))();
    template<> char32_t &__declval<char32_t &, char32_t &>(int);
    template<> const char32_t &&__declval<const char32_t &&, const char32_t &&>(int);
    template<> const char32_t *const &&__declval<const char32_t *const, const char32_t *const &&>(int);
    template<> std::allocator<char> &__declval<std::allocator<char> &, std::allocator<char> &>(int);
    template<> std::allocator<wchar_t> &__declval<std::allocator<wchar_t> &, std::allocator<wchar_t> &>(int);
    template<> std::allocator<char8_t> &__declval<std::allocator<char8_t> &, std::allocator<char8_t> &>(int);
    template<> std::allocator<char16_t> &__declval<std::allocator<char16_t> &, std::allocator<char16_t> &>(int);
    template<> std::allocator<char32_t> &__declval<std::allocator<char32_t> &, std::allocator<char32_t> &>(int);
    template<> const std::error_category *const &(&__declval<const std::error_category *const &(&)(), const std::error_category *const &(&)()>(int))();
    template<> const std::error_category *const &__declval<const std::error_category *const &, const std::error_category *const &>(int);
    template<> const std::error_category *&&__declval<const std::error_category *, const std::error_category *&&>(int);
    template<> std::_Bit_iterator &&__declval<std::_Bit_iterator, std::_Bit_iterator &&>(int);
    template<> const std::_Bit_iterator &(&__declval<const std::_Bit_iterator &(&)(), const std::_Bit_iterator &(&)()>(int))();
    template<> const std::_Bit_iterator &__declval<const std::_Bit_iterator &, const std::_Bit_iterator &>(int);
    template<> std::_Bit_iterator &__declval<std::_Bit_iterator &, std::_Bit_iterator &>(int);
    template<> const bool &(&__declval<const bool &(&)(), const bool &(&)()>(int))();
    template<> const std::_Bit_reference &(&__declval<const std::_Bit_reference &(&)(), const std::_Bit_reference &(&)()>(int))();
    template<> std::_Bit_reference &&(&__declval<std::_Bit_reference &&(&)(), std::_Bit_reference &&(&)()>(int))();
    template<> bool &(&__declval<bool &(&)(), bool &(&)()>(int))();
    template<> std::_Bit_reference &&__declval<std::_Bit_reference &&, std::_Bit_reference &&>(int);
    template<> bool &__declval<bool &, bool &>(int);
    template<> std::_Bit_reference &(&__declval<std::_Bit_reference &(&)(), std::_Bit_reference &(&)()>(int))();
    template<> const bool &__declval<const bool &, const bool &>(int);
    template<> const std::_Bit_iterator &&__declval<const std::_Bit_iterator, const std::_Bit_iterator &&>(int);
    template<> std::_Bit_const_iterator &&__declval<std::_Bit_const_iterator, std::_Bit_const_iterator &&>(int);
    template<> const std::_Bit_const_iterator &(&__declval<const std::_Bit_const_iterator &(&)(), const std::_Bit_const_iterator &(&)()>(int))();
    template<> const std::_Bit_const_iterator &__declval<const std::_Bit_const_iterator &, const std::_Bit_const_iterator &>(int);
    template<> std::_Bit_const_iterator &__declval<std::_Bit_const_iterator &, std::_Bit_const_iterator &>(int);
    template<> bool &&__declval<bool &&, bool &&>(int);
    template<> const std::_Bit_const_iterator &&__declval<const std::_Bit_const_iterator, const std::_Bit_const_iterator &&>(int);
    template<> const int &__declval<const int &, const int &>(int);
    template<> Base<ChildA, ChildB, ChildC> *const &__declval<Base<ChildA, ChildB, ChildC> *const &, Base<ChildA, ChildB, ChildC> *const &>(int);
    template <typename _Tp> _Tp __declval(long);
    template<> const std::ranges::__cust_swap::_Swap &__declval<const std::ranges::__cust_swap::_Swap &>(long);
    template<> const char &__declval<const char &>(long);
    template<> char &__declval<char &>(long);
    template<> const wchar_t &__declval<const wchar_t &>(long);
    template<> wchar_t &__declval<wchar_t &>(long);
    template<> const char8_t &__declval<const char8_t &>(long);
    template<> char8_t &__declval<char8_t &>(long);
    template<> const char16_t &__declval<const char16_t &>(long);
    template<> const char32_t &__declval<const char32_t &>(long);
    template<> const char *__declval<const char *>(long);
    template<> const char *const &(&__declval<const char *const &(&)()>(long))();
    template<> const char *const &__declval<const char *const &>(long);
    template<> const char *&__declval<const char *&>(long);
    template<> const char &(&__declval<const char &(&)()>(long))();
    template<> const char &&__declval<const char &&>(long);
    template<> const char *const __declval<const char *const>(long);
    template<> bool __declval<bool>(long);
    template<> unsigned long __declval<unsigned long>(long);
    template<> unsigned long &__declval<unsigned long &>(long);
    template<> const unsigned long &__declval<const unsigned long &>(long);
    template<> const unsigned long __declval<const unsigned long>(long);
    template<> const unsigned long &(&__declval<const unsigned long &(&)()>(long))();
    template<> const wchar_t *__declval<const wchar_t *>(long);
    template<> const wchar_t *const &(&__declval<const wchar_t *const &(&)()>(long))();
    template<> const wchar_t *const &__declval<const wchar_t *const &>(long);
    template<> const wchar_t *&__declval<const wchar_t *&>(long);
    template<> const wchar_t &(&__declval<const wchar_t &(&)()>(long))();
    template<> const wchar_t &&__declval<const wchar_t &&>(long);
    template<> const wchar_t *const __declval<const wchar_t *const>(long);
    template<> const char8_t *__declval<const char8_t *>(long);
    template<> const char8_t *const &(&__declval<const char8_t *const &(&)()>(long))();
    template<> const char8_t *const &__declval<const char8_t *const &>(long);
    template<> const char8_t *&__declval<const char8_t *&>(long);
    template<> const char8_t &(&__declval<const char8_t &(&)()>(long))();
    template<> const char8_t &&__declval<const char8_t &&>(long);
    template<> const char8_t *const __declval<const char8_t *const>(long);
    template<> const char16_t *__declval<const char16_t *>(long);
    template<> const char16_t *const &(&__declval<const char16_t *const &(&)()>(long))();
    template<> const char16_t *const &__declval<const char16_t *const &>(long);
    template<> const char16_t *&__declval<const char16_t *&>(long);
    template<> const char16_t &(&__declval<const char16_t &(&)()>(long))();
    template<> char16_t &__declval<char16_t &>(long);
    template<> const char16_t &&__declval<const char16_t &&>(long);
    template<> const char16_t *const __declval<const char16_t *const>(long);
    template<> const char32_t *__declval<const char32_t *>(long);
    template<> const char32_t *const &(&__declval<const char32_t *const &(&)()>(long))();
    template<> const char32_t *const &__declval<const char32_t *const &>(long);
    template<> const char32_t *&__declval<const char32_t *&>(long);
    template<> const char32_t &(&__declval<const char32_t &(&)()>(long))();
    template<> char32_t &__declval<char32_t &>(long);
    template<> const char32_t &&__declval<const char32_t &&>(long);
    template<> const char32_t *const __declval<const char32_t *const>(long);
    template<> std::allocator<char> &__declval<std::allocator<char> &>(long);
    template<> std::allocator<wchar_t> &__declval<std::allocator<wchar_t> &>(long);
    template<> std::allocator<char8_t> &__declval<std::allocator<char8_t> &>(long);
    template<> std::allocator<char16_t> &__declval<std::allocator<char16_t> &>(long);
    template<> std::allocator<char32_t> &__declval<std::allocator<char32_t> &>(long);
    template<> const std::error_category *const &(&__declval<const std::error_category *const &(&)()>(long))();
    template<> const std::error_category *const &__declval<const std::error_category *const &>(long);
    template<> const std::error_category *__declval<const std::error_category *>(long);
    template<> std::_Bit_iterator __declval<std::_Bit_iterator>(long);
    template<> const std::_Bit_iterator &(&__declval<const std::_Bit_iterator &(&)()>(long))();
    template<> const std::_Bit_iterator &__declval<const std::_Bit_iterator &>(long);
    template<> std::_Bit_iterator &__declval<std::_Bit_iterator &>(long);
    template<> const bool &(&__declval<const bool &(&)()>(long))();
    template<> const std::_Bit_reference &(&__declval<const std::_Bit_reference &(&)()>(long))();
    template<> std::_Bit_reference &&(&__declval<std::_Bit_reference &&(&)()>(long))();
    template<> bool &(&__declval<bool &(&)()>(long))();
    template<> std::_Bit_reference &&__declval<std::_Bit_reference &&>(long);
    template<> bool &__declval<bool &>(long);
    template<> std::_Bit_reference &(&__declval<std::_Bit_reference &(&)()>(long))();
    template<> const bool &__declval<const bool &>(long);
    template<> const std::_Bit_iterator __declval<const std::_Bit_iterator>(long);
    template<> std::_Bit_const_iterator __declval<std::_Bit_const_iterator>(long);
    template<> const std::_Bit_const_iterator &(&__declval<const std::_Bit_const_iterator &(&)()>(long))();
    template<> const std::_Bit_const_iterator &__declval<const std::_Bit_const_iterator &>(long);
    template<> std::_Bit_const_iterator &__declval<std::_Bit_const_iterator &>(long);
    template<> bool &&__declval<bool &&>(long);
    template<> const std::_Bit_const_iterator __declval<const std::_Bit_const_iterator>(long);
    template<> const int &__declval<const int &>(long);
    template<> Base<ChildA, ChildB, ChildC> *const &__declval<Base<ChildA, ChildB, ChildC> *const &>(long);
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0));
    template <typename> struct remove_all_extents;
    template <typename _Tp> struct __is_array_known_bounds : public false_type {
    };
    template <typename _Tp, size_t _Size> struct __is_array_known_bounds<_Tp[_Size]> : public true_type {
    };
    template <typename _Tp> struct __is_array_unknown_bounds : public false_type {
    };
    template<> struct __is_array_unknown_bounds<std::allocator<char>> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<std::_Bit_iterator> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<std::_Bit_const_iterator> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<unsigned long *> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<int> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<std::allocator<int>> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<const int *> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<int *> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> *const *> : public false_type {
    };
    template<> struct __is_array_unknown_bounds<Base<ChildA, ChildB, ChildC> **> : public false_type {
    };
    template <typename _Tp> struct __is_array_unknown_bounds<_Tp[]> : public true_type {
    };
    struct __do_is_destructible_impl {
        template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())> static true_type __test(int);
        template <typename> static false_type __test(...);
    };
    template <typename _Tp> struct __is_destructible_impl : public __do_is_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_destructible_safe
    template<> struct __is_destructible_safe<int, false, true> : public true_type {
    }
    template<> struct __is_destructible_safe<Base<ChildA, ChildB, ChildC> *, false, true> : public true_type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, false> : public __is_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, true, false> : public false_type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, true> : public true_type {
    };
    template <typename _Tp> struct is_destructible : public __is_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_destructible<int> : public __is_destructible_safe<int>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<int>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_destructible<Base<ChildA, ChildB, ChildC> *> : public __is_destructible_safe<Base<ChildA, ChildB, ChildC> *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<Base<ChildA, ChildB, ChildC> *>{}), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_nt_destructible_impl {
        template <typename _Tp> static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);
        template <typename> static false_type __test(...);
    };
    template <typename _Tp> struct __is_nt_destructible_impl : public __do_is_nt_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_nt_destructible_safe;
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, false> : public __is_nt_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, true, false> : public false_type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, true> : public true_type {
    };
    template <typename _Tp> struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> using __is_constructible_impl = __bool_constant<__is_constructible(_Tp, _Args...)>;
    template <typename _Tp, typename ..._Args> struct is_constructible : public __is_constructible_impl<_Tp, _Args...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_constructible<int, <const int &>> : public __is_constructible_impl<int, const int &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<int>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_constructible<Base<ChildA, ChildB, ChildC> *, <Base<ChildA, ChildB, ChildC> *const &>> : public __is_constructible_impl<Base<ChildA, ChildB, ChildC> *, Base<ChildA, ChildB, ChildC> *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<Base<ChildA, ChildB, ChildC> *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_default_constructible : public __is_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename = void> struct __add_lvalue_reference_helper {
        using type = _Tp;
    };
    template<> struct __add_lvalue_reference_helper<const char *, void> {
        using type = const char *&;
    };
    template<> struct __add_lvalue_reference_helper<unsigned long, void> {
        using type = unsigned long &;
    };
    template<> struct __add_lvalue_reference_helper<const wchar_t *, void> {
        using type = const wchar_t *&;
    };
    template<> struct __add_lvalue_reference_helper<const char8_t *, void> {
        using type = const char8_t *&;
    };
    template<> struct __add_lvalue_reference_helper<const char16_t *, void> {
        using type = const char16_t *&;
    };
    template<> struct __add_lvalue_reference_helper<const char32_t *, void> {
        using type = const char32_t *&;
    };
    template<> struct __add_lvalue_reference_helper<std::_Bit_iterator, void> {
        using type = std::_Bit_iterator &;
    };
    template<> struct __add_lvalue_reference_helper<std::_Bit_const_iterator, void> {
        using type = std::_Bit_const_iterator &;
    };
    template<> struct __add_lvalue_reference_helper<unsigned long *const, void> {
        using type = unsigned long *const &;
    };
    template<> struct __add_lvalue_reference_helper<const std::_Bit_const_iterator, void> {
        using type = const std::_Bit_const_iterator &;
    };
    template<> struct __add_lvalue_reference_helper<const std::_Bit_iterator, void> {
        using type = const std::_Bit_iterator &;
    };
    template<> struct __add_lvalue_reference_helper<const int *const, void> {
        using type = const int *const &;
    };
    template<> struct __add_lvalue_reference_helper<int *const, void> {
        using type = int *const &;
    };
    template<> struct __add_lvalue_reference_helper<Base<ChildA, ChildB, ChildC> *const *const, void> {
        using type = Base<ChildA, ChildB, ChildC> *const *const &;
    };
    template<> struct __add_lvalue_reference_helper<Base<ChildA, ChildB, ChildC> **const, void> {
        using type = Base<ChildA, ChildB, ChildC> **const &;
    };
    template <typename _Tp> struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp &>> {
        using type = _Tp &;
    };
    template <typename _Tp> using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;
    template <typename _Tp> struct is_copy_constructible : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename = void> struct __add_rvalue_reference_helper {
        using type = _Tp;
    };
    template<> struct __add_rvalue_reference_helper<const char *, void> {
        using type = const char *&&;
    };
    template<> struct __add_rvalue_reference_helper<unsigned long, void> {
        using type = unsigned long &&;
    };
    template<> struct __add_rvalue_reference_helper<const wchar_t *, void> {
        using type = const wchar_t *&&;
    };
    template<> struct __add_rvalue_reference_helper<const char8_t *, void> {
        using type = const char8_t *&&;
    };
    template<> struct __add_rvalue_reference_helper<const char16_t *, void> {
        using type = const char16_t *&&;
    };
    template<> struct __add_rvalue_reference_helper<const char32_t *, void> {
        using type = const char32_t *&&;
    };
    template<> struct __add_rvalue_reference_helper<std::_Bit_iterator, void> {
        using type = std::_Bit_iterator &&;
    };
    template<> struct __add_rvalue_reference_helper<std::_Bit_const_iterator, void> {
        using type = std::_Bit_const_iterator &&;
    };
    template <typename _Tp> struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp &&>> {
        using type = _Tp &&;
    };
    template <typename _Tp> using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;
    template <typename _Tp> struct is_move_constructible : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_move_constructible<std::_Bit_iterator> : public __is_constructible_impl<_Bit_iterator, __add_rval_ref_t<_Bit_iterator>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Bit_iterator>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_move_constructible<std::_Bit_const_iterator> : public __is_constructible_impl<_Bit_const_iterator, __add_rval_ref_t<_Bit_const_iterator>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Bit_const_iterator>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> using __is_nothrow_constructible_impl = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;
    template <typename _Tp, typename ..._Args> struct is_nothrow_constructible : public __is_nothrow_constructible_impl<_Tp, _Args...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_default_constructible : public __is_nothrow_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_default_constructible<std::allocator<char>> : public __is_nothrow_constructible_impl<allocator<char>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<allocator<char>>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_default_constructible<std::allocator<int>> : public __is_nothrow_constructible_impl<allocator<int>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<allocator<int>>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_copy_constructible : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_copy_constructible<unsigned long *> : public __is_nothrow_constructible_impl<unsigned long *, __add_lval_ref_t<unsigned long *const>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long *>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_copy_constructible<std::_Bit_const_iterator> : public __is_nothrow_constructible_impl<_Bit_const_iterator, __add_lval_ref_t<const _Bit_const_iterator>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Bit_const_iterator>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_copy_constructible<std::_Bit_iterator> : public __is_nothrow_constructible_impl<_Bit_iterator, __add_lval_ref_t<const _Bit_iterator>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Bit_iterator>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_copy_constructible<const int *> : public __is_nothrow_constructible_impl<const int *, __add_lval_ref_t<const int *const>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const int *>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_copy_constructible<int *> : public __is_nothrow_constructible_impl<int *, __add_lval_ref_t<int *const>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<int *>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_copy_constructible<Base<ChildA, ChildB, ChildC> *const *> : public __is_nothrow_constructible_impl<Base<ChildA, ChildB, ChildC> *const *, __add_lval_ref_t<Base<ChildA, ChildB, ChildC> *const *const>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<Base<ChildA, ChildB, ChildC> *const *>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_nothrow_copy_constructible<Base<ChildA, ChildB, ChildC> **> : public __is_nothrow_constructible_impl<Base<ChildA, ChildB, ChildC> **, __add_lval_ref_t<Base<ChildA, ChildB, ChildC> **const>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<Base<ChildA, ChildB, ChildC> **>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_move_constructible : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;
    template <typename _Tp, typename _Up> struct is_assignable : public __is_assignable_impl<_Tp, _Up> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_copy_assignable : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_move_assignable : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_move_assignable<std::_Bit_iterator> : public __is_assignable_impl<__add_lval_ref_t<_Bit_iterator>, __add_rval_ref_t<_Bit_iterator>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Bit_iterator>{}), "template argument must be a complete class or an unbounded array");
    };
    template<> struct is_move_assignable<std::_Bit_const_iterator> : public __is_assignable_impl<__add_lval_ref_t<_Bit_const_iterator>, __add_rval_ref_t<_Bit_const_iterator>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Bit_const_iterator>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> using __is_nothrow_assignable_impl = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;
    template <typename _Tp, typename _Up> struct is_nothrow_assignable : public __is_nothrow_assignable_impl<_Tp, _Up> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_copy_assignable : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_move_assignable : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> using __is_trivially_constructible_impl = __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;
    template <typename _Tp, typename ..._Args> struct is_trivially_constructible : public __is_trivially_constructible_impl<_Tp, _Args...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_default_constructible : public __is_trivially_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_implicitly_default_constructible_impl {
        template <typename _Tp> static void __helper(const _Tp &);
        template <typename _Tp> static true_type __test(const _Tp &, decltype(__helper<const _Tp &>({})) * = 0);
        static false_type __test(...);
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_impl : public __do_is_implicitly_default_constructible_impl {
        typedef decltype(__test(declval<_Tp>())) type;
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_safe : public __is_implicitly_default_constructible_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_implicitly_default_constructible : public __and_<__is_constructible_impl<_Tp>, __is_implicitly_default_constructible_safe<_Tp>>::type {
    };
    template <typename _Tp> struct is_trivially_copy_constructible : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_move_constructible : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> using __is_trivially_assignable_impl = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;
    template <typename _Tp, typename _Up> struct is_trivially_assignable : public __is_trivially_assignable_impl<_Tp, _Up> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_copy_assignable : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_move_assignable : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_destructible : public __and_<__is_destructible_safe<_Tp>, __bool_constant<__has_trivial_destructor(_Tp)>>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename> struct rank : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, std::size_t _Size> struct rank<_Tp[_Size]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename _Tp> struct rank<_Tp[]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename, unsigned int _Uint = 0> struct extent : public integral_constant<size_t, 0> {
    };
    template <typename _Tp, size_t _Size> struct extent<_Tp[_Size], 0> : public integral_constant<size_t, _Size> {
    };
    template <typename _Tp, unsigned int _Uint, size_t _Size> struct extent<_Tp[_Size], _Uint> : public extent<_Tp, _Uint - 1>::type {
    };
    template <typename _Tp> struct extent<_Tp[], 0> : public integral_constant<size_t, 0> {
    };
    template <typename _Tp, unsigned int _Uint> struct extent<_Tp[], _Uint> : public extent<_Tp, _Uint - 1>::type {
    };
    template <typename _Tp, typename _Up> struct is_same : public integral_constant<bool, __is_same(_Tp, _Up)> {
    };
    template<> struct is_same<int, int> : public integral_constant<bool, __is_same(int, int)> {
    };
    template<> struct is_same<Base<ChildA, ChildB, ChildC> *, Base<ChildA, ChildB, ChildC> *> : public integral_constant<bool, __is_same(Base<ChildA, ChildB, ChildC> *, Base<ChildA, ChildB, ChildC> *)> {
    };
    template<> struct is_same<long, int> : public integral_constant<bool, __is_same(long, int)> {
    };
    template<> struct is_same<unsigned long, int> : public integral_constant<bool, __is_same(unsigned long, int)> {
    };
    template<> struct is_same<long long, int> : public integral_constant<bool, __is_same(long long, int)> {
    };
    template<> struct is_same<unsigned long long, int> : public integral_constant<bool, __is_same(unsigned long long, int)> {
    };
    template<> struct is_same<float, int> : public integral_constant<bool, __is_same(float, int)> {
    };
    template<> struct is_same<double, int> : public integral_constant<bool, __is_same(double, int)> {
    };
    template<> struct is_same<long double, int> : public integral_constant<bool, __is_same(long double, int)> {
    };
    template <typename _Base, typename _Derived> struct is_base_of : public integral_constant<bool, __is_base_of(_Base, _Derived)> {
    };
    template <typename _From, typename _To> struct is_convertible : public __bool_constant<__is_convertible(_From, _To)> {
    };
    template<> struct is_convertible<const char &&, const char &> : public __bool_constant<__is_convertible(const char &&, const char &)> {
    };
    template<> struct is_convertible<const wchar_t &&, const wchar_t &> : public __bool_constant<__is_convertible(const wchar_t &&, const wchar_t &)> {
    };
    template<> struct is_convertible<const char8_t &&, const char8_t &> : public __bool_constant<__is_convertible(const char8_t &&, const char8_t &)> {
    };
    template<> struct is_convertible<const char16_t &&, const char16_t &> : public __bool_constant<__is_convertible(const char16_t &&, const char16_t &)> {
    };
    template<> struct is_convertible<const char32_t &&, const char32_t &> : public __bool_constant<__is_convertible(const char32_t &&, const char32_t &)> {
    };
    template<> struct is_convertible<const unsigned int &, std::basic_string_view<char>> : public __bool_constant<__is_convertible(const unsigned int &, basic_string_view<char, char_traits<char>>)> {
    };
    template<> struct is_convertible<const char *const &, std::basic_string_view<char>> : public __bool_constant<__is_convertible(const char *const &, basic_string_view<char, char_traits<char>>)> {
    };
    template<> struct is_convertible<const char *const *, const std::basic_string<char> *> : public __bool_constant<__is_convertible(const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *)> {
    };
    template<> struct is_convertible<const char *const &, const char *> : public __bool_constant<__is_convertible(const char *const &, const char *)> {
    };
    template<> struct is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t>> : public __bool_constant<__is_convertible(const wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>)> {
    };
    template<> struct is_convertible<const wchar_t *const *, const std::basic_string<wchar_t> *> : public __bool_constant<__is_convertible(const wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *)> {
    };
    template<> struct is_convertible<const wchar_t *const &, const wchar_t *> : public __bool_constant<__is_convertible(const wchar_t *const &, const wchar_t *)> {
    };
    template<> struct is_convertible<const char8_t *const &, std::basic_string_view<char8_t>> : public __bool_constant<__is_convertible(const char8_t *const &, basic_string_view<char8_t, char_traits<char8_t>>)> {
    };
    template<> struct is_convertible<const char8_t *const *, const std::basic_string<char8_t> *> : public __bool_constant<__is_convertible(const char8_t *const *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *)> {
    };
    template<> struct is_convertible<const char8_t *const &, const char8_t *> : public __bool_constant<__is_convertible(const char8_t *const &, const char8_t *)> {
    };
    template<> struct is_convertible<const char16_t *const &, std::basic_string_view<char16_t>> : public __bool_constant<__is_convertible(const char16_t *const &, basic_string_view<char16_t, char_traits<char16_t>>)> {
    };
    template<> struct is_convertible<const char16_t *const *, const std::basic_string<char16_t> *> : public __bool_constant<__is_convertible(const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *)> {
    };
    template<> struct is_convertible<const char16_t *const &, const char16_t *> : public __bool_constant<__is_convertible(const char16_t *const &, const char16_t *)> {
    };
    template<> struct is_convertible<const char32_t *const &, std::basic_string_view<char32_t>> : public __bool_constant<__is_convertible(const char32_t *const &, basic_string_view<char32_t, char_traits<char32_t>>)> {
    };
    template<> struct is_convertible<const char32_t *const *, const std::basic_string<char32_t> *> : public __bool_constant<__is_convertible(const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *)> {
    };
    template<> struct is_convertible<const char32_t *const &, const char32_t *> : public __bool_constant<__is_convertible(const char32_t *const &, const char32_t *)> {
    };
    template<> struct is_convertible<const std::allocator<char> &, std::basic_string_view<char>> : public __bool_constant<__is_convertible(const allocator<char> &, basic_string_view<char, char_traits<char>>)> {
    };
    template<> struct is_convertible<const std::basic_string<char> &, std::basic_string_view<char>> : public __bool_constant<__is_convertible(const basic_string<char, char_traits<char>, allocator<char>> &, basic_string_view<char, char_traits<char>>)> {
    };
    template<> struct is_convertible<const std::basic_string<char> *, const std::basic_string<char> *> : public __bool_constant<__is_convertible(const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *)> {
    };
    template<> struct is_convertible<char *const &, std::basic_string_view<char>> : public __bool_constant<__is_convertible(char *const &, basic_string_view<char, char_traits<char>>)> {
    };
    template<> struct is_convertible<char *const *, const std::basic_string<char> *> : public __bool_constant<__is_convertible(char *const *, const basic_string<char, char_traits<char>, allocator<char>> *)> {
    };
    template<> struct is_convertible<char *const &, const char *> : public __bool_constant<__is_convertible(char *const &, const char *)> {
    };
    template<> struct is_convertible<const char &, std::basic_string_view<char>> : public __bool_constant<__is_convertible(const char &, basic_string_view<char, char_traits<char>>)> {
    };
    template<> struct is_convertible<const int &, std::basic_string_view<char>> : public __bool_constant<__is_convertible(const int &, basic_string_view<char, char_traits<char>>)> {
    };
    template<> struct is_convertible<std::_Bit_reference &&, std::_Bit_reference &&> : public __bool_constant<__is_convertible(_Bit_reference &&, _Bit_reference &&)> {
    };
    template<> struct is_convertible<bool &&, const bool &> : public __bool_constant<__is_convertible(bool &&, const bool &)> {
    };
    template<> struct is_convertible<bool &&, bool &&> : public __bool_constant<__is_convertible(bool &&, bool &&)> {
    };
    template<> struct is_convertible<const char (&)[24], std::basic_string_view<char>> : public __bool_constant<__is_convertible(const char (&)[24], basic_string_view<char, char_traits<char>>)> {
    };
    template<> struct is_convertible<const char (*)[24], const std::basic_string<char> *> : public __bool_constant<__is_convertible(const char (*)[24], const basic_string<char, char_traits<char>, allocator<char>> *)> {
    };
    template<> struct is_convertible<const char (&)[24], const char *> : public __bool_constant<__is_convertible(const char (&)[24], const char *)> {
    };
    template<> struct is_convertible<std::random_access_iterator_tag, std::input_iterator_tag> : public __bool_constant<__is_convertible(random_access_iterator_tag, input_iterator_tag)> {
    };
    template<> struct is_convertible<wchar_t *const &, std::basic_string_view<wchar_t>> : public __bool_constant<__is_convertible(wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>)> {
    };
    template<> struct is_convertible<wchar_t *const *, const std::basic_string<wchar_t> *> : public __bool_constant<__is_convertible(wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *)> {
    };
    template<> struct is_convertible<wchar_t *const &, const wchar_t *> : public __bool_constant<__is_convertible(wchar_t *const &, const wchar_t *)> {
    };
    template <typename _ToElementType, typename _FromElementType> using __is_array_convertible = is_convertible<_FromElementType (*)[], _ToElementType (*)[]>;
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_nt_convertible_helper : is_void<_To> {
    };
    template <typename _From, typename _To> class __is_nt_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1> static __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))> __test(int);
        template <typename, typename> static false_type __test(...);
    public:
        using type = decltype(__test<_From, _To>(0));
    };
    template <typename _From, typename _To> struct is_nothrow_convertible : public __is_nt_convertible_helper<_From, _To>::type {
    };
    template <typename _From, typename _To> constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_From, _To>::value;
    template <typename _Tp> struct remove_const {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_const<const _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile<volatile _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_cv {
        using type = __remove_cv(_Tp);
    };
    template<> struct remove_cv<wchar_t> {
        using type = __remove_cv(wchar_t);
    };
    template<> struct remove_cv<unsigned int> {
        using type = __remove_cv(unsigned int);
    };
    template<> struct remove_cv<char8_t> {
        using type = __remove_cv(char8_t);
    };
    template<> struct remove_cv<unsigned char> {
        using type = __remove_cv(unsigned char);
    };
    template<> struct remove_cv<char16_t> {
        using type = __remove_cv(char16_t);
    };
    template<> struct remove_cv<unsigned short> {
        using type = __remove_cv(unsigned short);
    };
    template<> struct remove_cv<char32_t> {
        using type = __remove_cv(char32_t);
    };
    template<> struct remove_cv<double> {
        using type = __remove_cv(double);
    };
    template<> struct remove_cv<std::ranges::__detail::__max_size_type> {
        using type = __remove_cv(std::ranges::__detail::__max_size_type);
    };
    template<> struct remove_cv<int> {
        using type = __remove_cv(int);
    };
    template<> struct remove_cv<unsigned __int128> {
        using type = __remove_cv(unsigned __int128);
    };
    template<> struct remove_cv<unsigned long> {
        using type = __remove_cv(unsigned long);
    };
    template<> struct remove_cv<std::ranges::__detail::__max_diff_type> {
        using type = __remove_cv(std::ranges::__detail::__max_diff_type);
    };
    template<> struct remove_cv<const char> {
        using type = __remove_cv(const char);
    };
    template<> struct remove_cv<long> {
        using type = __remove_cv(long);
    };
    template<> struct remove_cv<const char *> {
        using type = __remove_cv(const char *);
    };
    template<> struct remove_cv<const wchar_t> {
        using type = __remove_cv(const wchar_t);
    };
    template<> struct remove_cv<const wchar_t *> {
        using type = __remove_cv(const wchar_t *);
    };
    template<> struct remove_cv<const char8_t> {
        using type = __remove_cv(const char8_t);
    };
    template<> struct remove_cv<const char8_t *> {
        using type = __remove_cv(const char8_t *);
    };
    template<> struct remove_cv<const char16_t> {
        using type = __remove_cv(const char16_t);
    };
    template<> struct remove_cv<const char16_t *> {
        using type = __remove_cv(const char16_t *);
    };
    template<> struct remove_cv<const char32_t> {
        using type = __remove_cv(const char32_t);
    };
    template<> struct remove_cv<const char32_t *> {
        using type = __remove_cv(const char32_t *);
    };
    template<> struct remove_cv<std::_Bit_iterator> {
        using type = __remove_cv(std::_Bit_iterator);
    };
    template<> struct remove_cv<bool> {
        using type = __remove_cv(bool);
    };
    template<> struct remove_cv<std::_Bit_const_iterator> {
        using type = __remove_cv(std::_Bit_const_iterator);
    };
    template<> struct remove_cv<const int> {
        using type = __remove_cv(const int);
    };
    template<> struct remove_cv<char> {
        using type = __remove_cv(char);
    };
    template<> struct remove_cv<Base<ChildA, ChildB, ChildC> *> {
        using type = __remove_cv(Base<ChildA, ChildB, ChildC> *);
    };
    template<> struct remove_cv<Base<ChildA, ChildB, ChildC> *const> {
        using type = __remove_cv(Base<ChildA, ChildB, ChildC> *const);
    };
    template <typename _Tp> struct add_const {
        using type = const _Tp;
    };
    template <typename _Tp> struct add_volatile {
        using type = volatile _Tp;
    };
    template <typename _Tp> struct add_cv {
        using type = const volatile _Tp;
    };
    template <typename _Tp> using remove_const_t = typename remove_const<_Tp>::type;
    template <typename _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
    template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename _Tp> using add_const_t = typename add_const<_Tp>::type;
    template <typename _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
    template <typename _Tp> using add_cv_t = typename add_cv<_Tp>::type;
    template <typename _Tp> struct remove_reference {
        using type = _Tp;
    };
    template<> struct remove_reference<const char &> {
        using type = const char;
    };
    template<> struct remove_reference<char &> {
        using type = char;
    };
    template<> struct remove_reference<const wchar_t &> {
        using type = const wchar_t;
    };
    template<> struct remove_reference<wchar_t &> {
        using type = wchar_t;
    };
    template<> struct remove_reference<const char8_t &> {
        using type = const char8_t;
    };
    template<> struct remove_reference<char8_t &> {
        using type = char8_t;
    };
    template<> struct remove_reference<const char16_t &> {
        using type = const char16_t;
    };
    template<> struct remove_reference<const char32_t &> {
        using type = const char32_t;
    };
    template<> struct remove_reference<const char *&> {
        using type = const char *;
    };
    template<> struct remove_reference<const char *> {
        using type = const char *;
    };
    template<> struct remove_reference<const char *const &> {
        using type = const char *const;
    };
    template<> struct remove_reference<const char *const> {
        using type = const char *const;
    };
    template<> struct remove_reference<unsigned long &> {
        using type = unsigned long;
    };
    template<> struct remove_reference<unsigned long> {
        using type = unsigned long;
    };
    template<> struct remove_reference<const unsigned long &> {
        using type = const unsigned long;
    };
    template<> struct remove_reference<const unsigned long> {
        using type = const unsigned long;
    };
    template<> struct remove_reference<const wchar_t *&> {
        using type = const wchar_t *;
    };
    template<> struct remove_reference<const wchar_t *> {
        using type = const wchar_t *;
    };
    template<> struct remove_reference<const wchar_t *const &> {
        using type = const wchar_t *const;
    };
    template<> struct remove_reference<const wchar_t *const> {
        using type = const wchar_t *const;
    };
    template<> struct remove_reference<const char8_t *&> {
        using type = const char8_t *;
    };
    template<> struct remove_reference<const char8_t *> {
        using type = const char8_t *;
    };
    template<> struct remove_reference<const char8_t *const &> {
        using type = const char8_t *const;
    };
    template<> struct remove_reference<const char8_t *const> {
        using type = const char8_t *const;
    };
    template<> struct remove_reference<const char16_t *&> {
        using type = const char16_t *;
    };
    template<> struct remove_reference<const char16_t *> {
        using type = const char16_t *;
    };
    template<> struct remove_reference<const char16_t *const &> {
        using type = const char16_t *const;
    };
    template<> struct remove_reference<const char16_t *const> {
        using type = const char16_t *const;
    };
    template<> struct remove_reference<const char32_t *&> {
        using type = const char32_t *;
    };
    template<> struct remove_reference<const char32_t *> {
        using type = const char32_t *;
    };
    template<> struct remove_reference<const char32_t *const &> {
        using type = const char32_t *const;
    };
    template<> struct remove_reference<const char32_t *const> {
        using type = const char32_t *const;
    };
    template<> struct remove_reference<std::allocator<char> &> {
        using type = std::allocator<char>;
    };
    template<> struct remove_reference<const std::error_category *> {
        using type = const std::error_category *;
    };
    template<> struct remove_reference<const std::error_category *const &> {
        using type = const std::error_category *const;
    };
    template<> struct remove_reference<std::basic_string<char> &> {
        using type = std::basic_string<char>;
    };
    template<> struct remove_reference<std::_Bit_iterator &> {
        using type = std::_Bit_iterator;
    };
    template<> struct remove_reference<std::_Bit_iterator> {
        using type = std::_Bit_iterator;
    };
    template<> struct remove_reference<const std::_Bit_iterator &> {
        using type = const std::_Bit_iterator;
    };
    template<> struct remove_reference<std::_Bit_reference &> {
        using type = std::_Bit_reference;
    };
    template<> struct remove_reference<const std::_Bit_iterator> {
        using type = const std::_Bit_iterator;
    };
    template<> struct remove_reference<std::_Bit_const_iterator &> {
        using type = std::_Bit_const_iterator;
    };
    template<> struct remove_reference<std::_Bit_const_iterator> {
        using type = std::_Bit_const_iterator;
    };
    template<> struct remove_reference<const std::_Bit_const_iterator &> {
        using type = const std::_Bit_const_iterator;
    };
    template<> struct remove_reference<bool &> {
        using type = bool;
    };
    template<> struct remove_reference<const std::_Bit_const_iterator> {
        using type = const std::_Bit_const_iterator;
    };
    template<> struct remove_reference<const int &> {
        using type = const int;
    };
    template<> struct remove_reference<Base<ChildA, ChildB, ChildC> *const &> {
        using type = Base<ChildA, ChildB, ChildC> *const;
    };
    template<> struct remove_reference<std::_Vector_base<int, std::allocator<int>>::_Vector_impl &> {
        using type = std::_Vector_base<int, std::allocator<int>>::_Vector_impl;
    };
    template<> struct remove_reference<Base<ChildA, ChildB, ChildC> &> {
        using type = Base<ChildA, ChildB, ChildC>;
    };
    template<> struct remove_reference<std::vector<int> &> {
        using type = std::vector<int>;
    };
    template<> struct remove_reference<std::allocator<int> &> {
        using type = std::allocator<int>;
    };
    template <typename _Tp> struct remove_reference<_Tp &> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_reference<_Tp &&> {
        using type = _Tp;
    };
    template <typename _Tp> struct add_lvalue_reference {
        using type = __add_lval_ref_t<_Tp>;
    };
    template <typename _Tp> struct add_rvalue_reference {
        using type = __add_rval_ref_t<_Tp>;
    };
    template <typename _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
    template <typename _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
    template <typename _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
    template <typename _Unqualified, bool _IsConst, bool _IsVol> struct __cv_selector
    template<> struct __cv_selector<unsigned int, false, false> {
        typedef unsigned int __type;
    }
    template<> struct __cv_selector<unsigned char, false, false> {
        typedef unsigned char __type;
    }
    template<> struct __cv_selector<unsigned short, false, false> {
        typedef unsigned short __type;
    }
    template<> struct __cv_selector<int, false, false> {
        typedef int __type;
    }
    template<> struct __cv_selector<signed char, false, false> {
        typedef signed char __type;
    }
    template<> struct __cv_selector<short, false, false> {
        typedef short __type;
    }
    template<> struct __cv_selector<const char *const, true, false> {
        typedef const char *const const __type;
    }
    template<> struct __cv_selector<char, true, false> {
        typedef const char __type;
    }
    template<> struct __cv_selector<const char, false, false> {
        typedef const char __type;
    }
    template<> struct __cv_selector<const char, true, false> {
        typedef const const char __type;
    }
    template<> struct __cv_selector<const unsigned long, true, false> {
        typedef const const unsigned long __type;
    }
    template<> struct __cv_selector<const wchar_t *const, true, false> {
        typedef const wchar_t *const const __type;
    }
    template<> struct __cv_selector<wchar_t, true, false> {
        typedef const wchar_t __type;
    }
    template<> struct __cv_selector<const wchar_t, false, false> {
        typedef const wchar_t __type;
    }
    template<> struct __cv_selector<const wchar_t, true, false> {
        typedef const const wchar_t __type;
    }
    template<> struct __cv_selector<const char8_t *const, true, false> {
        typedef const char8_t *const const __type;
    }
    template<> struct __cv_selector<char8_t, true, false> {
        typedef const char8_t __type;
    }
    template<> struct __cv_selector<const char8_t, false, false> {
        typedef const char8_t __type;
    }
    template<> struct __cv_selector<const char8_t, true, false> {
        typedef const const char8_t __type;
    }
    template<> struct __cv_selector<const char16_t *const, true, false> {
        typedef const char16_t *const const __type;
    }
    template<> struct __cv_selector<char16_t, true, false> {
        typedef const char16_t __type;
    }
    template<> struct __cv_selector<const char16_t, false, false> {
        typedef const char16_t __type;
    }
    template<> struct __cv_selector<const char16_t, true, false> {
        typedef const const char16_t __type;
    }
    template<> struct __cv_selector<const char32_t *const, true, false> {
        typedef const char32_t *const const __type;
    }
    template<> struct __cv_selector<char32_t, true, false> {
        typedef const char32_t __type;
    }
    template<> struct __cv_selector<const char32_t, false, false> {
        typedef const char32_t __type;
    }
    template<> struct __cv_selector<const char32_t, true, false> {
        typedef const const char32_t __type;
    }
    template<> struct __cv_selector<const std::error_category *const, true, false> {
        typedef const std::error_category *const const __type;
    }
    template<> struct __cv_selector<const std::_Bit_iterator, true, false> {
        typedef const const std::_Bit_iterator __type;
    }
    template<> struct __cv_selector<bool, true, false> {
        typedef const bool __type;
    }
    template<> struct __cv_selector<const std::_Bit_reference, false, false> {
        typedef const std::_Bit_reference __type;
    }
    template<> struct __cv_selector<std::_Bit_reference, false, false> {
        typedef std::_Bit_reference __type;
    }
    template<> struct __cv_selector<const bool, true, false> {
        typedef const const bool __type;
    }
    template<> struct __cv_selector<const std::_Bit_reference, true, false> {
        typedef const const std::_Bit_reference __type;
    }
    template<> struct __cv_selector<const std::_Bit_const_iterator, true, false> {
        typedef const const std::_Bit_const_iterator __type;
    }
    template<> struct __cv_selector<const bool, false, false> {
        typedef const bool __type;
    }
    template<> struct __cv_selector<bool, false, false> {
        typedef bool __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, false> {
        typedef _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, true> {
        typedef volatile _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, false> {
        typedef const _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, true> {
        typedef const volatile _Unqualified __type;
    };
    template <typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value, bool _IsVol = is_volatile<_Qualified>::value> class __match_cv_qualifiers {
        typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<wchar_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char8_t, unsigned char, false, false> {
        typedef __cv_selector<unsigned char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char16_t, unsigned short, false, false> {
        typedef __cv_selector<unsigned short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char32_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<unsigned int, int, false, false> {
        typedef __cv_selector<int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<unsigned char, signed char, false, false> {
        typedef __cv_selector<signed char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<unsigned short, short, false, false> {
        typedef __cv_selector<short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char *const, const char *const, true, false> {
        typedef __cv_selector<const char *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char, char, true, false> {
        typedef __cv_selector<char, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char, const char, false, false> {
        typedef __cv_selector<const char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char, const char, true, false> {
        typedef __cv_selector<const char, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const unsigned long, const unsigned long, true, false> {
        typedef __cv_selector<const unsigned long, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const wchar_t *const, const wchar_t *const, true, false> {
        typedef __cv_selector<const wchar_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const wchar_t, wchar_t, true, false> {
        typedef __cv_selector<wchar_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<wchar_t, const wchar_t, false, false> {
        typedef __cv_selector<const wchar_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const wchar_t, const wchar_t, true, false> {
        typedef __cv_selector<const wchar_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char8_t *const, const char8_t *const, true, false> {
        typedef __cv_selector<const char8_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char8_t, char8_t, true, false> {
        typedef __cv_selector<char8_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char8_t, const char8_t, false, false> {
        typedef __cv_selector<const char8_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char8_t, const char8_t, true, false> {
        typedef __cv_selector<const char8_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char16_t *const, const char16_t *const, true, false> {
        typedef __cv_selector<const char16_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char16_t, char16_t, true, false> {
        typedef __cv_selector<char16_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char16_t, const char16_t, false, false> {
        typedef __cv_selector<const char16_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char16_t, const char16_t, true, false> {
        typedef __cv_selector<const char16_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char32_t *const, const char32_t *const, true, false> {
        typedef __cv_selector<const char32_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char32_t, char32_t, true, false> {
        typedef __cv_selector<char32_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<char32_t, const char32_t, false, false> {
        typedef __cv_selector<const char32_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const char32_t, const char32_t, true, false> {
        typedef __cv_selector<const char32_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const std::error_category *const, const std::error_category *const, true, false> {
        typedef __cv_selector<const error_category *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const std::_Bit_iterator, const std::_Bit_iterator, true, false> {
        typedef __cv_selector<const _Bit_iterator, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const std::_Bit_reference, bool, true, false> {
        typedef __cv_selector<bool, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<bool, const std::_Bit_reference, false, false> {
        typedef __cv_selector<const _Bit_reference, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<std::_Bit_reference, std::_Bit_reference, false, false> {
        typedef __cv_selector<_Bit_reference, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const std::_Bit_reference, const bool, true, false> {
        typedef __cv_selector<const bool, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const bool, const std::_Bit_reference, true, false> {
        typedef __cv_selector<const _Bit_reference, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const std::_Bit_const_iterator, const std::_Bit_const_iterator, true, false> {
        typedef __cv_selector<const _Bit_const_iterator, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const bool, bool, true, false> {
        typedef __cv_selector<bool, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<bool, const bool, false, false> {
        typedef __cv_selector<const bool, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<bool, bool, false, false> {
        typedef __cv_selector<bool, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template<> class __match_cv_qualifiers<const bool, const bool, true, false> {
        typedef __cv_selector<const bool, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template <typename _Tp> struct __make_unsigned {
        typedef _Tp __type;
    };
    template<> struct __make_unsigned<char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<signed char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<short> {
        typedef unsigned short __type;
    };
    template<> struct __make_unsigned<int> {
        typedef unsigned int __type;
    };
    template<> struct __make_unsigned<long> {
        typedef unsigned long __type;
    };
    template<> struct __make_unsigned<long long> {
        typedef unsigned long long __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_unsigned_selector
    template<> class __make_unsigned_selector<wchar_t, false, true> : __make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(wchar_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char8_t, false, true> : __make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char8_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char8_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char16_t, false, true> : __make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char16_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char32_t, false, true> : __make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char32_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<wchar_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<wchar_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char8_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char8_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char8_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char16_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char16_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
    template<> class __make_unsigned_selector<char32_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char32_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    class __make_unsigned_selector_base {
    protected:
        template <typename ...> struct _List {
        };
        template<> struct _List<<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned short, unsigned int, unsigned long, unsigned long long> {
            static constexpr size_t __size = sizeof(unsigned char);
        };
        template<> struct _List<<unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned int, unsigned long, unsigned long long> {
            static constexpr size_t __size = sizeof(unsigned short);
        };
        template<> struct _List<<unsigned int, unsigned long, unsigned long long>> : _List<unsigned long, unsigned long long> {
            static constexpr size_t __size = sizeof(unsigned int);
        };
        template<> struct _List<<unsigned long, unsigned long long>> : _List<unsigned long long> {
            static constexpr size_t __size;
        };
        template<> struct _List<<unsigned long long>> : _List<> {
            static constexpr size_t __size;
        };
        template<> struct _List<<>> {
        };
        template <typename _Tp, typename ..._Up> struct _List<_Tp, _Up...> : _List<_Up...> {
            static constexpr size_t __size = sizeof(_Tp);
        };
        template <size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)> struct __select
        template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
        template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned int, unsigned long, unsigned long long>> {
        }
        template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned int;
        }
        template<> struct __select<1, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned char;
        }
        template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
        template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned short;
        };
        template <size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, true> {
            using __type = _Uint;
        };
        template <size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, false> : __select<_Sz, _List<_UInts...>> {
        };
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, false, true> : __make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    template<> struct __make_unsigned<wchar_t> {
        using __type = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char8_t> {
        using __type = typename __make_unsigned_selector<char8_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char16_t> {
        using __type = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char32_t> {
        using __type = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_unsigned {
        typedef typename __make_unsigned_selector<_Tp>::__type type;
    };
    template<> struct make_unsigned<bool>;
    template<> struct make_unsigned<const bool>;
    template<> struct make_unsigned<volatile bool>;
    template<> struct make_unsigned<const volatile bool>;
    template <typename _Tp> struct __make_signed {
        typedef _Tp __type;
    };
    template<> struct __make_signed<char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned short> {
        typedef short __type;
    };
    template<> struct __make_signed<unsigned int> {
        typedef int __type;
    };
    template<> struct __make_signed<unsigned long> {
        typedef long __type;
    };
    template<> struct __make_signed<unsigned long long> {
        typedef long long __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_signed_selector
    template<> class __make_signed_selector<wchar_t, false, true> {
        typedef typename __make_unsigned_selector<wchar_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
    template<> class __make_signed_selector<unsigned int, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned int>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned int, __signed_type>::__type;
    }
    template<> class __make_signed_selector<char8_t, false, true> {
        typedef typename __make_unsigned_selector<char8_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
    template<> class __make_signed_selector<unsigned char, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned char>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned char, __signed_type>::__type;
    }
    template<> class __make_signed_selector<char16_t, false, true> {
        typedef typename __make_unsigned_selector<char16_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
    template<> class __make_signed_selector<unsigned short, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned short>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned short, __signed_type>::__type;
    }
    template<> class __make_signed_selector<char32_t, false, true> {
        typedef typename __make_unsigned_selector<char32_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, false, true> {
        typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template<> struct __make_signed<wchar_t> {
        using __type = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
    template<> struct __make_signed<char8_t> {
        using __type = typename __make_signed_selector<char8_t, false, true>::__type;
    };
    template<> struct __make_signed<char16_t> {
        using __type = typename __make_signed_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_signed<char32_t> {
        using __type = typename __make_signed_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_signed {
        typedef typename __make_signed_selector<_Tp>::__type type;
    };
    template<> struct make_signed<bool>;
    template<> struct make_signed<const bool>;
    template<> struct make_signed<volatile bool>;
    template<> struct make_signed<const volatile bool>;
    template <typename _Tp> using make_signed_t = typename make_signed<_Tp>::type;
    template <typename _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
    template <typename _Tp> struct remove_extent {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp[_Size]> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_extent<_Tp[]> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_all_extents {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_all_extents<_Tp[_Size]> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> struct remove_all_extents<_Tp[]> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
    template <typename _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
    template <typename _Tp, typename> struct __remove_pointer_helper {
        typedef _Tp type;
    };
    template <typename _Tp, typename _Up> struct __remove_pointer_helper<_Tp, _Up *> {
        typedef _Up type;
    };
    template <typename _Tp> struct remove_pointer : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {
    };
    template <typename _Tp, typename = void> struct __add_pointer_helper {
        using type = _Tp;
    };
    template <typename _Tp> struct __add_pointer_helper<_Tp, __void_t<_Tp *>> {
        using type = _Tp *;
    };
    template <typename _Tp> struct add_pointer : public __add_pointer_helper<_Tp> {
    };
    template<> struct add_pointer<const char &> {
        using type = const char *;
    };
    template<> struct add_pointer<const wchar_t &> {
        using type = const wchar_t *;
    };
    template<> struct add_pointer<const char8_t &> {
        using type = const char8_t *;
    };
    template<> struct add_pointer<const char16_t &> {
        using type = const char16_t *;
    };
    template<> struct add_pointer<const char32_t &> {
        using type = const char32_t *;
    };
    template <typename _Tp> struct add_pointer<_Tp &> {
        using type = _Tp *;
    };
    template <typename _Tp> struct add_pointer<_Tp &&> {
        using type = _Tp *;
    };
    template <typename _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
    template <typename _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
    template <std::size_t _Len> struct __aligned_storage_msa {
        union __type {
            unsigned char __data[_Len];
            struct __attribute__((aligned)) {
            } __align;
        };
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> struct aligned_storage {
        union type {
            unsigned char __data[_Len];
            struct __attribute__((aligned((_Align)))) {
            } __align;
        };
    };
    template <typename ..._Types> struct __strictest_alignment {
        static const size_t _S_alignment = 0;
        static const size_t _S_size = 0;
    };
    template <typename _Tp, typename ..._Types> struct __strictest_alignment<_Tp, _Types...> {
        static const size_t _S_alignment = alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
        static const size_t _S_size = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
    template <size_t _Len, typename ..._Types> struct aligned_union {
    private:
        static_assert(sizeof...(_Types) != 0, "At least one type is required");
        using __strictest = __strictest_alignment<_Types...>;
        static const size_t _S_len = _Len > __strictest::_S_size ? _Len : __strictest::_S_size;
    public:
        static const size_t alignment_value = __strictest::_S_alignment;
        typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };
    const size_t alignment_value;
    template <typename _Up> struct __decay_selector : __conditional_t<is_const<const _Up>::value, remove_cv<_Up>, add_pointer<_Up>> {
    };
    template <typename _Up, size_t _Nm> struct __decay_selector<_Up[_Nm]> {
        using type = _Up *;
    };
    template <typename _Up> struct __decay_selector<_Up[]> {
        using type = _Up *;
    };
    template <typename _Tp> struct decay {
        using type = typename __decay_selector<_Tp>::type;
    };
    template <typename _Tp> struct decay<_Tp &> {
        using type = typename __decay_selector<_Tp>::type;
    };
    template <typename _Tp> struct decay<_Tp &&> {
        using type = typename __decay_selector<_Tp>::type;
    };
    template <typename _Tp> struct __strip_reference_wrapper {
        typedef _Tp __type;
    };
    template <typename _Tp> struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
        typedef _Tp &__type;
    };
    template <typename _Tp> using __decay_t = typename decay<_Tp>::type;
    template <typename _Tp> using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;
    template <typename ..._Cond> using _Require = __enable_if_t<__and_<_Cond...>::value>;
    template <typename _Tp> using __remove_cvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> struct conditional {
        typedef _Iftrue type;
    };
    template <typename _Iftrue, typename _Iffalse> struct conditional<false, _Iftrue, _Iffalse> {
        typedef _Iffalse type;
    };
    template <typename ..._Tp> struct common_type;
    template <typename _Tp> struct __success_type {
        typedef _Tp type;
    };
    struct __failure_type {
    };
    struct __do_common_type_impl {
        template <typename _Tp, typename _Up> using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());
        template <typename _Tp, typename _Up> static __success_type<__decay_t<__cond_t<_Tp, _Up>>> _S_test(int);
        template <typename _Tp, typename _Up> static __success_type<__remove_cvref_t<__cond_t<const _Tp &, const _Up &>>> _S_test_2(int);
        template <typename, typename> static __failure_type _S_test_2(...);
        template <typename _Tp, typename _Up> static decltype(_S_test_2<_Tp, _Up>(0)) _S_test(...);
    };
    template<> struct common_type<> {
    };
    template <typename _Tp0> struct common_type<_Tp0> : public common_type<_Tp0, _Tp0> {
    };
    template <typename _Tp1, typename _Tp2, typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>> struct __common_type_impl {
        using type = common_type<_Dp1, _Dp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2> : private __do_common_type_impl {
        using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };
    template <typename _Tp1, typename _Tp2> struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type {
    };
    template <typename ...> struct __common_type_pack {
    };
    template <typename, typename, typename = void> struct __common_type_fold;
    template <typename _Tp1, typename _Tp2, typename ..._Rp> struct common_type<_Tp1, _Tp2, _Rp...> : public __common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>> {
    };
    template <typename _CTp, typename ..._Rp> struct __common_type_fold<_CTp, __common_type_pack<_Rp...>, __void_t<typename _CTp::type>> : public common_type<typename _CTp::type, _Rp...> {
    };
    template <typename _CTp, typename _Rp> struct __common_type_fold<_CTp, _Rp, void> {
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl {
        using type = __underlying_type(_Tp);
    };
    template <typename _Tp> struct __underlying_type_impl<_Tp, false> {
    };
    template <typename _Tp> struct underlying_type : public __underlying_type_impl<_Tp> {
    };
    template <typename _Tp> struct __declval_protector {
        static const bool __stop = false;
    };
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0)) {
        static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
        return __declval<_Tp>(0);
    }
    template<> auto declval<const std::ranges::__cust_swap::_Swap &>() noexcept -> decltype(__declval<const std::ranges::__cust_swap::_Swap &>(0))    template<> auto declval<const char &>() noexcept -> decltype(__declval<const char &>(0))    template<> auto declval<char &>() noexcept -> decltype(__declval<char &>(0))    template<> auto declval<const wchar_t &>() noexcept -> decltype(__declval<const wchar_t &>(0))    template<> auto declval<wchar_t &>() noexcept -> decltype(__declval<wchar_t &>(0))    template<> auto declval<const char8_t &>() noexcept -> decltype(__declval<const char8_t &>(0))    template<> auto declval<char8_t &>() noexcept -> decltype(__declval<char8_t &>(0))    template<> auto declval<const char16_t &>() noexcept -> decltype(__declval<const char16_t &>(0))    template<> auto declval<const char32_t &>() noexcept -> decltype(__declval<const char32_t &>(0))    template<> auto declval<const char *>() noexcept -> decltype(__declval<const char *>(0))    template<> auto declval<const char *const &(&)()>() noexcept -> decltype(__declval<const char *const &(&)()>(0))    template<> auto declval<const char *const &>() noexcept -> decltype(__declval<const char *const &>(0))    template<> auto declval<const char *&>() noexcept -> decltype(__declval<const char *&>(0))    template<> auto declval<const char &(&)()>() noexcept -> decltype(__declval<const char &(&)()>(0))    template<> auto declval<const char &&>() noexcept -> decltype(__declval<const char &&>(0))    template<> auto declval<const char *const>() noexcept -> decltype(__declval<const char *const>(0))    template<> auto declval<bool>() noexcept -> decltype(__declval<bool>(0))    template<> auto declval<unsigned long>() noexcept -> decltype(__declval<unsigned long>(0))    template<> auto declval<unsigned long &>() noexcept -> decltype(__declval<unsigned long &>(0))    template<> auto declval<const unsigned long &>() noexcept -> decltype(__declval<const unsigned long &>(0))    template<> auto declval<const unsigned long>() noexcept -> decltype(__declval<const unsigned long>(0))    template<> auto declval<const unsigned long &(&)()>() noexcept -> decltype(__declval<const unsigned long &(&)()>(0))    template<> auto declval<const wchar_t *>() noexcept -> decltype(__declval<const wchar_t *>(0))    template<> auto declval<const wchar_t *const &(&)()>() noexcept -> decltype(__declval<const wchar_t *const &(&)()>(0))    template<> auto declval<const wchar_t *const &>() noexcept -> decltype(__declval<const wchar_t *const &>(0))    template<> auto declval<const wchar_t *&>() noexcept -> decltype(__declval<const wchar_t *&>(0))    template<> auto declval<const wchar_t &(&)()>() noexcept -> decltype(__declval<const wchar_t &(&)()>(0))    template<> auto declval<const wchar_t &&>() noexcept -> decltype(__declval<const wchar_t &&>(0))    template<> auto declval<const wchar_t *const>() noexcept -> decltype(__declval<const wchar_t *const>(0))    template<> auto declval<const char8_t *>() noexcept -> decltype(__declval<const char8_t *>(0))    template<> auto declval<const char8_t *const &(&)()>() noexcept -> decltype(__declval<const char8_t *const &(&)()>(0))    template<> auto declval<const char8_t *const &>() noexcept -> decltype(__declval<const char8_t *const &>(0))    template<> auto declval<const char8_t *&>() noexcept -> decltype(__declval<const char8_t *&>(0))    template<> auto declval<const char8_t &(&)()>() noexcept -> decltype(__declval<const char8_t &(&)()>(0))    template<> auto declval<const char8_t &&>() noexcept -> decltype(__declval<const char8_t &&>(0))    template<> auto declval<const char8_t *const>() noexcept -> decltype(__declval<const char8_t *const>(0))    template<> auto declval<const char16_t *>() noexcept -> decltype(__declval<const char16_t *>(0))    template<> auto declval<const char16_t *const &(&)()>() noexcept -> decltype(__declval<const char16_t *const &(&)()>(0))    template<> auto declval<const char16_t *const &>() noexcept -> decltype(__declval<const char16_t *const &>(0))    template<> auto declval<const char16_t *&>() noexcept -> decltype(__declval<const char16_t *&>(0))    template<> auto declval<const char16_t &(&)()>() noexcept -> decltype(__declval<const char16_t &(&)()>(0))    template<> auto declval<char16_t &>() noexcept -> decltype(__declval<char16_t &>(0))    template<> auto declval<const char16_t &&>() noexcept -> decltype(__declval<const char16_t &&>(0))    template<> auto declval<const char16_t *const>() noexcept -> decltype(__declval<const char16_t *const>(0))    template<> auto declval<const char32_t *>() noexcept -> decltype(__declval<const char32_t *>(0))    template<> auto declval<const char32_t *const &(&)()>() noexcept -> decltype(__declval<const char32_t *const &(&)()>(0))    template<> auto declval<const char32_t *const &>() noexcept -> decltype(__declval<const char32_t *const &>(0))    template<> auto declval<const char32_t *&>() noexcept -> decltype(__declval<const char32_t *&>(0))    template<> auto declval<const char32_t &(&)()>() noexcept -> decltype(__declval<const char32_t &(&)()>(0))    template<> auto declval<char32_t &>() noexcept -> decltype(__declval<char32_t &>(0))    template<> auto declval<const char32_t &&>() noexcept -> decltype(__declval<const char32_t &&>(0))    template<> auto declval<const char32_t *const>() noexcept -> decltype(__declval<const char32_t *const>(0))    template<> auto declval<std::allocator<char> &>() noexcept -> decltype(__declval<std::allocator<char> &>(0))    template<> auto declval<std::allocator<wchar_t> &>() noexcept -> decltype(__declval<std::allocator<wchar_t> &>(0))    template<> auto declval<std::allocator<char8_t> &>() noexcept -> decltype(__declval<std::allocator<char8_t> &>(0))    template<> auto declval<std::allocator<char16_t> &>() noexcept -> decltype(__declval<std::allocator<char16_t> &>(0))    template<> auto declval<std::allocator<char32_t> &>() noexcept -> decltype(__declval<std::allocator<char32_t> &>(0))    template<> auto declval<const std::error_category *const &(&)()>() noexcept -> decltype(__declval<const std::error_category *const &(&)()>(0))    template<> auto declval<const std::error_category *const &>() noexcept -> decltype(__declval<const std::error_category *const &>(0))    template<> auto declval<const std::error_category *>() noexcept -> decltype(__declval<const std::error_category *>(0))    template<> auto declval<std::_Bit_iterator>() noexcept -> decltype(__declval<std::_Bit_iterator>(0))    template<> auto declval<const std::_Bit_iterator &(&)()>() noexcept -> decltype(__declval<const std::_Bit_iterator &(&)()>(0))    template<> auto declval<const std::_Bit_iterator &>() noexcept -> decltype(__declval<const std::_Bit_iterator &>(0))    template<> auto declval<std::_Bit_iterator &>() noexcept -> decltype(__declval<std::_Bit_iterator &>(0))    template<> auto declval<const bool &(&)()>() noexcept -> decltype(__declval<const bool &(&)()>(0))    template<> auto declval<const std::_Bit_reference &(&)()>() noexcept -> decltype(__declval<const std::_Bit_reference &(&)()>(0))    template<> auto declval<std::_Bit_reference &&(&)()>() noexcept -> decltype(__declval<std::_Bit_reference &&(&)()>(0))    template<> auto declval<bool &(&)()>() noexcept -> decltype(__declval<bool &(&)()>(0))    template<> auto declval<std::_Bit_reference &&>() noexcept -> decltype(__declval<std::_Bit_reference &&>(0))    template<> auto declval<bool &>() noexcept -> decltype(__declval<bool &>(0))    template<> auto declval<std::_Bit_reference &(&)()>() noexcept -> decltype(__declval<std::_Bit_reference &(&)()>(0))    template<> auto declval<const bool &>() noexcept -> decltype(__declval<const bool &>(0))    template<> auto declval<const std::_Bit_iterator>() noexcept -> decltype(__declval<const std::_Bit_iterator>(0))    template<> auto declval<std::_Bit_const_iterator>() noexcept -> decltype(__declval<std::_Bit_const_iterator>(0))    template<> auto declval<const std::_Bit_const_iterator &(&)()>() noexcept -> decltype(__declval<const std::_Bit_const_iterator &(&)()>(0))    template<> auto declval<const std::_Bit_const_iterator &>() noexcept -> decltype(__declval<const std::_Bit_const_iterator &>(0))    template<> auto declval<std::_Bit_const_iterator &>() noexcept -> decltype(__declval<std::_Bit_const_iterator &>(0))    template<> auto declval<bool &&>() noexcept -> decltype(__declval<bool &&>(0))    template<> auto declval<const std::_Bit_const_iterator>() noexcept -> decltype(__declval<const std::_Bit_const_iterator>(0))    template<> auto declval<const int &>() noexcept -> decltype(__declval<const int &>(0))    template<> auto declval<Base<ChildA, ChildB, ChildC> *const &>() noexcept -> decltype(__declval<Base<ChildA, ChildB, ChildC> *const &>(0))    template <typename _Signature> struct result_of;
    struct __invoke_memfun_ref {
    };
    struct __invoke_memfun_deref {
    };
    struct __invoke_memobj_ref {
    };
    struct __invoke_memobj_deref {
    };
    struct __invoke_other {
    };
    template <typename _Tp, typename _Tag> struct __result_of_success : __success_type<_Tp> {
        using __invoke_type = _Tag;
    };
    struct __result_of_memfun_ref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype((std::declval<_Tp1>() .* std::declval<_Fp>())(std::declval<_Args>()...)), __invoke_memfun_ref> _S_test(int);
        template <typename ...> static __failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_ref : private __result_of_memfun_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memfun_deref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype(((*std::declval<_Tp1>()) .* std::declval<_Fp>())(std::declval<_Args>()...)), __invoke_memfun_deref> _S_test(int);
        template <typename ...> static __failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_deref : private __result_of_memfun_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memobj_ref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype(std::declval<_Tp1>() .* std::declval<_Fp>()), __invoke_memobj_ref> _S_test(int);
        template <typename, typename> static __failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_ref : private __result_of_memobj_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    struct __result_of_memobj_deref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype((*std::declval<_Tp1>()) .* std::declval<_Fp>()), __invoke_memobj_deref> _S_test(int);
        template <typename, typename> static __failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_deref : private __result_of_memobj_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj;
    template <typename _Res, typename _Class, typename _Arg> struct __result_of_memobj<_Res _Class::*, _Arg> {
        typedef __remove_cvref_t<_Arg> _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename __conditional_t<__or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval>>::value, __result_of_memobj_ref<_MemPtr, _Arg>, __result_of_memobj_deref<_MemPtr, _Arg>>::type type;
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun;
    template <typename _Res, typename _Class, typename _Arg, typename ..._Args> struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
        typedef typename remove_reference<_Arg>::type _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename __conditional_t<is_base_of<_Class, _Argval>::value, __result_of_memfun_ref<_MemPtr, _Arg, _Args...>, __result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type type;
    };
    template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>> struct __inv_unwrap {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
        using type = _Up &;
    };
    template <bool, bool, typename _Functor, typename ..._ArgTypes> struct __result_of_impl {
        typedef __failure_type type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_impl<true, false, _MemPtr, _Arg> : public __result_of_memobj<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type> {
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...> : public __result_of_memfun<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type, _Args...> {
    };
    struct __result_of_other_impl {
        template <typename _Fn, typename ..._Args> static __result_of_success<decltype(std::declval<_Fn>()(std::declval<_Args>()...)), __invoke_other> _S_test(int);
        template <typename ...> static __failure_type _S_test(...);
    };
    template <typename _Functor, typename ..._ArgTypes> struct __result_of_impl<false, false, _Functor, _ArgTypes...> : private __result_of_other_impl {
        typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };
    template <typename _Functor, typename ..._ArgTypes> struct __invoke_result : public __result_of_impl<is_member_object_pointer<typename remove_reference<_Functor>::type>::value, is_member_function_pointer<typename remove_reference<_Functor>::type>::value, _Functor, _ArgTypes...>::type {
    };
    template <typename _Functor, typename ..._ArgTypes> struct __attribute__((deprecated("use 'std::invoke_result' instead"))) result_of<_Functor (_ArgTypes...)> : public __invoke_result<_Functor, _ArgTypes...> {
    };
    template <size_t _Len, size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
    template <size_t _Len, typename ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
    template <typename _Tp> using decay_t = typename decay<_Tp>::type;
    template <bool _Cond, typename _Tp = void> using enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;
    template <typename ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
    template <typename _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
    template <typename _Tp> using result_of_t = typename result_of<_Tp>::type;
    template <typename ...> using void_t = void;
    template <typename _Def, template <typename ...> class _Op, typename ..._Args> struct __detected_or {
        using type = _Def;
        using __is_detected = false_type;
    };
    template <typename _Def, template <typename ...> class _Op, typename ..._Args> struct __detected_or<_Def, _Op, _Args...> {
        using type = _Op<_Args...>;
        using __is_detected = true_type;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
    template <typename _Tp> struct __is_swappable;
    template <typename _Tp> struct __is_nothrow_swappable;
    template <typename> struct __is_tuple_like_impl : false_type {
    };
    template<> struct __is_tuple_like_impl<std::_Bit_iterator> : false_type {
    };
    template<> struct __is_tuple_like_impl<std::_Bit_const_iterator> : false_type {
    };
    template <typename _Tp> struct __is_tuple_like : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {
    };
    template<> struct __is_tuple_like<std::_Bit_iterator> : public __is_tuple_like_impl<__remove_cvref_t<_Bit_iterator>>::type {
    };
    template<> struct __is_tuple_like<std::_Bit_const_iterator> : public __is_tuple_like_impl<__remove_cvref_t<_Bit_const_iterator>>::type {
    };
    template <typename _Tp> inline constexpr _Require<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>> swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value);
    template <typename _Tp, size_t _Nm> inline constexpr __enable_if_t<__is_swappable<_Tp>::value> swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);
    namespace __swappable_details {
        using std::swap;
        struct __do_is_swappable_impl {
            template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> static true_type __test(int);
            template <typename> static false_type __test(...);
        };
        struct __do_is_nothrow_swappable_impl {
            template <typename _Tp> static __bool_constant<noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> __test(int);
            template <typename> static false_type __test(...);
        };
    }
    template <typename _Tp> struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_swappable : public __is_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct is_swappable : public __is_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool is_swappable_v = is_swappable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
    namespace __swappable_with_details {
        using std::swap;
        struct __do_is_swappable_with_impl {
            template <typename _Tp, typename _Up, typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())), typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))> static true_type __test(int);
            template <typename, typename> static false_type __test(...);
        };
        struct __do_is_nothrow_swappable_with_impl {
            template <typename _Tp, typename _Up> static __bool_constant<noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) && noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))> __test(int);
            template <typename, typename> static false_type __test(...);
        };
    }
    template <typename _Tp, typename _Up> struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct __is_nothrow_swappable_with_impl : public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "first template argument must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}), "second template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "first template argument must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}), "second template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
    template <typename _Result, typename _Ret, bool = is_void<_Ret>::value, typename = void> struct __is_invocable_impl : false_type {
        using __nothrow_conv = false_type;
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, true, __void_t<typename _Result::type>> : true_type {
        using __nothrow_conv = true_type;
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, false, __void_t<typename _Result::type>> {
    private:
        using _Res_t = typename _Result::type;
        static _Res_t _S_get() noexcept;
        template <typename _Tp> static void _S_conv(__type_identity_t<_Tp>) noexcept;
        template <typename _Tp, bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())), typename = decltype(_S_conv<_Tp>(_S_get())), bool _Dangle = false> static __bool_constant<_Nothrow && !_Dangle> _S_test(int);
        template <typename _Tp, bool = false> static false_type _S_test(...);
    public:
        using type = decltype(_S_test<_Ret, true>(1));
        using __nothrow_conv = decltype(_S_test<_Ret>(1));
    };
    template <typename _Fn, typename ..._ArgTypes> struct __is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
    };
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(__invoke_memfun_ref) {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept((std::declval<_Up>() .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(__invoke_memfun_deref) {
        return noexcept(((*std::declval<_Tp>()) .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(__invoke_memobj_ref) {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept(std::declval<_Up>() .* std::declval<_Fn>());
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(__invoke_memobj_deref) {
        return noexcept((*std::declval<_Tp>()) .* std::declval<_Fn>());
    }
    template <typename _Fn, typename ..._Args> constexpr bool __call_is_nt(__invoke_other) {
        return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }
    template <typename _Result, typename _Fn, typename ..._Args> struct __call_is_nothrow : __bool_constant<std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})> {
    };
    template <typename _Fn, typename ..._Args> using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;
    template <typename _Fn, typename ..._Args> struct __is_nothrow_invocable : __and_<__is_invocable<_Fn, _Args...>, __call_is_nothrow_<_Fn, _Args...>>::type {
    };
    struct __nonesuchbase {
    };
    struct __nonesuch : private __nonesuchbase {
        ~__nonesuch() = delete
        __nonesuch(const __nonesuch &) = delete
        void operator=(const __nonesuch &) = delete
    };
    template <typename _Functor, typename ..._ArgTypes> struct invoke_result : public __invoke_result<_Functor, _ArgTypes...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}), "_Functor must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...), "each argument type must be a complete class or an unbounded array");
    };
    template <typename _Fn, typename ..._Args> using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
    template <typename _Fn, typename ..._ArgTypes> struct is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}), "_Fn must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...), "each argument type must be a complete class or an unbounded array");
    };
    template <typename _Ret, typename _Fn, typename ..._ArgTypes> struct is_invocable_r : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}), "_Fn must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...), "each argument type must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}), "_Ret must be a complete class or an unbounded array");
    };
    template <typename _Fn, typename ..._ArgTypes> struct is_nothrow_invocable : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>, __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}), "_Fn must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...), "each argument type must be a complete class or an unbounded array");
    };
    template <typename _Result, typename _Ret> using __is_nt_invocable_impl = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;
    template <typename _Ret, typename _Fn, typename ..._ArgTypes> struct is_nothrow_invocable_r : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>, __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}), "_Fn must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...), "each argument type must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}), "_Ret must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool is_void_v = is_void<_Tp>::value;
    template <typename _Tp> constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_integral_v = is_integral<_Tp>::value;
    template <typename _Tp> constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
    template <typename _Tp> constexpr bool is_array_v = false;
    constexpr bool is_array_v = true;
    constexpr bool is_array_v = true;
    template <typename _Tp> constexpr bool is_pointer_v = is_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_lvalue_reference_v = false;
    constexpr bool is_lvalue_reference_v = true;
    template <typename _Tp> constexpr bool is_rvalue_reference_v = false;
    constexpr bool is_rvalue_reference_v = true;
    template <typename _Tp> constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_enum_v = __is_enum(_Tp);
    template <typename _Tp> constexpr bool is_union_v = __is_union(_Tp);
    template <typename _Tp> constexpr bool is_class_v = __is_class(_Tp);
    template <typename _Tp> constexpr bool is_function_v = is_function<_Tp>::value;
    template <typename _Tp> constexpr bool is_reference_v = false;
    constexpr bool is_reference_v = true;
    constexpr bool is_reference_v = true;
    template <typename _Tp> constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
    template <typename _Tp> constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
    template <typename _Tp> constexpr bool is_object_v = is_object<_Tp>::value;
    template <typename _Tp> constexpr bool is_scalar_v = is_scalar<_Tp>::value;
    template <typename _Tp> constexpr bool is_compound_v = is_compound<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_const_v = false;
    constexpr bool is_const_v = true;
    template <typename _Tp> constexpr bool is_volatile_v = false;
    constexpr bool is_volatile_v = true;
    template <typename _Tp> constexpr bool is_trivial_v = __is_trivial(_Tp);
    template <typename _Tp> constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
    template <typename _Tp> constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
    template <typename _Tp> constexpr bool is_pod_v = __is_pod(_Tp) __attribute__((deprecated("use 'is_standard_layout_v && is_trivial_v' instead")));
    template <typename _Tp> constexpr bool is_literal_type_v = __is_literal(_Tp) [[deprecated("")]];
    template <typename _Tp> constexpr bool is_empty_v = __is_empty(_Tp);
    template <typename _Tp> constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
    template <typename _Tp> constexpr bool is_abstract_v = __is_abstract(_Tp);
    template <typename _Tp> constexpr bool is_final_v = __is_final(_Tp);
    template <typename _Tp> constexpr bool is_signed_v = is_signed<_Tp>::value;
    template <typename _Tp> constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
    template <typename _Tp> constexpr bool is_default_constructible_v = __is_constructible(_Tp);
    template <typename _Tp> constexpr bool is_copy_constructible_v = __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
    template <typename _Tp> constexpr bool is_move_constructible_v = __is_constructible(_Tp, __add_rval_ref_t<_Tp>);
    template <typename _Tp, typename _Up> constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
    template <typename _Tp> constexpr bool is_copy_assignable_v = __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
    template <typename _Tp> constexpr bool is_move_assignable_v = __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);
    template <typename _Tp> constexpr bool is_destructible_v = is_destructible<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Tp, _Args...);
    template <typename _Tp> constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Tp);
    template <typename _Tp> constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
    template <typename _Tp> constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);
    template <typename _Tp, typename _Up> constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_Tp, _Up);
    template <typename _Tp> constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
    template <typename _Tp> constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);
    template <typename _Tp> constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Tp, _Args...);
    template <typename _Tp> constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Tp);
    template <typename _Tp> constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
    template <typename _Tp> constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_Tp, _Up);
    template <typename _Tp> constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
    template <typename _Tp> constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);
    template <typename _Tp> constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;
    template <typename _Tp> constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Tp);
    template <typename _Tp> constexpr size_t alignment_of_v = alignment_of<_Tp>::value;
    template <typename _Tp> constexpr size_t rank_v = 0;
    constexpr size_t rank_v = 1 + rank_v<_Tp>;
    constexpr size_t rank_v = 1 + rank_v<_Tp>;
    template <typename _Tp, unsigned int _Idx = 0> constexpr size_t extent_v = 0;
    constexpr size_t extent_v = _Size;
    constexpr size_t extent_v = extent_v<_Tp, _Idx - 1>;
    constexpr size_t extent_v = 0;
    constexpr size_t extent_v = extent_v<_Tp, _Idx - 1>;
    template <typename _Tp, typename _Up> constexpr bool is_same_v = __is_same(_Tp, _Up);
    template <typename _Base, typename _Derived> constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
    template <typename _From, typename _To> constexpr bool is_convertible_v = __is_convertible(_From, _To);
    template <typename _Fn, typename ..._Args> constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
    template <typename _Fn, typename ..._Args> constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename ..._Args> constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename ..._Args> constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Tp> struct has_unique_object_representations : bool_constant<__has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool has_unique_object_representations_v = has_unique_object_representations<_Tp>::value;
    template <typename _Tp> struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> {
    };
    template <typename _Tp> constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);
    template <typename _Tp> struct remove_cvref {
        using type = __remove_cvref(_Tp);
    };
    template<> struct remove_cvref<const char *> {
        using type = __remove_cvref(const char *);
    };
    template<> struct remove_cvref<const char &> {
        using type = __remove_cvref(const char &);
    };
    template<> struct remove_cvref<const wchar_t *> {
        using type = __remove_cvref(const wchar_t *);
    };
    template<> struct remove_cvref<const wchar_t &> {
        using type = __remove_cvref(const wchar_t &);
    };
    template<> struct remove_cvref<const char8_t *> {
        using type = __remove_cvref(const char8_t *);
    };
    template<> struct remove_cvref<const char8_t &> {
        using type = __remove_cvref(const char8_t &);
    };
    template<> struct remove_cvref<const char16_t *> {
        using type = __remove_cvref(const char16_t *);
    };
    template<> struct remove_cvref<const char16_t &> {
        using type = __remove_cvref(const char16_t &);
    };
    template<> struct remove_cvref<const char32_t *> {
        using type = __remove_cvref(const char32_t *);
    };
    template<> struct remove_cvref<const char32_t &> {
        using type = __remove_cvref(const char32_t &);
    };
    template<> struct remove_cvref<std::_Bit_iterator> {
        using type = __remove_cvref(std::_Bit_iterator);
    };
    template<> struct remove_cvref<std::_Bit_reference &&> {
        using type = __remove_cvref(std::_Bit_reference &&);
    };
    template<> struct remove_cvref<bool &> {
        using type = __remove_cvref(bool &);
    };
    template<> struct remove_cvref<const bool &> {
        using type = __remove_cvref(const bool &);
    };
    template<> struct remove_cvref<std::_Bit_const_iterator> {
        using type = __remove_cvref(std::_Bit_const_iterator);
    };
    template <typename _Tp> using remove_cvref_t = typename remove_cvref<_Tp>::type;
    template <typename _Tp> struct type_identity {
        using type = _Tp;
    };
    template <typename _Tp> using type_identity_t = typename type_identity<_Tp>::type;
    template <typename _Tp> struct unwrap_reference {
        using type = _Tp;
    };
    template <typename _Tp> struct unwrap_reference<reference_wrapper<_Tp>> {
        using type = _Tp &;
    };
    template <typename _Tp> using unwrap_reference_t = typename unwrap_reference<_Tp>::type;
    template <typename _Tp> struct unwrap_ref_decay {
        using type = unwrap_reference_t<decay_t<_Tp>>;
    };
    template <typename _Tp> using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
    template <typename _Tp> constexpr bool is_bounded_array_v = false;
    constexpr bool is_bounded_array_v = true;
    template <typename _Tp> constexpr bool is_unbounded_array_v = false;
    constexpr bool is_unbounded_array_v = true;
    template <typename _Tp> struct is_bounded_array : public bool_constant<is_bounded_array_v<_Tp>> {
    };
    template <typename _Tp> struct is_unbounded_array : public bool_constant<is_unbounded_array_v<_Tp>> {
    };
    inline constexpr bool is_constant_evaluated() noexcept {
        return __builtin_is_constant_evaluated();
    }
    template <typename _From, typename _To> using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;
    template <typename _Xp, typename _Yp> using __cond_res = decltype(false ? declval<_Xp (&)()>()() : declval<_Yp (&)()>()());
    template <typename _Ap, typename _Bp, typename = void> struct __common_ref_impl {
    };
    template<> struct __common_ref_impl<const char *const &, const char *const &, void> : enable_if<is_reference_v<__condres_cvref<const char *const, const char *const>>, __condres_cvref<const char *const, const char *const>> {
    };
    template<> struct __common_ref_impl<const char &, char &, void> : enable_if<is_reference_v<__condres_cvref<const char, char>>, __condres_cvref<const char, char>> {
    };
    template<> struct __common_ref_impl<char &, const char &, void> : enable_if<is_reference_v<__condres_cvref<char, const char>>, __condres_cvref<char, const char>> {
    };
    template<> struct __common_ref_impl<const char &, const char &&, void> : __common_ref_impl<const char &&, const char &> {
    };
    template<> struct __common_ref_impl<const char &&, const char &, void> {
        using type = __common_ref_D<const char, const char>;
    };
    template<> struct __common_ref_impl<const char &, const char &, void> : enable_if<is_reference_v<__condres_cvref<const char, const char>>, __condres_cvref<const char, const char>> {
    };
    template<> struct __common_ref_impl<const unsigned long &, const unsigned long &, void> : enable_if<is_reference_v<__condres_cvref<const unsigned long, const unsigned long>>, __condres_cvref<const unsigned long, const unsigned long>> {
    };
    template<> struct __common_ref_impl<const wchar_t *const &, const wchar_t *const &, void> : enable_if<is_reference_v<__condres_cvref<const wchar_t *const, const wchar_t *const>>, __condres_cvref<const wchar_t *const, const wchar_t *const>> {
    };
    template<> struct __common_ref_impl<const wchar_t &, wchar_t &, void> : enable_if<is_reference_v<__condres_cvref<const wchar_t, wchar_t>>, __condres_cvref<const wchar_t, wchar_t>> {
    };
    template<> struct __common_ref_impl<wchar_t &, const wchar_t &, void> : enable_if<is_reference_v<__condres_cvref<wchar_t, const wchar_t>>, __condres_cvref<wchar_t, const wchar_t>> {
    };
    template<> struct __common_ref_impl<const wchar_t &, const wchar_t &&, void> : __common_ref_impl<const wchar_t &&, const wchar_t &> {
    };
    template<> struct __common_ref_impl<const wchar_t &&, const wchar_t &, void> {
        using type = __common_ref_D<const wchar_t, const wchar_t>;
    };
    template<> struct __common_ref_impl<const wchar_t &, const wchar_t &, void> : enable_if<is_reference_v<__condres_cvref<const wchar_t, const wchar_t>>, __condres_cvref<const wchar_t, const wchar_t>> {
    };
    template<> struct __common_ref_impl<const char8_t *const &, const char8_t *const &, void> : enable_if<is_reference_v<__condres_cvref<const char8_t *const, const char8_t *const>>, __condres_cvref<const char8_t *const, const char8_t *const>> {
    };
    template<> struct __common_ref_impl<const char8_t &, char8_t &, void> : enable_if<is_reference_v<__condres_cvref<const char8_t, char8_t>>, __condres_cvref<const char8_t, char8_t>> {
    };
    template<> struct __common_ref_impl<char8_t &, const char8_t &, void> : enable_if<is_reference_v<__condres_cvref<char8_t, const char8_t>>, __condres_cvref<char8_t, const char8_t>> {
    };
    template<> struct __common_ref_impl<const char8_t &, const char8_t &&, void> : __common_ref_impl<const char8_t &&, const char8_t &> {
    };
    template<> struct __common_ref_impl<const char8_t &&, const char8_t &, void> {
        using type = __common_ref_D<const char8_t, const char8_t>;
    };
    template<> struct __common_ref_impl<const char8_t &, const char8_t &, void> : enable_if<is_reference_v<__condres_cvref<const char8_t, const char8_t>>, __condres_cvref<const char8_t, const char8_t>> {
    };
    template<> struct __common_ref_impl<const char16_t *const &, const char16_t *const &, void> : enable_if<is_reference_v<__condres_cvref<const char16_t *const, const char16_t *const>>, __condres_cvref<const char16_t *const, const char16_t *const>> {
    };
    template<> struct __common_ref_impl<const char16_t &, char16_t &, void> : enable_if<is_reference_v<__condres_cvref<const char16_t, char16_t>>, __condres_cvref<const char16_t, char16_t>> {
    };
    template<> struct __common_ref_impl<char16_t &, const char16_t &, void> : enable_if<is_reference_v<__condres_cvref<char16_t, const char16_t>>, __condres_cvref<char16_t, const char16_t>> {
    };
    template<> struct __common_ref_impl<const char16_t &, const char16_t &&, void> : __common_ref_impl<const char16_t &&, const char16_t &> {
    };
    template<> struct __common_ref_impl<const char16_t &&, const char16_t &, void> {
        using type = __common_ref_D<const char16_t, const char16_t>;
    };
    template<> struct __common_ref_impl<const char16_t &, const char16_t &, void> : enable_if<is_reference_v<__condres_cvref<const char16_t, const char16_t>>, __condres_cvref<const char16_t, const char16_t>> {
    };
    template<> struct __common_ref_impl<const char32_t *const &, const char32_t *const &, void> : enable_if<is_reference_v<__condres_cvref<const char32_t *const, const char32_t *const>>, __condres_cvref<const char32_t *const, const char32_t *const>> {
    };
    template<> struct __common_ref_impl<const char32_t &, char32_t &, void> : enable_if<is_reference_v<__condres_cvref<const char32_t, char32_t>>, __condres_cvref<const char32_t, char32_t>> {
    };
    template<> struct __common_ref_impl<char32_t &, const char32_t &, void> : enable_if<is_reference_v<__condres_cvref<char32_t, const char32_t>>, __condres_cvref<char32_t, const char32_t>> {
    };
    template<> struct __common_ref_impl<const char32_t &, const char32_t &&, void> : __common_ref_impl<const char32_t &&, const char32_t &> {
    };
    template<> struct __common_ref_impl<const char32_t &&, const char32_t &, void> {
        using type = __common_ref_D<const char32_t, const char32_t>;
    };
    template<> struct __common_ref_impl<const char32_t &, const char32_t &, void> : enable_if<is_reference_v<__condres_cvref<const char32_t, const char32_t>>, __condres_cvref<const char32_t, const char32_t>> {
    };
    template<> struct __common_ref_impl<const std::error_category *const &, const std::error_category *const &, void> : enable_if<is_reference_v<__condres_cvref<const error_category *const, const error_category *const>>, __condres_cvref<const error_category *const, const error_category *const>> {
    };
    template<> struct __common_ref_impl<const std::_Bit_iterator &, const std::_Bit_iterator &, void> : enable_if<is_reference_v<__condres_cvref<const _Bit_iterator, const _Bit_iterator>>, __condres_cvref<const _Bit_iterator, const _Bit_iterator>> {
    };
    template<> struct __common_ref_impl<std::_Bit_reference &&, bool &, void> {
    };
    template<> struct __common_ref_impl<const std::_Bit_reference &, bool &, void> : enable_if<is_reference_v<__condres_cvref<const _Bit_reference, bool>>, __condres_cvref<const _Bit_reference, bool>> {
    };
    template<> struct __common_ref_impl<bool &, std::_Bit_reference &&, void> : __common_ref_impl<_Bit_reference &&, bool &> {
    };
    template<> struct __common_ref_impl<std::_Bit_reference &&, std::_Bit_reference &&, void> {
        using type = __common_ref_C<_Bit_reference, _Bit_reference>;
    };
    template<> struct __common_ref_impl<std::_Bit_reference &, std::_Bit_reference &, void> : enable_if<is_reference_v<__condres_cvref<_Bit_reference, _Bit_reference>>, __condres_cvref<_Bit_reference, _Bit_reference>> {
    };
    template<> struct __common_ref_impl<std::_Bit_reference &&, const bool &, void> {
    };
    template<> struct __common_ref_impl<const std::_Bit_reference &, const bool &, void> : enable_if<is_reference_v<__condres_cvref<const _Bit_reference, const bool>>, __condres_cvref<const _Bit_reference, const bool>> {
    };
    template<> struct __common_ref_impl<const bool &, std::_Bit_reference &&, void> : __common_ref_impl<_Bit_reference &&, const bool &> {
    };
    template<> struct __common_ref_impl<const std::_Bit_const_iterator &, const std::_Bit_const_iterator &, void> : enable_if<is_reference_v<__condres_cvref<const _Bit_const_iterator, const _Bit_const_iterator>>, __condres_cvref<const _Bit_const_iterator, const _Bit_const_iterator>> {
    };
    template<> struct __common_ref_impl<bool &&, bool &, void> {
        using type = __common_ref_D<bool, bool>;
    };
    template<> struct __common_ref_impl<const bool &, bool &, void> : enable_if<is_reference_v<__condres_cvref<const bool, bool>>, __condres_cvref<const bool, bool>> {
    };
    template<> struct __common_ref_impl<bool &, bool &&, void> : __common_ref_impl<bool &&, bool &> {
    };
    template<> struct __common_ref_impl<bool &&, bool &&, void> {
        using type = __common_ref_C<bool, bool>;
    };
    template<> struct __common_ref_impl<bool &, bool &, void> : enable_if<is_reference_v<__condres_cvref<bool, bool>>, __condres_cvref<bool, bool>> {
    };
    template<> struct __common_ref_impl<bool &&, const bool &, void> {
        using type = __common_ref_D<bool, const bool>;
    };
    template<> struct __common_ref_impl<const bool &, const bool &, void> : enable_if<is_reference_v<__condres_cvref<const bool, const bool>>, __condres_cvref<const bool, const bool>> {
    };
    template<> struct __common_ref_impl<const bool &, bool &&, void> : __common_ref_impl<bool &&, const bool &> {
    };
    template <typename _Ap, typename _Bp> using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;
    template <typename _Xp, typename _Yp> using __condres_cvref = __cond_res<__copy_cv<_Xp, _Yp> &, __copy_cv<_Yp, _Xp> &>;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &, _Yp &, __void_t<__condres_cvref<_Xp, _Yp>>> : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>, __condres_cvref<_Xp, _Yp>> {
    };
    template <typename _Xp, typename _Yp> using __common_ref_C = remove_reference_t<__common_ref<_Xp &, _Yp &>> &&;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &&, _Yp &&, _Require<is_convertible<_Xp &&, __common_ref_C<_Xp, _Yp>>, is_convertible<_Yp &&, __common_ref_C<_Xp, _Yp>>>> {
        using type = __common_ref_C<_Xp, _Yp>;
    };
    template <typename _Xp, typename _Yp> using __common_ref_D = __common_ref<const _Xp &, _Yp &>;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &&, _Yp &, _Require<is_convertible<_Xp &&, __common_ref_D<_Xp, _Yp>>>> {
        using type = __common_ref_D<_Xp, _Yp>;
    };
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &, _Yp &&> : __common_ref_impl<_Yp &&, _Xp &> {
    };
    template <typename _Tp, typename _Up, template <typename> class _TQual, template <typename> class _UQual> struct basic_common_reference {
    };
    template<> struct basic_common_reference<std::_Bit_reference, bool, std::__xref<std::_Bit_reference &&>::__type, std::__xref<bool &>::__type> {
    };
    template<> struct basic_common_reference<bool, std::_Bit_reference, std::__xref<bool &>::__type, std::__xref<std::_Bit_reference &&>::__type> {
    };
    template<> struct basic_common_reference<std::_Bit_reference, bool, std::__xref<std::_Bit_reference &&>::__type, std::__xref<const bool &>::__type> {
    };
    template<> struct basic_common_reference<bool, std::_Bit_reference, std::__xref<const bool &>::__type, std::__xref<std::_Bit_reference &&>::__type> {
    };
    template <typename _Tp> struct __xref {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up>;
    };
    template<> struct __xref<std::_Bit_reference &&> {
        template <typename _Up> using __type = __copy_cv<_Bit_reference, _Up> &&;
    };
    template<> struct __xref<bool &> {
        template <typename _Up> using __type = __copy_cv<bool, _Up> &;
    };
    template<> struct __xref<const bool &> {
        template <typename _Up> using __type = __copy_cv<const bool, _Up> &;
    };
    template <typename _Tp> struct __xref<_Tp &> {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up> &;
    };
    template <typename _Tp> struct __xref<_Tp &&> {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up> &&;
    };
    template <typename _Tp1, typename _Tp2> using __basic_common_ref = typename basic_common_reference<remove_cvref_t<_Tp1>, remove_cvref_t<_Tp2>, template __type, template __type>::type;
    template <typename ..._Tp> struct common_reference
    template<> struct common_reference<<const char *const &, const char *const &>> : __common_reference_impl<const char *const &, const char *const &> {
    }
    template<> struct common_reference<<const char &, char &>> : __common_reference_impl<const char &, char &> {
    }
    template<> struct common_reference<<char &, const char &>> : __common_reference_impl<char &, const char &> {
    }
    template<> struct common_reference<<const char &, const char &&>> : __common_reference_impl<const char &, const char &&> {
    }
    template<> struct common_reference<<const char &&, const char &>> : __common_reference_impl<const char &&, const char &> {
    }
    template<> struct common_reference<<const unsigned long &, const unsigned long &>> : __common_reference_impl<const unsigned long &, const unsigned long &> {
    }
    template<> struct common_reference<<const wchar_t *const &, const wchar_t *const &>> : __common_reference_impl<const wchar_t *const &, const wchar_t *const &> {
    }
    template<> struct common_reference<<const wchar_t &, wchar_t &>> : __common_reference_impl<const wchar_t &, wchar_t &> {
    }
    template<> struct common_reference<<wchar_t &, const wchar_t &>> : __common_reference_impl<wchar_t &, const wchar_t &> {
    }
    template<> struct common_reference<<const wchar_t &, const wchar_t &&>> : __common_reference_impl<const wchar_t &, const wchar_t &&> {
    }
    template<> struct common_reference<<const wchar_t &&, const wchar_t &>> : __common_reference_impl<const wchar_t &&, const wchar_t &> {
    }
    template<> struct common_reference<<const char8_t *const &, const char8_t *const &>> : __common_reference_impl<const char8_t *const &, const char8_t *const &> {
    }
    template<> struct common_reference<<const char8_t &, char8_t &>> : __common_reference_impl<const char8_t &, char8_t &> {
    }
    template<> struct common_reference<<char8_t &, const char8_t &>> : __common_reference_impl<char8_t &, const char8_t &> {
    }
    template<> struct common_reference<<const char8_t &, const char8_t &&>> : __common_reference_impl<const char8_t &, const char8_t &&> {
    }
    template<> struct common_reference<<const char8_t &&, const char8_t &>> : __common_reference_impl<const char8_t &&, const char8_t &> {
    }
    template<> struct common_reference<<const char16_t *const &, const char16_t *const &>> : __common_reference_impl<const char16_t *const &, const char16_t *const &> {
    }
    template<> struct common_reference<<const char16_t &, char16_t &>> : __common_reference_impl<const char16_t &, char16_t &> {
    }
    template<> struct common_reference<<char16_t &, const char16_t &>> : __common_reference_impl<char16_t &, const char16_t &> {
    }
    template<> struct common_reference<<const char16_t &, const char16_t &&>> : __common_reference_impl<const char16_t &, const char16_t &&> {
    }
    template<> struct common_reference<<const char16_t &&, const char16_t &>> : __common_reference_impl<const char16_t &&, const char16_t &> {
    }
    template<> struct common_reference<<const char32_t *const &, const char32_t *const &>> : __common_reference_impl<const char32_t *const &, const char32_t *const &> {
    }
    template<> struct common_reference<<const char32_t &, char32_t &>> : __common_reference_impl<const char32_t &, char32_t &> {
    }
    template<> struct common_reference<<char32_t &, const char32_t &>> : __common_reference_impl<char32_t &, const char32_t &> {
    }
    template<> struct common_reference<<const char32_t &, const char32_t &&>> : __common_reference_impl<const char32_t &, const char32_t &&> {
    }
    template<> struct common_reference<<const char32_t &&, const char32_t &>> : __common_reference_impl<const char32_t &&, const char32_t &> {
    }
    template<> struct common_reference<<const std::error_category *const &, const std::error_category *const &>> : __common_reference_impl<const error_category *const &, const error_category *const &> {
    }
    template<> struct common_reference<<const std::_Bit_iterator &, const std::_Bit_iterator &>> : __common_reference_impl<const _Bit_iterator &, const _Bit_iterator &> {
    }
    template<> struct common_reference<<std::_Bit_reference &&, bool &>> : __common_reference_impl<_Bit_reference &&, bool &> {
    }
    template<> struct common_reference<<bool &, std::_Bit_reference &&>> : __common_reference_impl<bool &, _Bit_reference &&> {
    }
    template<> struct common_reference<<std::_Bit_reference &&, std::_Bit_reference &&>> : __common_reference_impl<_Bit_reference &&, _Bit_reference &&> {
    }
    template<> struct common_reference<<std::_Bit_reference &&, const bool &>> : __common_reference_impl<_Bit_reference &&, const bool &> {
    }
    template<> struct common_reference<<const bool &, std::_Bit_reference &&>> : __common_reference_impl<const bool &, _Bit_reference &&> {
    }
    template<> struct common_reference<<const std::_Bit_const_iterator &, const std::_Bit_const_iterator &>> : __common_reference_impl<const _Bit_const_iterator &, const _Bit_const_iterator &> {
    }
    template<> struct common_reference<<bool &&, bool &>> : __common_reference_impl<bool &&, bool &> {
    }
    template<> struct common_reference<<bool &, bool &&>> : __common_reference_impl<bool &, bool &&> {
    }
    template<> struct common_reference<<bool &&, bool &&>> : __common_reference_impl<bool &&, bool &&> {
    }
    template<> struct common_reference<<bool &&, const bool &>> : __common_reference_impl<bool &&, const bool &> {
    }
    template<> struct common_reference<<const bool &, bool &&>> : __common_reference_impl<const bool &, bool &&> {
    };
    template <typename ..._Tp> using common_reference_t = typename common_reference<_Tp...>::type;
    template<> struct common_reference<> {
    };
    template <typename _Tp0> struct common_reference<_Tp0> {
        using type = _Tp0;
    };
    template <typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void> struct __common_reference_impl : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1> {
    };
    template<> struct __common_reference_impl<const char *const &, const char *const &, 1, void> {
        using type = __common_ref<const char *const &, const char *const &>;
    };
    template<> struct __common_reference_impl<const char &, char &, 1, void> {
        using type = __common_ref<const char &, char &>;
    };
    template<> struct __common_reference_impl<char &, const char &, 1, void> {
        using type = __common_ref<char &, const char &>;
    };
    template<> struct __common_reference_impl<const char &, const char &&, 1, void> {
        using type = __common_ref<const char &, const char &&>;
    };
    template<> struct __common_reference_impl<const char &&, const char &, 1, void> {
        using type = __common_ref<const char &&, const char &>;
    };
    template<> struct __common_reference_impl<const unsigned long &, const unsigned long &, 1, void> {
        using type = __common_ref<const unsigned long &, const unsigned long &>;
    };
    template<> struct __common_reference_impl<const wchar_t *const &, const wchar_t *const &, 1, void> {
        using type = __common_ref<const wchar_t *const &, const wchar_t *const &>;
    };
    template<> struct __common_reference_impl<const wchar_t &, wchar_t &, 1, void> {
        using type = __common_ref<const wchar_t &, wchar_t &>;
    };
    template<> struct __common_reference_impl<wchar_t &, const wchar_t &, 1, void> {
        using type = __common_ref<wchar_t &, const wchar_t &>;
    };
    template<> struct __common_reference_impl<const wchar_t &, const wchar_t &&, 1, void> {
        using type = __common_ref<const wchar_t &, const wchar_t &&>;
    };
    template<> struct __common_reference_impl<const wchar_t &&, const wchar_t &, 1, void> {
        using type = __common_ref<const wchar_t &&, const wchar_t &>;
    };
    template<> struct __common_reference_impl<const char8_t *const &, const char8_t *const &, 1, void> {
        using type = __common_ref<const char8_t *const &, const char8_t *const &>;
    };
    template<> struct __common_reference_impl<const char8_t &, char8_t &, 1, void> {
        using type = __common_ref<const char8_t &, char8_t &>;
    };
    template<> struct __common_reference_impl<char8_t &, const char8_t &, 1, void> {
        using type = __common_ref<char8_t &, const char8_t &>;
    };
    template<> struct __common_reference_impl<const char8_t &, const char8_t &&, 1, void> {
        using type = __common_ref<const char8_t &, const char8_t &&>;
    };
    template<> struct __common_reference_impl<const char8_t &&, const char8_t &, 1, void> {
        using type = __common_ref<const char8_t &&, const char8_t &>;
    };
    template<> struct __common_reference_impl<const char16_t *const &, const char16_t *const &, 1, void> {
        using type = __common_ref<const char16_t *const &, const char16_t *const &>;
    };
    template<> struct __common_reference_impl<const char16_t &, char16_t &, 1, void> {
        using type = __common_ref<const char16_t &, char16_t &>;
    };
    template<> struct __common_reference_impl<char16_t &, const char16_t &, 1, void> {
        using type = __common_ref<char16_t &, const char16_t &>;
    };
    template<> struct __common_reference_impl<const char16_t &, const char16_t &&, 1, void> {
        using type = __common_ref<const char16_t &, const char16_t &&>;
    };
    template<> struct __common_reference_impl<const char16_t &&, const char16_t &, 1, void> {
        using type = __common_ref<const char16_t &&, const char16_t &>;
    };
    template<> struct __common_reference_impl<const char32_t *const &, const char32_t *const &, 1, void> {
        using type = __common_ref<const char32_t *const &, const char32_t *const &>;
    };
    template<> struct __common_reference_impl<const char32_t &, char32_t &, 1, void> {
        using type = __common_ref<const char32_t &, char32_t &>;
    };
    template<> struct __common_reference_impl<char32_t &, const char32_t &, 1, void> {
        using type = __common_ref<char32_t &, const char32_t &>;
    };
    template<> struct __common_reference_impl<const char32_t &, const char32_t &&, 1, void> {
        using type = __common_ref<const char32_t &, const char32_t &&>;
    };
    template<> struct __common_reference_impl<const char32_t &&, const char32_t &, 1, void> {
        using type = __common_ref<const char32_t &&, const char32_t &>;
    };
    template<> struct __common_reference_impl<const std::error_category *const &, const std::error_category *const &, 1, void> {
        using type = __common_ref<const error_category *const &, const error_category *const &>;
    };
    template<> struct __common_reference_impl<const std::_Bit_iterator &, const std::_Bit_iterator &, 1, void> {
        using type = __common_ref<const _Bit_iterator &, const _Bit_iterator &>;
    };
    template<> struct __common_reference_impl<std::_Bit_reference &&, bool &, 1, void> : __common_reference_impl<_Bit_reference &&, bool &, 1 + 1> {
    };
    template<> struct __common_reference_impl<std::_Bit_reference &&, bool &, 2, void> : __common_reference_impl<_Bit_reference &&, bool &, 2 + 1> {
    };
    template<> struct __common_reference_impl<std::_Bit_reference &&, bool &, 3, void> {
        using type = __cond_res<_Bit_reference &&, bool &>;
    };
    template<> struct __common_reference_impl<bool &, std::_Bit_reference &&, 1, void> : __common_reference_impl<bool &, _Bit_reference &&, 1 + 1> {
    };
    template<> struct __common_reference_impl<bool &, std::_Bit_reference &&, 2, void> : __common_reference_impl<bool &, _Bit_reference &&, 2 + 1> {
    };
    template<> struct __common_reference_impl<bool &, std::_Bit_reference &&, 3, void> {
        using type = __cond_res<bool &, _Bit_reference &&>;
    };
    template<> struct __common_reference_impl<std::_Bit_reference &&, std::_Bit_reference &&, 1, void> {
        using type = __common_ref<_Bit_reference &&, _Bit_reference &&>;
    };
    template<> struct __common_reference_impl<std::_Bit_reference &&, const bool &, 1, void> : __common_reference_impl<_Bit_reference &&, const bool &, 1 + 1> {
    };
    template<> struct __common_reference_impl<std::_Bit_reference &&, const bool &, 2, void> : __common_reference_impl<_Bit_reference &&, const bool &, 2 + 1> {
    };
    template<> struct __common_reference_impl<std::_Bit_reference &&, const bool &, 3, void> {
        using type = __cond_res<_Bit_reference &&, const bool &>;
    };
    template<> struct __common_reference_impl<const bool &, std::_Bit_reference &&, 1, void> : __common_reference_impl<const bool &, _Bit_reference &&, 1 + 1> {
    };
    template<> struct __common_reference_impl<const bool &, std::_Bit_reference &&, 2, void> : __common_reference_impl<const bool &, _Bit_reference &&, 2 + 1> {
    };
    template<> struct __common_reference_impl<const bool &, std::_Bit_reference &&, 3, void> {
        using type = __cond_res<const bool &, _Bit_reference &&>;
    };
    template<> struct __common_reference_impl<const std::_Bit_const_iterator &, const std::_Bit_const_iterator &, 1, void> {
        using type = __common_ref<const _Bit_const_iterator &, const _Bit_const_iterator &>;
    };
    template<> struct __common_reference_impl<bool &&, bool &, 1, void> {
        using type = __common_ref<bool &&, bool &>;
    };
    template<> struct __common_reference_impl<bool &, bool &&, 1, void> {
        using type = __common_ref<bool &, bool &&>;
    };
    template<> struct __common_reference_impl<bool &&, bool &&, 1, void> {
        using type = __common_ref<bool &&, bool &&>;
    };
    template<> struct __common_reference_impl<bool &&, const bool &, 1, void> {
        using type = __common_ref<bool &&, const bool &>;
    };
    template<> struct __common_reference_impl<const bool &, bool &&, 1, void> {
        using type = __common_ref<const bool &, bool &&>;
    };
    template <typename _Tp1, typename _Tp2> struct common_reference<_Tp1, _Tp2> : __common_reference_impl<_Tp1, _Tp2> {
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &, _Tp2 &, 1, void_t<__common_ref<_Tp1 &, _Tp2 &>>> {
        using type = __common_ref<_Tp1 &, _Tp2 &>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &&, _Tp2 &&, 1, void_t<__common_ref<_Tp1 &&, _Tp2 &&>>> {
        using type = __common_ref<_Tp1 &&, _Tp2 &&>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &, _Tp2 &&, 1, void_t<__common_ref<_Tp1 &, _Tp2 &&>>> {
        using type = __common_ref<_Tp1 &, _Tp2 &&>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &&, _Tp2 &, 1, void_t<__common_ref<_Tp1 &&, _Tp2 &>>> {
        using type = __common_ref<_Tp1 &&, _Tp2 &>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 2, void_t<__basic_common_ref<_Tp1, _Tp2>>> {
        using type = __basic_common_ref<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 3, void_t<__cond_res<_Tp1, _Tp2>>> {
        using type = __cond_res<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 4, void_t<common_type_t<_Tp1, _Tp2>>> {
        using type = common_type_t<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 5, void> {
    };
    template <typename _Tp1, typename _Tp2, typename ..._Rest> struct common_reference<_Tp1, _Tp2, _Rest...> : __common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>> {
    };
    template <typename _Tp1, typename _Tp2, typename ..._Rest> struct __common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>, void_t<common_reference_t<_Tp1, _Tp2>>> : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...> {
    };
    constexpr bool is_floating_point_v = is_floating_point<double>::value;
    constexpr bool is_integral_v = is_integral<__max_size_type>::value;
    constexpr bool is_same_v = __is_same(std::ranges::__detail::__max_size_type, __int128);
    constexpr bool is_same_v = __is_same(std::ranges::__detail::__max_size_type, unsigned __int128);
    constexpr bool is_integral_v = is_integral<int>::value;
    constexpr bool is_integral_v = is_integral<unsigned __int128>::value;
    constexpr bool is_same_v = __is_same(unsigned __int128, __int128);
    constexpr bool is_same_v = __is_same(unsigned __int128, unsigned __int128);
    constexpr bool is_integral_v = is_integral<unsigned long>::value;
    constexpr bool is_integral_v = is_integral<__max_diff_type>::value;
    constexpr bool is_same_v = __is_same(std::ranges::__detail::__max_diff_type, __int128);
    constexpr bool is_same_v = __is_same(std::ranges::__detail::__max_diff_type, unsigned __int128);
    constexpr bool is_array_v = false;
    constexpr bool is_trivial_v = __is_trivial(char);
    constexpr bool is_standard_layout_v = __is_standard_layout(char);
    constexpr bool is_same_v = __is_same(char, char);
    constexpr bool is_array_v = false;
    constexpr bool is_trivial_v = __is_trivial(wchar_t);
    constexpr bool is_standard_layout_v = __is_standard_layout(wchar_t);
    constexpr bool is_same_v = __is_same(wchar_t, wchar_t);
    constexpr bool is_array_v = false;
    constexpr bool is_trivial_v = __is_trivial(char8_t);
    constexpr bool is_standard_layout_v = __is_standard_layout(char8_t);
    constexpr bool is_same_v = __is_same(char8_t, char8_t);
    constexpr bool is_array_v = false;
    constexpr bool is_trivial_v = __is_trivial(char16_t);
    constexpr bool is_standard_layout_v = __is_standard_layout(char16_t);
    constexpr bool is_same_v = __is_same(char16_t, char16_t);
    constexpr bool is_array_v = false;
    constexpr bool is_trivial_v = __is_trivial(char32_t);
    constexpr bool is_standard_layout_v = __is_standard_layout(char32_t);
    constexpr bool is_same_v = __is_same(char32_t, char32_t);
    constexpr bool is_object_v = is_object<const char *>::value;
    constexpr bool is_constructible_v = __is_constructible(const char *, const char *);
    constexpr bool is_convertible_v = __is_convertible(const char *, const char *);
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const char *const &, const char *const &);
    constexpr bool is_convertible_v = __is_convertible(const char *const &, const char *const &);
    constexpr bool is_same_v = __is_same(const char *&, const char *&);
    constexpr bool is_class_v = __is_class(const char *);
    constexpr bool is_union_v = __is_union(const char *);
    constexpr bool is_enum_v = __is_enum(const char *);
    constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(const char *, __add_rval_ref_t<const char *>);
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<const char *>, __add_rval_ref_t<const char *>);
    constexpr bool is_object_v = is_object<const char>::value;
    constexpr bool is_integral_v = is_integral<long>::value;
    constexpr bool is_signed_v = is_signed<long>::value;
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_same_v = __is_same(const char &, const char &);
    constexpr bool is_class_v = __is_class(const char *const);
    constexpr bool is_union_v = __is_union(const char *const);
    constexpr bool is_enum_v = __is_enum(const char *const);
    constexpr bool is_same_v = __is_same(const char &&, const char &&);
    constexpr bool is_reference_v = true;
    constexpr bool is_convertible_v = __is_convertible(const char &, const char &);
    constexpr bool is_convertible_v = __is_convertible(char &, const char &);
    constexpr bool is_convertible_v = __is_convertible(const char &&, const char &);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *);
    constexpr bool is_constructible_v = __is_constructible(const char *, const char *&);
    constexpr bool is_convertible_v = __is_convertible(const char *&, const char *);
    constexpr bool is_constructible_v = __is_constructible(const char *, const char *const &);
    constexpr bool is_convertible_v = __is_convertible(const char *const &, const char *);
    constexpr bool is_constructible_v = __is_constructible(const char *, const char *const);
    constexpr bool is_convertible_v = __is_convertible(const char *const, const char *);
    constexpr bool is_constructible_v = __is_constructible(const char *);
    constexpr bool is_convertible_v = __is_convertible(bool, bool);
    constexpr bool is_same_v = __is_same(const char *, const char *);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *);
    constexpr bool is_same_v = __is_same(long, long);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *);
    constexpr bool is_constructible_v = __is_constructible(unsigned long, unsigned long);
    constexpr bool is_convertible_v = __is_convertible(unsigned long, unsigned long);
    constexpr bool is_constructible_v = __is_constructible(unsigned long, unsigned long &);
    constexpr bool is_convertible_v = __is_convertible(unsigned long &, unsigned long);
    constexpr bool is_constructible_v = __is_constructible(unsigned long, const unsigned long &);
    constexpr bool is_convertible_v = __is_convertible(const unsigned long &, unsigned long);
    constexpr bool is_constructible_v = __is_constructible(unsigned long, const unsigned long);
    constexpr bool is_convertible_v = __is_convertible(const unsigned long, unsigned long);
    constexpr bool is_object_v = is_object<unsigned long>::value;
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const unsigned long &, const unsigned long &);
    constexpr bool is_convertible_v = __is_convertible(const unsigned long &, const unsigned long &);
    constexpr bool is_same_v = __is_same(unsigned long &, unsigned long &);
    constexpr bool is_class_v = __is_class(unsigned long);
    constexpr bool is_union_v = __is_union(unsigned long);
    constexpr bool is_enum_v = __is_enum(unsigned long);
    constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(unsigned long, __add_rval_ref_t<unsigned long>);
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<unsigned long>, __add_rval_ref_t<unsigned long>);
    constexpr bool is_constructible_v = __is_constructible(unsigned long);
    constexpr bool is_object_v = is_object<const wchar_t *>::value;
    constexpr bool is_constructible_v = __is_constructible(const wchar_t *, const wchar_t *);
    constexpr bool is_convertible_v = __is_convertible(const wchar_t *, const wchar_t *);
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const wchar_t *const &, const wchar_t *const &);
    constexpr bool is_convertible_v = __is_convertible(const wchar_t *const &, const wchar_t *const &);
    constexpr bool is_same_v = __is_same(const wchar_t *&, const wchar_t *&);
    constexpr bool is_class_v = __is_class(const wchar_t *);
    constexpr bool is_union_v = __is_union(const wchar_t *);
    constexpr bool is_enum_v = __is_enum(const wchar_t *);
    constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(const wchar_t *, __add_rval_ref_t<const wchar_t *>);
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<const wchar_t *>, __add_rval_ref_t<const wchar_t *>);
    constexpr bool is_object_v = is_object<const wchar_t>::value;
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_same_v = __is_same(const wchar_t &, const wchar_t &);
    constexpr bool is_class_v = __is_class(const wchar_t *const);
    constexpr bool is_union_v = __is_union(const wchar_t *const);
    constexpr bool is_enum_v = __is_enum(const wchar_t *const);
    constexpr bool is_same_v = __is_same(const wchar_t &&, const wchar_t &&);
    constexpr bool is_reference_v = true;
    constexpr bool is_convertible_v = __is_convertible(const wchar_t &, const wchar_t &);
    constexpr bool is_convertible_v = __is_convertible(wchar_t &, const wchar_t &);
    constexpr bool is_convertible_v = __is_convertible(const wchar_t &&, const wchar_t &);
    constexpr bool is_constructible_v = __is_constructible(const wchar_t *, const wchar_t *&);
    constexpr bool is_convertible_v = __is_convertible(const wchar_t *&, const wchar_t *);
    constexpr bool is_constructible_v = __is_constructible(const wchar_t *, const wchar_t *const &);
    constexpr bool is_convertible_v = __is_convertible(const wchar_t *const &, const wchar_t *);
    constexpr bool is_constructible_v = __is_constructible(const wchar_t *, const wchar_t *const);
    constexpr bool is_convertible_v = __is_convertible(const wchar_t *const, const wchar_t *);
    constexpr bool is_constructible_v = __is_constructible(const wchar_t *);
    constexpr bool is_same_v = __is_same(const wchar_t *, const wchar_t *);
    constexpr bool is_object_v = is_object<const char8_t *>::value;
    constexpr bool is_constructible_v = __is_constructible(const char8_t *, const char8_t *);
    constexpr bool is_convertible_v = __is_convertible(const char8_t *, const char8_t *);
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const char8_t *const &, const char8_t *const &);
    constexpr bool is_convertible_v = __is_convertible(const char8_t *const &, const char8_t *const &);
    constexpr bool is_same_v = __is_same(const char8_t *&, const char8_t *&);
    constexpr bool is_class_v = __is_class(const char8_t *);
    constexpr bool is_union_v = __is_union(const char8_t *);
    constexpr bool is_enum_v = __is_enum(const char8_t *);
    constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(const char8_t *, __add_rval_ref_t<const char8_t *>);
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<const char8_t *>, __add_rval_ref_t<const char8_t *>);
    constexpr bool is_object_v = is_object<const char8_t>::value;
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_same_v = __is_same(const char8_t &, const char8_t &);
    constexpr bool is_class_v = __is_class(const char8_t *const);
    constexpr bool is_union_v = __is_union(const char8_t *const);
    constexpr bool is_enum_v = __is_enum(const char8_t *const);
    constexpr bool is_same_v = __is_same(const char8_t &&, const char8_t &&);
    constexpr bool is_reference_v = true;
    constexpr bool is_convertible_v = __is_convertible(const char8_t &, const char8_t &);
    constexpr bool is_convertible_v = __is_convertible(char8_t &, const char8_t &);
    constexpr bool is_convertible_v = __is_convertible(const char8_t &&, const char8_t &);
    constexpr bool is_constructible_v = __is_constructible(const char8_t *, const char8_t *&);
    constexpr bool is_convertible_v = __is_convertible(const char8_t *&, const char8_t *);
    constexpr bool is_constructible_v = __is_constructible(const char8_t *, const char8_t *const &);
    constexpr bool is_convertible_v = __is_convertible(const char8_t *const &, const char8_t *);
    constexpr bool is_constructible_v = __is_constructible(const char8_t *, const char8_t *const);
    constexpr bool is_convertible_v = __is_convertible(const char8_t *const, const char8_t *);
    constexpr bool is_constructible_v = __is_constructible(const char8_t *);
    constexpr bool is_same_v = __is_same(const char8_t *, const char8_t *);
    constexpr bool is_object_v = is_object<const char16_t *>::value;
    constexpr bool is_constructible_v = __is_constructible(const char16_t *, const char16_t *);
    constexpr bool is_convertible_v = __is_convertible(const char16_t *, const char16_t *);
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const char16_t *const &, const char16_t *const &);
    constexpr bool is_convertible_v = __is_convertible(const char16_t *const &, const char16_t *const &);
    constexpr bool is_same_v = __is_same(const char16_t *&, const char16_t *&);
    constexpr bool is_class_v = __is_class(const char16_t *);
    constexpr bool is_union_v = __is_union(const char16_t *);
    constexpr bool is_enum_v = __is_enum(const char16_t *);
    constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(const char16_t *, __add_rval_ref_t<const char16_t *>);
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<const char16_t *>, __add_rval_ref_t<const char16_t *>);
    constexpr bool is_object_v = is_object<const char16_t>::value;
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_same_v = __is_same(const char16_t &, const char16_t &);
    constexpr bool is_class_v = __is_class(const char16_t *const);
    constexpr bool is_union_v = __is_union(const char16_t *const);
    constexpr bool is_enum_v = __is_enum(const char16_t *const);
    constexpr bool is_same_v = __is_same(const char16_t &&, const char16_t &&);
    constexpr bool is_reference_v = true;
    constexpr bool is_convertible_v = __is_convertible(const char16_t &, const char16_t &);
    constexpr bool is_convertible_v = __is_convertible(char16_t &, const char16_t &);
    constexpr bool is_convertible_v = __is_convertible(const char16_t &&, const char16_t &);
    constexpr bool is_constructible_v = __is_constructible(const char16_t *, const char16_t *&);
    constexpr bool is_convertible_v = __is_convertible(const char16_t *&, const char16_t *);
    constexpr bool is_constructible_v = __is_constructible(const char16_t *, const char16_t *const &);
    constexpr bool is_convertible_v = __is_convertible(const char16_t *const &, const char16_t *);
    constexpr bool is_constructible_v = __is_constructible(const char16_t *, const char16_t *const);
    constexpr bool is_convertible_v = __is_convertible(const char16_t *const, const char16_t *);
    constexpr bool is_constructible_v = __is_constructible(const char16_t *);
    constexpr bool is_same_v = __is_same(const char16_t *, const char16_t *);
    constexpr bool is_object_v = is_object<const char32_t *>::value;
    constexpr bool is_constructible_v = __is_constructible(const char32_t *, const char32_t *);
    constexpr bool is_convertible_v = __is_convertible(const char32_t *, const char32_t *);
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const char32_t *const &, const char32_t *const &);
    constexpr bool is_convertible_v = __is_convertible(const char32_t *const &, const char32_t *const &);
    constexpr bool is_same_v = __is_same(const char32_t *&, const char32_t *&);
    constexpr bool is_class_v = __is_class(const char32_t *);
    constexpr bool is_union_v = __is_union(const char32_t *);
    constexpr bool is_enum_v = __is_enum(const char32_t *);
    constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(const char32_t *, __add_rval_ref_t<const char32_t *>);
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<const char32_t *>, __add_rval_ref_t<const char32_t *>);
    constexpr bool is_object_v = is_object<const char32_t>::value;
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_same_v = __is_same(const char32_t &, const char32_t &);
    constexpr bool is_class_v = __is_class(const char32_t *const);
    constexpr bool is_union_v = __is_union(const char32_t *const);
    constexpr bool is_enum_v = __is_enum(const char32_t *const);
    constexpr bool is_same_v = __is_same(const char32_t &&, const char32_t &&);
    constexpr bool is_reference_v = true;
    constexpr bool is_convertible_v = __is_convertible(const char32_t &, const char32_t &);
    constexpr bool is_convertible_v = __is_convertible(char32_t &, const char32_t &);
    constexpr bool is_convertible_v = __is_convertible(const char32_t &&, const char32_t &);
    constexpr bool is_constructible_v = __is_constructible(const char32_t *, const char32_t *&);
    constexpr bool is_convertible_v = __is_convertible(const char32_t *&, const char32_t *);
    constexpr bool is_constructible_v = __is_constructible(const char32_t *, const char32_t *const &);
    constexpr bool is_convertible_v = __is_convertible(const char32_t *const &, const char32_t *);
    constexpr bool is_constructible_v = __is_constructible(const char32_t *, const char32_t *const);
    constexpr bool is_convertible_v = __is_convertible(const char32_t *const, const char32_t *);
    constexpr bool is_constructible_v = __is_constructible(const char32_t *);
    constexpr bool is_same_v = __is_same(const char32_t *, const char32_t *);
    constexpr bool is_same_v = __is_same(std::partial_ordering, std::partial_ordering);
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const std::error_category *const &, const std::error_category *const &);
    constexpr bool is_convertible_v = __is_convertible(const std::error_category *const &, const std::error_category *const &);
    constexpr bool is_convertible_v = __is_convertible(const std::error_category *, const volatile void *);
    constexpr bool is_same_v = __is_same(std::char_traits<char>, std::char_traits<char>);
    constexpr bool is_object_v = is_object<_Bit_iterator>::value;
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_iterator, std::_Bit_iterator);
    constexpr bool is_convertible_v = __is_convertible(std::_Bit_iterator, std::_Bit_iterator);
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const std::_Bit_iterator &, const std::_Bit_iterator &);
    constexpr bool is_convertible_v = __is_convertible(const std::_Bit_iterator &, const std::_Bit_iterator &);
    constexpr bool is_same_v = __is_same(std::_Bit_iterator &, std::_Bit_iterator &);
    constexpr bool is_class_v = __is_class(std::_Bit_iterator);
    constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(std::_Bit_iterator, __add_rval_ref_t<_Bit_iterator>);
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<_Bit_iterator>, __add_rval_ref_t<_Bit_iterator>);
    constexpr bool is_array_v = false;
    constexpr bool is_object_v = is_object<bool>::value;
    constexpr bool is_lvalue_reference_v = false;
    constexpr bool is_same_v = __is_same(std::_Bit_reference, std::_Bit_reference);
    constexpr bool is_class_v = __is_class(const std::_Bit_iterator);
    constexpr bool is_reference_v = false;
    constexpr bool is_same_v = __is_same(bool, bool);
    constexpr bool is_convertible_v = __is_convertible(std::_Bit_reference &&, bool);
    constexpr bool is_convertible_v = __is_convertible(bool &, bool);
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(std::_Bit_reference &&, std::_Bit_reference &&);
    constexpr bool is_convertible_v = __is_convertible(std::_Bit_reference &&, std::_Bit_reference &&);
    constexpr bool is_convertible_v = __is_convertible(const bool &, bool);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::random_access_iterator_tag *, const volatile std::input_iterator_tag *);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::random_access_iterator_tag *, const volatile std::forward_iterator_tag *);
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_iterator, std::_Bit_iterator &);
    constexpr bool is_convertible_v = __is_convertible(std::_Bit_iterator &, std::_Bit_iterator);
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_iterator, const std::_Bit_iterator &);
    constexpr bool is_convertible_v = __is_convertible(const std::_Bit_iterator &, std::_Bit_iterator);
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_iterator, const std::_Bit_iterator);
    constexpr bool is_convertible_v = __is_convertible(const std::_Bit_iterator, std::_Bit_iterator);
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_iterator);
    constexpr bool is_same_v = __is_same(std::_Bit_iterator, std::_Bit_iterator);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::random_access_iterator_tag *, const volatile std::bidirectional_iterator_tag *);
    constexpr bool is_convertible_v = __is_convertible(const volatile std::random_access_iterator_tag *, const volatile std::random_access_iterator_tag *);
    constexpr bool is_object_v = is_object<_Bit_const_iterator>::value;
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_const_iterator, std::_Bit_const_iterator);
    constexpr bool is_convertible_v = __is_convertible(std::_Bit_const_iterator, std::_Bit_const_iterator);
    constexpr bool is_lvalue_reference_v = true;
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const std::_Bit_const_iterator &, const std::_Bit_const_iterator &);
    constexpr bool is_convertible_v = __is_convertible(const std::_Bit_const_iterator &, const std::_Bit_const_iterator &);
    constexpr bool is_same_v = __is_same(std::_Bit_const_iterator &, std::_Bit_const_iterator &);
    constexpr bool is_class_v = __is_class(std::_Bit_const_iterator);
    constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(std::_Bit_const_iterator, __add_rval_ref_t<_Bit_const_iterator>);
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<_Bit_const_iterator>, __add_rval_ref_t<_Bit_const_iterator>);
    constexpr bool is_array_v = false;
    constexpr bool is_lvalue_reference_v = false;
    constexpr bool is_class_v = __is_class(const std::_Bit_const_iterator);
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(const bool &, const bool &);
    constexpr bool is_convertible_v = __is_convertible(bool &&, const bool &);
    constexpr bool is_convertible_v = __is_convertible(bool &, const bool &);
    constexpr bool is_reference_v = true;
    constexpr bool is_same_v = __is_same(bool &&, bool &&);
    constexpr bool is_convertible_v = __is_convertible(bool &&, bool &&);
    constexpr bool is_convertible_v = __is_convertible(const bool &, const bool &);
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_const_iterator, std::_Bit_const_iterator &);
    constexpr bool is_convertible_v = __is_convertible(std::_Bit_const_iterator &, std::_Bit_const_iterator);
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_const_iterator, const std::_Bit_const_iterator &);
    constexpr bool is_convertible_v = __is_convertible(const std::_Bit_const_iterator &, std::_Bit_const_iterator);
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_const_iterator, const std::_Bit_const_iterator);
    constexpr bool is_convertible_v = __is_convertible(const std::_Bit_const_iterator, std::_Bit_const_iterator);
    constexpr bool is_constructible_v = __is_constructible(std::_Bit_const_iterator);
    constexpr bool is_same_v = __is_same(std::_Bit_const_iterator, std::_Bit_const_iterator);
    constexpr bool is_object_v = is_object<const int>::value;
    constexpr bool is_object_v = is_object<int>::value;
    constexpr bool is_array_v = false;
    constexpr bool is_object_v = is_object<char>::value;
    constexpr bool is_class_v = __is_class(std::basic_ostream<char> &);
    constexpr bool is_object_v = is_object<Base<ChildA, ChildB, ChildC> *const>::value;
    constexpr bool is_object_v = is_object<Base<ChildA, ChildB, ChildC> *>::value;
    constexpr bool is_array_v = false;
    constexpr bool is_void_v = is_void<void>::value;
    constexpr bool is_void_v = is_void<float>::value;
    constexpr bool is_void_v = is_void<vector<int>>::value;
    constexpr bool is_object_v = is_object<wchar_t>::value;
    constexpr bool is_same_v = __is_same(std::char_traits<wchar_t>, std::char_traits<wchar_t>);
    constexpr bool is_same_v = __is_same(std::char_traits<char8_t>, std::char_traits<char8_t>);
    constexpr bool is_object_v = is_object<char8_t>::value;
    constexpr bool is_same_v = __is_same(std::char_traits<char16_t>, std::char_traits<char16_t>);
    constexpr bool is_object_v = is_object<char16_t>::value;
    constexpr bool is_same_v = __is_same(std::char_traits<char32_t>, std::char_traits<char32_t>);
    constexpr bool is_object_v = is_object<char32_t>::value;
    constexpr bool is_same_v = __is_same(void *, void *);
    constexpr bool is_same_v = __is_same(float *, void *);
    constexpr bool is_same_v = __is_same(std::vector<int> *, void *);
}
namespace std {
    template <typename _Tp> inline constexpr _Tp *__addressof(_Tp &__r) noexcept {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr int *__addressof<int>(int &__r) noexcept    template<> inline constexpr Base<ChildA, ChildB, ChildC> **__addressof<Base<ChildA, ChildB, ChildC> *>(Base<ChildA, ChildB, ChildC> *&__r) noexcept    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept [[nodiscard("")]] {
        return static_cast<_Tp &&>(__t);
    }
    template<> constexpr const char &forward<const char &>(typename std::remove_reference<const char &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr char &forward<char &>(typename std::remove_reference<char &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr const wchar_t &forward<const wchar_t &>(typename std::remove_reference<const wchar_t &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr wchar_t &forward<wchar_t &>(typename std::remove_reference<wchar_t &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr const char8_t &forward<const char8_t &>(typename std::remove_reference<const char8_t &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr char8_t &forward<char8_t &>(typename std::remove_reference<char8_t &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr const char16_t &forward<const char16_t &>(typename std::remove_reference<const char16_t &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr const char32_t &forward<const char32_t &>(typename std::remove_reference<const char32_t &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr const int &forward<const int &>(typename std::remove_reference<const int &>::type &__t) noexcept [[nodiscard("")]]    template<> constexpr Base<ChildA, ChildB, ChildC> *const &forward<Base<ChildA, ChildB, ChildC> *const &>(typename std::remove_reference<Base<ChildA, ChildB, ChildC> *const &>::type &__t) noexcept [[nodiscard("")]]    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &&__t) noexcept [[nodiscard("")]] {
        static_assert(!std::is_lvalue_reference<_Tp>::value, "std::forward must not be used to convert an rvalue to an lvalue");
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept [[nodiscard("")]] {
        return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char> &>::type &&move<std::allocator<char> &>(std::allocator<char> &__t) noexcept [[nodiscard("")]]    template<> constexpr typename std::remove_reference<basic_string<char> &>::type &&move<std::basic_string<char> &>(std::basic_string<char> &__t) noexcept [[nodiscard("")]]    template<> constexpr typename std::remove_reference<_Vector_impl &>::type &&move<std::_Vector_base<int, std::allocator<int>>::_Vector_impl &>(std::_Vector_base<int, std::allocator<int>>::_Vector_impl &__t) noexcept [[nodiscard("")]]    template<> constexpr typename std::remove_reference<vector<int> &>::type &&move<std::vector<int> &>(std::vector<int> &__t) noexcept [[nodiscard("")]]    template<> constexpr typename std::remove_reference<allocator<int> &>::type &&move<std::allocator<int> &>(std::allocator<int> &__t) noexcept [[nodiscard("")]]    template <typename _Tp> struct __move_if_noexcept_cond : public __and_<__not_<is_nothrow_move_constructible<_Tp>>, is_copy_constructible<_Tp>>::type {
    };
    template <typename _Tp> constexpr __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&> move_if_noexcept(_Tp &__x) noexcept [[nodiscard("")]] {
        return std::move(__x);
    }
    template <typename _Tp> inline constexpr _Tp *addressof(_Tp &__r) noexcept [[nodiscard("")]] {
        return std::__addressof(__r);
    }
    template<> inline constexpr char *addressof<char>(char &__r) noexcept [[nodiscard("")]]    template<> inline constexpr const char *addressof<const char>(const char &__r) noexcept [[nodiscard("")]]    template<> inline constexpr const wchar_t *addressof<const wchar_t>(const wchar_t &__r) noexcept [[nodiscard("")]]    template<> inline constexpr wchar_t *addressof<wchar_t>(wchar_t &__r) noexcept [[nodiscard("")]]    template<> inline constexpr char8_t *addressof<char8_t>(char8_t &__r) noexcept [[nodiscard("")]]    template<> inline constexpr const char8_t *addressof<const char8_t>(const char8_t &__r) noexcept [[nodiscard("")]]    template<> inline constexpr char16_t *addressof<char16_t>(char16_t &__r) noexcept [[nodiscard("")]]    template<> inline constexpr const char16_t *addressof<const char16_t>(const char16_t &__r) noexcept [[nodiscard("")]]    template<> inline constexpr char32_t *addressof<char32_t>(char32_t &__r) noexcept [[nodiscard("")]]    template<> inline constexpr const char32_t *addressof<const char32_t>(const char32_t &__r) noexcept [[nodiscard("")]]    template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete    template<> const char *addressof<char>(const char &&) = delete    template<> const wchar_t *addressof<wchar_t>(const wchar_t &&) = delete    template<> const char8_t *addressof<char8_t>(const char8_t &&) = delete    template<> const char16_t *addressof<char16_t>(const char16_t &&) = delete    template<> const char32_t *addressof<char32_t>(const char32_t &&) = delete
    template <typename _Tp, typename _Up = _Tp> inline constexpr _Tp __exchange(_Tp &__obj, _Up &&__new_val) {
        _Tp __old_val = std::move(__obj);
        __obj = std::forward<_Up>(__new_val);
        return __old_val;
    }
    template <typename _Tp> inline constexpr typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>>::value>::type swap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value) {
        _Tp __tmp = std::move(__a);
        __a = std::move(__b);
        __b = std::move(__tmp);
    }
    template<> inline constexpr typename enable_if<__and_<__not_<__is_tuple_like<_Bit_iterator>>, is_move_constructible<_Bit_iterator>, is_move_assignable<_Bit_iterator>>::value>::type swap<std::_Bit_iterator>(std::_Bit_iterator &__a, std::_Bit_iterator &__b)    template<> inline constexpr typename enable_if<__and_<__not_<__is_tuple_like<_Bit_const_iterator>>, is_move_constructible<_Bit_const_iterator>, is_move_assignable<_Bit_const_iterator>>::value>::type swap<std::_Bit_const_iterator>(std::_Bit_const_iterator &__a, std::_Bit_const_iterator &__b)    template <typename _Tp, size_t _Nm> inline constexpr typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value) {
        for (size_t __n = 0; __n < _Nm; ++__n)
            swap(__a[__n], __b[__n]);
    }
}
extern "C++" {
    namespace std {
        class type_info;
        namespace __exception_ptr {
            class exception_ptr;
        }
        using __exception_ptr::exception_ptr;
        exception_ptr current_exception() noexcept;
        template <typename _Ex> exception_ptr make_exception_ptr(_Ex) noexcept;
        void rethrow_exception(exception_ptr);
        namespace __exception_ptr {
            using std::rethrow_exception;
            class exception_ptr {
                void *_M_exception_object;
                explicit exception_ptr(void *__e) noexcept;
                void _M_addref() noexcept;
                void _M_release() noexcept;
                void *_M_get() const noexcept __attribute__((pure));
                friend exception_ptr std::current_exception() noexcept;
                friend void std::rethrow_exception(exception_ptr);
                friend template <typename _Ex> exception_ptr std::make_exception_ptr(_Ex) noexcept;
            public:
                exception_ptr() noexcept;
                exception_ptr(const exception_ptr &) noexcept;
                exception_ptr(nullptr_t) noexcept : _M_exception_object(nullptr) {
                }
                exception_ptr(exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object) {
                    __o._M_exception_object = nullptr;
                }
                exception_ptr &operator=(const exception_ptr &) noexcept;
                exception_ptr &operator=(exception_ptr &&__o) noexcept {
                    exception_ptr(static_cast<exception_ptr &&>(__o)).swap(*this);
                    return *this;
                }
                ~exception_ptr() noexcept;
                void swap(exception_ptr &) noexcept;
                explicit operator bool() const noexcept {
                    return this->_M_exception_object;
                }
                friend bool operator==(const exception_ptr &, const exception_ptr &) noexcept = default;
                const class std::type_info *__cxa_exception_type() const noexcept __attribute__((pure));
            };
            inline exception_ptr::exception_ptr() noexcept : _M_exception_object(0) {
            }
            inline exception_ptr::exception_ptr(const exception_ptr &__other) noexcept : _M_exception_object(__other._M_exception_object) {
                if (this->_M_exception_object)
                    this->_M_addref();
            }
            inline exception_ptr::~exception_ptr() noexcept {
                if (this->_M_exception_object)
                    this->_M_release();
            }
            inline exception_ptr &exception_ptr::operator=(const exception_ptr &__other) noexcept {
                exception_ptr(__other).swap(*this);
                return *this;
            }
            inline void exception_ptr::swap(exception_ptr &__other) noexcept {
                void *__tmp = this->_M_exception_object;
                this->_M_exception_object = __other._M_exception_object;
                __other._M_exception_object = __tmp;
            }
            inline void swap(exception_ptr &__lhs, exception_ptr &__rhs) {
                __lhs.swap(__rhs);
            }
            template <typename _Ex> inline void __dest_thunk(void *__x) {
                static_cast<_Ex *>(__x)->~_Ex();
            }
        }
        using __exception_ptr::swap;
        template <typename _Ex> exception_ptr make_exception_ptr(_Ex __ex) noexcept {
            using _Ex2 = typename decay<_Ex>::type;
            void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
            (void)__cxxabiv1::__cxa_init_primary_exception(__e, const_cast<std::type_info *>(&typeid(_Ex)), __exception_ptr::__dest_thunk<_Ex2>);
            try {
                ::new (__e) _Ex2(__ex);
                return exception_ptr(__e);
            } catch (...) {
                __cxxabiv1::__cxa_free_exception(__e);
                return current_exception();
            }
        }
    }
}
extern "C++" {
    namespace std {
        class nested_exception {
            exception_ptr _M_ptr;
        public:
            nested_exception() noexcept : _M_ptr(current_exception()) {
            }
            nested_exception(const nested_exception &) noexcept = default
            nested_exception &operator=(const nested_exception &) noexcept = default
            virtual ~nested_exception() noexcept;
            void rethrow_nested() const [[noreturn]] {
                if (this->_M_ptr)
                    rethrow_exception(this->_M_ptr);
                std::terminate();
            }
            exception_ptr nested_ptr() const noexcept {
                return this->_M_ptr;
            }
        };
        template <typename _Except> struct _Nested_exception : public _Except, public nested_exception {
            explicit _Nested_exception<_Except>(const _Except &__ex) : _Except(__ex) {
            }
            explicit _Nested_exception<_Except>(_Except &&__ex) : _Except(static_cast<_Except &&>(__ex)) {
            }
        };
        template <typename _Tp> inline void throw_with_nested(_Tp &&__t) [[noreturn]] {
            using _Up = typename decay<_Tp>::type;
            using _CopyConstructible = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
            static_assert(_CopyConstructible::value, "throw_with_nested argument must be CopyConstructible");
            if (is_class_v<_Up>)
                if (!is_final_v<_Up>)
                    if (!is_base_of_v<nested_exception, _Up>)
                        throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
            throw std::forward<_Tp>(__t);
        }
        template <typename _Ex> inline void rethrow_if_nested(const _Ex &__ex) {
            const _Ex *__ptr = __builtin_addressof(__ex);
            if (!is_polymorphic_v<_Ex>)
                return;
            else if (is_base_of_v<nested_exception, _Ex> && !is_convertible_v<_Ex *, nested_exception *>)
                return;
            else if (auto __ne_ptr = dynamic_cast<const nested_exception *>(__ptr))
                __ne_ptr->rethrow_nested();
        }
    }
}
namespace std {
    namespace __detail {
        template <typename _Tp, typename _Up> concept __same_as = std::is_same_v<_Tp, _Up>;
    }
    template <typename _Tp, typename _Up> concept same_as = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;
    template <typename _Derived, typename _Base> concept derived_from = __is_base_of(_Base, _Derived) && is_convertible_v<const volatile _Derived *, const volatile _Base *>;
    template <typename _From, typename _To> concept convertible_to = is_convertible_v<_From, _To> && requires { static_cast<_To>(std::declval<_From>()); };
    template <typename _Tp, typename _Up> concept common_reference_with = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>> && convertible_to<_Tp, common_reference_t<_Tp, _Up>> && convertible_to<_Up, common_reference_t<_Tp, _Up>>;
    template <typename _Tp, typename _Up> concept common_with = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>> && requires { static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>()); static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>()); } && common_reference_with<add_lvalue_reference_t<const _Tp>, add_lvalue_reference_t<const _Up>> && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>, common_reference_t<add_lvalue_reference_t<const _Tp>, add_lvalue_reference_t<const _Up>>>;
    template <typename _Tp> concept integral = is_integral_v<_Tp>;
    template <typename _Tp> concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;
    template <typename _Tp> concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;
    template <typename _Tp> concept floating_point = is_floating_point_v<_Tp>;
    namespace __detail {
        template <typename _Tp> using __cref = const remove_reference_t<_Tp> &;
        template <typename _Tp> concept __class_or_enum = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;
        template <typename _Tp> constexpr bool __destructible_impl = false;
        constexpr bool __destructible_impl = true;
        template <typename _Tp> constexpr bool __destructible = __destructible_impl<_Tp>;
        constexpr bool __destructible = true;
        constexpr bool __destructible = true;
        constexpr bool __destructible = __destructible<_Tp>;
        constexpr bool __destructible = __destructible_impl<const char *>;
        constexpr bool __destructible_impl = true;
        constexpr bool __destructible = __destructible_impl<unsigned long>;
        constexpr bool __destructible_impl = true;
        constexpr bool __destructible = __destructible_impl<const wchar_t *>;
        constexpr bool __destructible_impl = true;
        constexpr bool __destructible = __destructible_impl<const char8_t *>;
        constexpr bool __destructible_impl = true;
        constexpr bool __destructible = __destructible_impl<const char16_t *>;
        constexpr bool __destructible_impl = true;
        constexpr bool __destructible = __destructible_impl<const char32_t *>;
        constexpr bool __destructible_impl = true;
        constexpr bool __destructible = __destructible_impl<std::_Bit_iterator>;
        constexpr bool __destructible_impl = true;
        constexpr bool __destructible = __destructible_impl<std::_Bit_const_iterator>;
        constexpr bool __destructible_impl = true;
    }
    template <typename _Lhs, typename _Rhs> concept assignable_from = is_lvalue_reference_v<_Lhs> && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>> && requires (_Lhs __lhs, _Rhs &&__rhs) { { __lhs = static_cast<_Rhs &&>(__rhs) } -> same_as<_Lhs>; };
    template <typename _Tp> concept destructible = __detail::__destructible<_Tp>;
    template <typename _Tp, typename ..._Args> concept constructible_from = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;
    template <typename _Tp> concept default_initializable = constructible_from<_Tp> && requires { _Tp{}; (void)::new _Tp; };
    template <typename _Tp> concept move_constructible = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;
    template <typename _Tp> concept copy_constructible = move_constructible<_Tp> && constructible_from<_Tp, _Tp &> && convertible_to<_Tp &, _Tp> && constructible_from<_Tp, const _Tp &> && convertible_to<const _Tp &, _Tp> && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;
    namespace ranges {
        namespace __cust_swap {
            template <typename _Tp> void swap(_Tp &, _Tp &) = delete            template<> void swap<std::_Bit_iterator>(std::_Bit_iterator &, std::_Bit_iterator &) = delete            template<> void swap<std::_Bit_const_iterator>(std::_Bit_const_iterator &, std::_Bit_const_iterator &) = delete
            template <typename _Tp, typename _Up> concept __adl_swap = (__detail::__class_or_enum<remove_reference_t<_Tp>> || __detail::__class_or_enum<remove_reference_t<_Up>>) && requires (_Tp &&__t, _Up &&__u) { swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); };
            struct _Swap {
            private:
                template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
                    if (__adl_swap<_Tp, _Up>)
                        return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<_Tp>> && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
                }
                template<> static constexpr bool _S_noexcept<const char *&, const char *&>() {
                    if (__adl_swap<const char *&, const char *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char *&>>;
                }
                template<> static constexpr bool _S_noexcept<unsigned long &, unsigned long &>() {
                    if (__adl_swap<unsigned long &, unsigned long &>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<unsigned long &>> && is_nothrow_move_assignable_v<remove_reference_t<unsigned long &>>;
                }
                template<> static constexpr bool _S_noexcept<const wchar_t *&, const wchar_t *&>() {
                    if (__adl_swap<const wchar_t *&, const wchar_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const wchar_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const wchar_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char8_t *&, const char8_t *&>() {
                    if (__adl_swap<const char8_t *&, const char8_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char8_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char8_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char16_t *&, const char16_t *&>() {
                    if (__adl_swap<const char16_t *&, const char16_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char16_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char16_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char32_t *&, const char32_t *&>() {
                    if (__adl_swap<const char32_t *&, const char32_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char32_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char32_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<std::_Bit_iterator &, std::_Bit_iterator &>() {
                    if (__adl_swap<std::_Bit_iterator &, std::_Bit_iterator &>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<_Bit_iterator &>> && is_nothrow_move_assignable_v<remove_reference_t<_Bit_iterator &>>;
                }
                template<> static constexpr bool _S_noexcept<std::_Bit_const_iterator &, std::_Bit_const_iterator &>() {
                    if (__adl_swap<std::_Bit_const_iterator &, std::_Bit_const_iterator &>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<_Bit_const_iterator &>> && is_nothrow_move_assignable_v<remove_reference_t<_Bit_const_iterator &>>;
                }
            public:
                template <typename _Tp, typename _Up> constexpr void operator()(_Tp &&__t, _Up &&__u) const noexcept(_S_noexcept<_Tp, _Up>()) {
                    if (__adl_swap<_Tp, _Up>)
                        swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u));
                    else {
                        auto __tmp = static_cast<remove_reference_t<_Tp> &&>(__t);
                        __t = static_cast<remove_reference_t<_Tp> &&>(__u);
                        __u = static_cast<remove_reference_t<_Tp> &&>(__tmp);
                    }
                }
                template<> constexpr void operator()<const char *&, const char *&>(const char *&__t, const char *&__u) const noexcept(_S_noexcept<const char *&, const char *&>())                template<> constexpr void operator()<unsigned long &, unsigned long &>(unsigned long &__t, unsigned long &__u) const noexcept(_S_noexcept<unsigned long &, unsigned long &>())                template<> constexpr void operator()<const wchar_t *&, const wchar_t *&>(const wchar_t *&__t, const wchar_t *&__u) const noexcept(_S_noexcept<const wchar_t *&, const wchar_t *&>())                template<> constexpr void operator()<const char8_t *&, const char8_t *&>(const char8_t *&__t, const char8_t *&__u) const noexcept(_S_noexcept<const char8_t *&, const char8_t *&>())                template<> constexpr void operator()<const char16_t *&, const char16_t *&>(const char16_t *&__t, const char16_t *&__u) const noexcept(_S_noexcept<const char16_t *&, const char16_t *&>())                template<> constexpr void operator()<const char32_t *&, const char32_t *&>(const char32_t *&__t, const char32_t *&__u) const noexcept(_S_noexcept<const char32_t *&, const char32_t *&>())                template<> constexpr void operator()<std::_Bit_iterator &, std::_Bit_iterator &>(std::_Bit_iterator &__t, std::_Bit_iterator &__u) const noexcept(_S_noexcept<std::_Bit_iterator &, std::_Bit_iterator &>())                template<> constexpr void operator()<std::_Bit_const_iterator &, std::_Bit_const_iterator &>(std::_Bit_const_iterator &__t, std::_Bit_const_iterator &__u) const noexcept(_S_noexcept<std::_Bit_const_iterator &, std::_Bit_const_iterator &>())                template <typename _Tp, typename _Up, size_t _Num> constexpr void operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const noexcept(noexcept(std::declval<const _Swap &>()(*__e1, *__e2))) {
                    for (size_t __n = 0; __n < _Num; ++__n)
                        (*this)(__e1[__n], __e2[__n]);
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_swap::_Swap swap{};
        }
    }
    template <typename _Tp> concept swappable = requires (_Tp &__a, _Tp &__b) { ranges::swap(__a, __b); };
    template <typename _Tp, typename _Up> concept swappable_with = common_reference_with<_Tp, _Up> && requires (_Tp &&__t, _Up &&__u) { ranges::swap(static_cast<_Tp &&>(__t), static_cast<_Tp &&>(__t)); ranges::swap(static_cast<_Up &&>(__u), static_cast<_Up &&>(__u)); ranges::swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); ranges::swap(static_cast<_Up &&>(__u), static_cast<_Tp &&>(__t)); };
    template <typename _Tp> concept movable = is_object_v<_Tp> && move_constructible<_Tp> && assignable_from<_Tp &, _Tp> && swappable<_Tp>;
    template <typename _Tp> concept copyable = copy_constructible<_Tp> && movable<_Tp> && assignable_from<_Tp &, _Tp &> && assignable_from<_Tp &, const _Tp &> && assignable_from<_Tp &, const _Tp>;
    template <typename _Tp> concept semiregular = copyable<_Tp> && default_initializable<_Tp>;
    namespace __detail {
        template <typename _Tp> concept __boolean_testable_impl = convertible_to<_Tp, bool>;
        template <typename _Tp> concept __boolean_testable = __boolean_testable_impl<_Tp> && requires (_Tp &&__t) { { !static_cast<_Tp &&>(__t) } -> __boolean_testable_impl; };
    }
    namespace __detail {
        template <typename _Tp, typename _Up> concept __weakly_eq_cmp_with = requires (__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) { { __t == __u } -> __boolean_testable; { __t != __u } -> __boolean_testable; { __u == __t } -> __boolean_testable; { __u != __t } -> __boolean_testable; };
    }
    template <typename _Tp> concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;
    template <typename _Tp, typename _Up> concept equality_comparable_with = equality_comparable<_Tp> && equality_comparable<_Up> && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>> && equality_comparable<common_reference_t<__detail::__cref<_Tp>, __detail::__cref<_Up>>> && __detail::__weakly_eq_cmp_with<_Tp, _Up>;
    namespace __detail {
        template <typename _Tp, typename _Up> concept __partially_ordered_with = requires (const remove_reference_t<_Tp> &__t, const remove_reference_t<_Up> &__u) { { __t < __u } -> __boolean_testable; { __t > __u } -> __boolean_testable; { __t <= __u } -> __boolean_testable; { __t >= __u } -> __boolean_testable; { __u < __t } -> __boolean_testable; { __u > __t } -> __boolean_testable; { __u <= __t } -> __boolean_testable; { __u >= __t } -> __boolean_testable; };
    }
    template <typename _Tp> concept totally_ordered = equality_comparable<_Tp> && __detail::__partially_ordered_with<_Tp, _Tp>;
    template <typename _Tp, typename _Up> concept totally_ordered_with = totally_ordered<_Tp> && totally_ordered<_Up> && equality_comparable_with<_Tp, _Up> && totally_ordered<common_reference_t<__detail::__cref<_Tp>, __detail::__cref<_Up>>> && __detail::__partially_ordered_with<_Tp, _Up>;
    template <typename _Tp> concept regular = semiregular<_Tp> && equality_comparable<_Tp>;
    template <typename _Fn, typename ..._Args> concept invocable = is_invocable_v<_Fn, _Args...>;
    template <typename _Fn, typename ..._Args> concept regular_invocable = invocable<_Fn, _Args...>;
    template <typename _Fn, typename ..._Args> concept predicate = regular_invocable<_Fn, _Args...> && __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;
    template <typename _Rel, typename _Tp, typename _Up> concept relation = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up> && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;
    template <typename _Rel, typename _Tp, typename _Up> concept equivalence_relation = relation<_Rel, _Tp, _Up>;
    template <typename _Rel, typename _Tp, typename _Up> concept strict_weak_order = relation<_Rel, _Tp, _Up>;
}
namespace std {
    namespace __cmp_cat {
        using type = signed char;
        enum class _Ord : type {
            equivalent = 0,
            less = -1,
            greater = 1
        };
        enum class _Ncmp : type {
            _Unordered = 2
        };
        struct __unspec {
            constexpr __unspec(__unspec *) noexcept {
            }
        };
    }
    class partial_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit partial_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v)) {
        }
        constexpr explicit partial_ordering(__cmp_cat::_Ncmp __v) noexcept : _M_value(__cmp_cat::type(__v)) {
        }
        friend  class weak_ordering;
        friend  class strong_ordering;
    public:
        static const partial_ordering less;
        static const partial_ordering equivalent;
        static const partial_ordering greater;
        static const partial_ordering unordered;
        friend constexpr bool operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value == 0;
        }
;
        friend bool operator==(partial_ordering, partial_ordering) noexcept [[nodiscard("")]] = default;
        friend constexpr bool operator<(partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value == -1;
        }
;
        friend constexpr bool operator>(partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value == 1;
        }
;
        friend constexpr bool operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __cmp_cat::type(__v._M_value & 1) == __v._M_value;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, partial_ordering __v) noexcept [[nodiscard("")]] {
            return __v._M_value == 1;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, partial_ordering __v) noexcept [[nodiscard("")]] {
            return __v._M_value == -1;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept [[nodiscard("")]] {
            return __cmp_cat::type(__v._M_value & 1) == __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept [[nodiscard("")]] {
            return 0 >= __v._M_value;
        }
;
        friend constexpr partial_ordering operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v;
        }
;
        friend constexpr partial_ordering operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept [[nodiscard("")]] {
            if (__v._M_value & 1)
                return partial_ordering(__cmp_cat::_Ord(-__v._M_value));
            else
                return __v;
        }
;
    };
    constexpr partial_ordering less(__cmp_cat::_Ord::less);
    constexpr partial_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr partial_ordering greater(__cmp_cat::_Ord::greater);
    constexpr partial_ordering unordered(__cmp_cat::_Ncmp::_Unordered);
    class weak_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v)) {
        }
        friend  class strong_ordering;
    public:
        static const weak_ordering less;
        static const weak_ordering equivalent;
        static const weak_ordering greater;
        constexpr operator partial_ordering() const noexcept [[nodiscard("")]] {
            return partial_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        friend constexpr bool operator==(weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value == 0;
        }
;
        friend bool operator==(weak_ordering, weak_ordering) noexcept [[nodiscard("")]] = default;
        friend constexpr bool operator<(weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value < 0;
        }
;
        friend constexpr bool operator>(weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value > 0;
        }
;
        friend constexpr bool operator<=(weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value >= 0;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, weak_ordering __v) noexcept [[nodiscard("")]] {
            return 0 < __v._M_value;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, weak_ordering __v) noexcept [[nodiscard("")]] {
            return 0 > __v._M_value;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, weak_ordering __v) noexcept [[nodiscard("")]] {
            return 0 <= __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, weak_ordering __v) noexcept [[nodiscard("")]] {
            return 0 >= __v._M_value;
        }
;
        friend constexpr weak_ordering operator<=>(weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v;
        }
;
        friend constexpr weak_ordering operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept [[nodiscard("")]] {
            return weak_ordering(__cmp_cat::_Ord(-__v._M_value));
        }
;
    };
    constexpr weak_ordering less(__cmp_cat::_Ord::less);
    constexpr weak_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr weak_ordering greater(__cmp_cat::_Ord::greater);
    class strong_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit strong_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v)) {
        }
    public:
        static const strong_ordering less;
        static const strong_ordering equal;
        static const strong_ordering equivalent;
        static const strong_ordering greater;
        constexpr operator partial_ordering() const noexcept [[nodiscard("")]] {
            return partial_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        constexpr operator weak_ordering() const noexcept [[nodiscard("")]] {
            return weak_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        friend constexpr bool operator==(strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value == 0;
        }
;
        friend bool operator==(strong_ordering, strong_ordering) noexcept [[nodiscard("")]] = default;
        friend constexpr bool operator<(strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value < 0;
        }
;
        friend constexpr bool operator>(strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value > 0;
        }
;
        friend constexpr bool operator<=(strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v._M_value >= 0;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, strong_ordering __v) noexcept [[nodiscard("")]] {
            return 0 < __v._M_value;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, strong_ordering __v) noexcept [[nodiscard("")]] {
            return 0 > __v._M_value;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, strong_ordering __v) noexcept [[nodiscard("")]] {
            return 0 <= __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, strong_ordering __v) noexcept [[nodiscard("")]] {
            return 0 >= __v._M_value;
        }
;
        friend constexpr strong_ordering operator<=>(strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]] {
            return __v;
        }
;
        friend constexpr strong_ordering operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept [[nodiscard("")]] {
            return strong_ordering(__cmp_cat::_Ord(-__v._M_value));
        }
;
    };
    constexpr strong_ordering less(__cmp_cat::_Ord::less);
    constexpr strong_ordering equal(__cmp_cat::_Ord::equivalent);
    constexpr strong_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr strong_ordering greater(__cmp_cat::_Ord::greater);
    constexpr bool is_eq(partial_ordering __cmp) noexcept [[nodiscard("")]] {
        return __cmp == 0;
    }
    constexpr bool is_neq(partial_ordering __cmp) noexcept [[nodiscard("")]] {
        return __cmp != 0;
    }
    constexpr bool is_lt(partial_ordering __cmp) noexcept [[nodiscard("")]] {
        return __cmp < 0;
    }
    constexpr bool is_lteq(partial_ordering __cmp) noexcept [[nodiscard("")]] {
        return __cmp <= 0;
    }
    constexpr bool is_gt(partial_ordering __cmp) noexcept [[nodiscard("")]] {
        return __cmp > 0;
    }
    constexpr bool is_gteq(partial_ordering __cmp) noexcept [[nodiscard("")]] {
        return __cmp >= 0;
    }
    namespace __detail {
        template <typename _Tp> constexpr unsigned int __cmp_cat_id = 1;
        constexpr unsigned int __cmp_cat_id = 2;
        constexpr unsigned int __cmp_cat_id = 4;
        constexpr unsigned int __cmp_cat_id = 8;
        template <typename ..._Ts> constexpr auto __common_cmp_cat() {
            constexpr unsigned int __cats = (__cmp_cat_id<_Ts> | ...);
            if (__cats & 1)
                return;
            else if (bool(__cats & __cmp_cat_id<partial_ordering>))
                return partial_ordering::equivalent;
            else if (bool(__cats & __cmp_cat_id<weak_ordering>))
                return weak_ordering::equivalent;
            else
                return strong_ordering::equivalent;
        }
        template<> constexpr partial_ordering __common_cmp_cat<<std::strong_ordering, std::partial_ordering>>() {
            constexpr unsigned int __cats = __cmp_cat_id<std::strong_ordering> | __cmp_cat_id<std::partial_ordering>;
            if (__cats & 1)
                ;
            else if (bool(__cats & __cmp_cat_id<partial_ordering>))
                return partial_ordering::equivalent;
        }
    }
    template <typename ..._Ts> struct common_comparison_category {
        using type = decltype(__detail::__common_cmp_cat<_Ts...>());
    };
    template<> struct common_comparison_category<<std::strong_ordering, std::partial_ordering>> {
        using type = decltype(__detail::__common_cmp_cat<std::strong_ordering, std::partial_ordering>());
    };
    template <typename _Tp> struct common_comparison_category<_Tp> {
        using type = void;
    };
    template<> struct common_comparison_category<partial_ordering> {
        using type = partial_ordering;
    };
    template<> struct common_comparison_category<weak_ordering> {
        using type = weak_ordering;
    };
    template<> struct common_comparison_category<strong_ordering> {
        using type = strong_ordering;
    };
    template<> struct common_comparison_category<> {
        using type = strong_ordering;
    };
    template <typename ..._Ts> using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;
    namespace __detail {
        template <typename _Tp, typename _Cat> concept __compares_as = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;
    }
    template <typename _Tp, typename _Cat = partial_ordering> concept three_way_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp> && __detail::__partially_ordered_with<_Tp, _Tp> && requires (const remove_reference_t<_Tp> &__a, const remove_reference_t<_Tp> &__b) { { __a <=> __b } -> __detail::__compares_as<_Cat>; };
    template <typename _Tp, typename _Up, typename _Cat = partial_ordering> concept three_way_comparable_with = three_way_comparable<_Tp, _Cat> && three_way_comparable<_Up, _Cat> && common_reference_with<const remove_reference_t<_Tp> &, const remove_reference_t<_Up> &> && three_way_comparable<common_reference_t<const remove_reference_t<_Tp> &, const remove_reference_t<_Up> &>, _Cat> && __detail::__weakly_eq_cmp_with<_Tp, _Up> && __detail::__partially_ordered_with<_Tp, _Up> && requires (const remove_reference_t<_Tp> &__t, const remove_reference_t<_Up> &__u) { { __t <=> __u } -> __detail::__compares_as<_Cat>; { __u <=> __t } -> __detail::__compares_as<_Cat>; };
    namespace __detail {
        template <typename _Tp, typename _Up> using __cmp3way_res_t = decltype(std::declval<_Tp>() <=> std::declval<_Up>());
        template <typename _Tp, typename _Up> struct __cmp3way_res_impl {
        };
        template <typename _Tp, typename _Up> struct __cmp3way_res_impl<_Tp, _Up> {
            using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
        };
    }
    template <typename _Tp, typename _Up = _Tp> struct compare_three_way_result : __detail::__cmp3way_res_impl<_Tp, _Up> {
    };
    template <typename _Tp, typename _Up = _Tp> using compare_three_way_result_t = typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;
    namespace __detail {
        template <typename _Tp, typename _Up> concept __3way_builtin_ptr_cmp = requires (_Tp &&__t, _Up &&__u) { static_cast<_Tp &&>(__t) <=> static_cast<_Up &&>(__u); } && convertible_to<_Tp, const volatile void *> && convertible_to<_Up, const volatile void *> && !requires (_Tp &&__t, _Up &&__u) { operator<=>(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); } && !requires (_Tp &&__t, _Up &&__u) { static_cast<_Tp &&>(__t).operator<=>(static_cast<_Up &&>(__u)); };
    }
    struct compare_three_way {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>())) [[nodiscard("")]] {
            if (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>) {
                auto __pt = static_cast<const volatile void *>(__t);
                auto __pu = static_cast<const volatile void *>(__u);
                if (std::__is_constant_evaluated())
                    return __pt <=> __pu;
                auto __it = reinterpret_cast<unsigned long>(__pt);
                auto __iu = reinterpret_cast<unsigned long>(__pu);
                return __it <=> __iu;
            } else
                return static_cast<_Tp &&>(__t) <=> static_cast<_Up &&>(__u);
        }
        template<> constexpr std::strong_ordering operator()<const std::error_category *, const std::error_category *>(const std::error_category *&&__t, const std::error_category *&&__u) const noexcept(noexcept(std::declval<const std::error_category *>() <=> std::declval<const std::error_category *>())) [[nodiscard("")]] {
            if (__detail::__3way_builtin_ptr_cmp<const std::error_category *, const std::error_category *>) {
                auto __pt = static_cast<const volatile void *>(__t);
                auto __pu = static_cast<const volatile void *>(__u);
                if (std::__is_constant_evaluated())
                    return __pt <=> __pu;
                auto __it = reinterpret_cast<unsigned long>(__pt);
                auto __iu = reinterpret_cast<unsigned long>(__pu);
                return __it <=> __iu;
            }
        }
        using is_transparent = void;
    };
    namespace __cmp_cust {
        template <floating_point _Tp> constexpr weak_ordering __fp_weak_ordering(_Tp __e, _Tp __f) {
            auto __cat = [](_Tp __fp) -> int {
                const int __sign = __builtin_signbit(__fp) ? -1 : 1;
                if (__builtin_isnormal(__fp))
                    return (__fp == 0 ? 1 : 3) * __sign;
                if (__builtin_isnan(__fp))
                    return 5 * __sign;
                if (int __inf = __builtin_isinf_sign(__fp))
                    return 4 * __inf;
                return 2 * __sign;
            };
            auto __po = __e <=> __f;
            if (is_lt(__po))
                return weak_ordering::less;
            else if (is_gt(__po))
                return weak_ordering::greater;
            else if (__po == partial_ordering::equivalent)
                return weak_ordering::equivalent;
            else {
                auto __isnan_sign = [](_Tp __fp) -> int {
                    return __builtin_isnan(__fp) ? __builtin_signbit(__fp) ? -1 : 1 : 0;
                };
                auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
                if (is_eq(__ord))
                    return weak_ordering::equivalent;
                else if (is_lt(__ord))
                    return weak_ordering::less;
                else
                    return weak_ordering::greater;
            }
        }
        template <typename _Tp, typename _Up> concept __adl_strong = requires (_Tp &&__t, _Up &&__u) { strong_ordering(strong_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };
        template <typename _Tp, typename _Up> concept __adl_weak = requires (_Tp &&__t, _Up &&__u) { weak_ordering(weak_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };
        template <typename _Tp, typename _Up> concept __adl_partial = requires (_Tp &&__t, _Up &&__u) { partial_ordering(partial_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };
        template <typename _Ord, typename _Tp, typename _Up> concept __cmp3way = requires (_Tp &&__t, _Up &&__u, compare_three_way __c) { _Ord(__c(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };
        template <typename _Tp, typename _Up> concept __strongly_ordered = __adl_strong<_Tp, _Up> || floating_point<remove_reference_t<_Tp>> || __cmp3way<strong_ordering, _Tp, _Up>;
        template <typename _Tp, typename _Up> concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;
        class _Strong_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
                if (floating_point<decay_t<_Tp>>)
                    return true;
                else if (__adl_strong<_Tp, _Up>)
                    return noexcept(strong_ordering(strong_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<strong_ordering, _Tp, _Up>)
                    return noexcept(compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
            }
            friend  class _Weak_order;
            friend  class _Strong_fallback;
            enum class _Fp_fmt : int {
                _Binary16,
                _Binary32,
                _Binary64,
                _Binary128,
                _X86_80bit,
                _M68k_80bit,
                _Dbldbl,
                _Bfloat16
            };
            template <typename _Tp> static consteval _Fp_fmt _S_fp_fmt() noexcept {
                using enum 0x56438a536c88;
                if (__is_same(_Tp, long double))
                    return (-16381) == -16381 ? _X86_80bit : _M68k_80bit;
                constexpr int __width = sizeof(_Tp) * 8;
                if (__width == 16)
                    return _Binary16;
                else if (__width == 32)
                    return _Binary32;
                else if (__width == 64)
                    return _Binary64;
                else if (__width == 128)
                    return _Binary128;
            }
            using int64_t = long;
            using int32_t = int;
            using int16_t = short;
            using uint64_t = unsigned long;
            using uint16_t = unsigned short;
            template <typename _Tp> struct _Int {
                uint64_t _M_lo;
                _Tp _M_hi;
                constexpr explicit _Int<_Tp>(_Tp __hi, uint64_t __lo) noexcept : _M_hi(__hi) {
                    this->_M_lo = __lo;
                }
                constexpr explicit _Int<_Tp>(uint64_t __lo) noexcept : _M_hi(0) {
                    this->_M_lo = __lo;
                }
                bool operator==(const _Int<_Tp> &) const = default
                constexpr _Int<_Tp> &operator^=(const _Int<_Tp> &__rhs) noexcept {
                    this->_M_hi ^= __rhs._M_hi;
                    this->_M_lo ^= __rhs._M_lo;
                    return *this;
                }
                constexpr strong_ordering operator<=>(const _Int<_Tp> &__rhs) const noexcept {
                    strong_ordering __cmp = this->_M_hi <=> __rhs._M_hi;
                    if (__cmp != strong_ordering::equal)
                        return __cmp;
                    return this->_M_lo <=> __rhs._M_lo;
                }
            };
            template<> struct _Int<int> {
                uint64_t _M_lo;
                int _M_hi;
                constexpr explicit _Int(int __hi, uint64_t __lo) noexcept;
                constexpr explicit _Int(uint64_t __lo) noexcept;
                bool operator==(const _Int<int> &) const = default
                constexpr _Int<int> &operator^=(const _Int<int> &__rhs) noexcept;
                constexpr strong_ordering operator<=>(const _Int<int> &__rhs) const noexcept;
            };
            template<> struct _Int<short> {
                uint64_t _M_lo;
                short _M_hi;
                constexpr explicit _Int(short __hi, uint64_t __lo) noexcept : _M_hi(__hi) {
                    this->_M_lo = __lo;
                }
                constexpr explicit _Int(uint64_t __lo) noexcept;
                bool operator==(const _Int<short> &) const = default
                constexpr _Int<short> &operator^=(const _Int<short> &__rhs) noexcept;
                constexpr strong_ordering operator<=>(const _Int<short> &__rhs) const noexcept;
            };
            template<> struct _Int<long> {
                uint64_t _M_lo;
                long _M_hi;
                constexpr explicit _Int(long __hi, uint64_t __lo) noexcept;
                constexpr explicit _Int(uint64_t __lo) noexcept;
                bool operator==(const _Int<long> &) const = default
                constexpr _Int<long> &operator^=(const _Int<long> &__rhs) noexcept;
                constexpr strong_ordering operator<=>(const _Int<long> &__rhs) const noexcept;
            };
            template <typename _Tp> static constexpr _Tp _S_compl(_Tp __t) noexcept {
                constexpr int __width = sizeof(_Tp) * 8;
                make_unsigned_t<_Tp> __sign = __t >> (__width - 1);
                return __t ^ (__sign >> 1);
            }
            template <typename _Tp> static constexpr _Int<_Tp> _S_compl(_Int<_Tp> __t) noexcept {
                constexpr int __width = sizeof(_Tp) * 8;
                make_unsigned_t<_Tp> __sign = __t._M_hi >> (__width - 1);
                __t._M_hi ^= (__sign >> 1);
                uint64_t __sign64 = (_Tp)__sign;
                __t._M_lo ^= __sign64;
                return __t;
            }
            template <typename _Tp> static constexpr auto _S_fp_bits(_Tp __val) noexcept {
                if (sizeof(_Tp) == sizeof(int64_t))
                    return __builtin_bit_cast(int64_t, __val);
                else if (sizeof(_Tp) == sizeof(int32_t))
                    return __builtin_bit_cast(int32_t, __val);
                else if (sizeof(_Tp) == sizeof(int16_t))
                    return __builtin_bit_cast(int16_t, __val);
                else {
                    using enum 0x56438a536c88;
                    constexpr auto __fmt = _S_fp_fmt<_Tp>();
                    if (__fmt == _X86_80bit || __fmt == _M68k_80bit) {
                        if (sizeof(_Tp) == 3 * sizeof(int32_t)) {
                            auto __ival = __builtin_bit_cast(_Int<int32_t>, __val);
                            return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
                        } else {
                            auto __ival = __builtin_bit_cast(_Int<int64_t>, __val);
                            return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
                        }
                    } else if (sizeof(_Tp) == 2 * sizeof(int64_t)) {
                        return __builtin_bit_cast(__int128, __val);
                    } else
                        static_assert(sizeof(_Tp) == sizeof(int64_t), "unsupported floating-point type");
                }
            }
            template <typename _Tp> static constexpr strong_ordering _S_fp_cmp(_Tp __x, _Tp __y) noexcept {
                auto __ix = _S_fp_bits(__x);
                auto __iy = _S_fp_bits(__y);
                if (__ix == __iy)
                    return strong_ordering::equal;
                using enum 0x56438a536c88;
                constexpr auto __fmt = _S_fp_fmt<_Tp>();
                if (__fmt == _Dbldbl) {
                    struct _Unpacked {
                        double _M_hi;
                        int64_t _M_lo;
                    };
                    auto __x2 = __builtin_bit_cast(_Unpacked, __x);
                    auto __y2 = __builtin_bit_cast(_Unpacked, __y);
                    auto __cmp = _S_fp_cmp(__x2._M_hi, __y2._M_hi);
                    if (__cmp != strong_ordering::equal)
                        return __cmp;
                    if (__builtin_isnan(__x2._M_hi))
                        return strong_ordering::equal;
                    if (((__x2._M_lo | __y2._M_lo) & 9223372036854775807ULL) == 0)
                        return strong_ordering::equal;
                    return _S_compl(__x2._M_lo) <=> _S_compl(__y2._M_lo);
                } else {
                    if (__fmt == _M68k_80bit) {
                        constexpr uint16_t __maxexp = 32767;
                        if ((__ix._M_hi & __maxexp) == __maxexp)
                            __ix._M_lo |= 1ULL << 63;
                        if ((__iy._M_hi & __maxexp) == __maxexp)
                            __iy._M_lo |= 1ULL << 63;
                    } else {
                    }
                    return _S_compl(__ix) <=> _S_compl(__iy);
                }
            }
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr strong_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]] {
                if (floating_point<decay_t<_Tp>>)
                    return _S_fp_cmp(__e, __f);
                else if (__adl_strong<_Tp, _Up>)
                    return strong_ordering(strong_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<strong_ordering, _Tp, _Up>)
                    return compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __weakly_ordered = floating_point<remove_reference_t<_Tp>> || __adl_weak<_Tp, _Up> || __cmp3way<weak_ordering, _Tp, _Up> || __strongly_ordered<_Tp, _Up>;
        class _Weak_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
                if (floating_point<decay_t<_Tp>>)
                    return true;
                else if (__adl_weak<_Tp, _Up>)
                    return noexcept(weak_ordering(weak_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<weak_ordering, _Tp, _Up>)
                    return noexcept(compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
                else if (__strongly_ordered<_Tp, _Up>)
                    return _Strong_order::_S_noexcept<_Tp, _Up>();
            }
            friend  class _Partial_order;
            friend  class _Weak_fallback;
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr weak_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]] {
                if (floating_point<decay_t<_Tp>>)
                    return __cmp_cust::__fp_weak_ordering(__e, __f);
                else if (__adl_weak<_Tp, _Up>)
                    return weak_ordering(weak_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<weak_ordering, _Tp, _Up>)
                    return compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__strongly_ordered<_Tp, _Up>)
                    return _Strong_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __partially_ordered = __adl_partial<_Tp, _Up> || __cmp3way<partial_ordering, _Tp, _Up> || __weakly_ordered<_Tp, _Up>;
        class _Partial_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
                if (__adl_partial<_Tp, _Up>)
                    return noexcept(partial_ordering(partial_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<partial_ordering, _Tp, _Up>)
                    return noexcept(compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
                else if (__weakly_ordered<_Tp, _Up>)
                    return _Weak_order::_S_noexcept<_Tp, _Up>();
            }
            friend  class _Partial_fallback;
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr partial_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]] {
                if (__adl_partial<_Tp, _Up>)
                    return partial_ordering(partial_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<partial_ordering, _Tp, _Up>)
                    return compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__weakly_ordered<_Tp, _Up>)
                    return _Weak_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __op_eq_lt = requires (_Tp &&__t, _Up &&__u) { { static_cast<_Tp &&>(__t) == static_cast<_Up &&>(__u) } -> convertible_to<bool>; { static_cast<_Tp &&>(__t) < static_cast<_Up &&>(__u) } -> convertible_to<bool>; };
        class _Strong_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
                if (__strongly_ordered<_Tp, _Up>)
                    return _Strong_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr strong_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]] {
                if (__strongly_ordered<_Tp, _Up>)
                    return _Strong_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? strong_ordering::equal : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? strong_ordering::less : strong_ordering::greater;
            }
        };
        class _Weak_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
                if (__weakly_ordered<_Tp, _Up>)
                    return _Weak_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr weak_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]] {
                if (__weakly_ordered<_Tp, _Up>)
                    return _Weak_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? weak_ordering::equivalent : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? weak_ordering::less : weak_ordering::greater;
            }
        };
        template <typename _Tp, typename _Up> concept __op_eq_lt_lt = __op_eq_lt<_Tp, _Up> && requires (_Tp &&__t, _Up &&__u) { { static_cast<_Up &&>(__u) < static_cast<_Tp &&>(__t) } -> convertible_to<bool>; };
        class _Partial_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
                if (__partially_ordered<_Tp, _Up>)
                    return _Partial_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr partial_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]] {
                if (__partially_ordered<_Tp, _Up>)
                    return _Partial_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? partial_ordering::equivalent : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? partial_ordering::less : static_cast<_Up &&>(__f) < static_cast<_Tp &&>(__e) ? partial_ordering::greater : partial_ordering::unordered;
            }
        };
    }
    inline namespace __cmp_alg {
        constexpr __cmp_cust::_Strong_order strong_order{};
        constexpr __cmp_cust::_Weak_order weak_order{};
        constexpr __cmp_cust::_Partial_order partial_order{};
        constexpr __cmp_cust::_Strong_fallback compare_strong_order_fallback{};
        constexpr __cmp_cust::_Weak_fallback compare_weak_order_fallback{};
        constexpr __cmp_cust::_Partial_fallback compare_partial_order_fallback{};
    }
    namespace __detail {
        constexpr struct _Synth3way {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept(const _Tp *__t = nullptr, const _Up *__u = nullptr) {
                if (three_way_comparable_with<_Tp, _Up>)
                    return noexcept(*__t <=> *__u);
                else
                    return noexcept(*__t < *__u) && noexcept(*__u < *__t);
            }
            template <typename _Tp, typename _Up> constexpr auto operator()(const _Tp &__t, const _Up &__u) const noexcept(_S_noexcept<_Tp, _Up>()) requires requires { { __t < __u } -> __boolean_testable; { __u < __t } -> __boolean_testable; } [[nodiscard("")]] {
                if (three_way_comparable_with<_Tp, _Up>)
                    return __t <=> __u;
                else {
                    if (__t < __u)
                        return weak_ordering::less;
                    else if (__u < __t)
                        return weak_ordering::greater;
                    else
                        return weak_ordering::equivalent;
                }
            }
        } __synth3way = {};
        template <typename _Tp, typename _Up = _Tp> using __synth3way_t = decltype(__detail::__synth3way(std::declval<_Tp &>(), std::declval<_Up &>()));
    }
}
namespace __gnu_debug {
    struct _Safe_iterator_base;
}
namespace std {
    class __undefined;
    template <typename _Tp> struct __get_first_arg {
        using type = __undefined;
    };
    template <template <typename, typename ...> class _SomeTemplate, typename _Tp, typename ..._Types> struct __get_first_arg<_SomeTemplate<_Tp, _Types...>> {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __replace_first_arg {
    };
    template <template <typename, typename ...> class _SomeTemplate, typename _Up, typename _Tp, typename ..._Types> struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up> {
        using type = _SomeTemplate<_Up, _Types...>;
    };
    template <typename _Ptr, typename = void> struct __ptr_traits_elem : __get_first_arg<_Ptr> {
    };
    template <typename _Ptr> struct __ptr_traits_elem<_Ptr, void> {
        using type = typename _Ptr::element_type;
    };
    template <typename _Ptr> using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;
    template <typename _Ptr, typename _Elt, bool = is_void<_Elt>::value> struct __ptr_traits_ptr_to {
        using pointer = _Ptr;
        using element_type = _Elt;
        static pointer pointer_to(element_type &__r) requires requires { { pointer::pointer_to(__r) } -> convertible_to<pointer>; } {
            return pointer::pointer_to(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<char *, char, false> {
        using pointer = char *;
        using element_type = char;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const char *, const char, false> {
        using pointer = const char *;
        using element_type = const char;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const wchar_t *, const wchar_t, false> {
        using pointer = const wchar_t *;
        using element_type = const wchar_t;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<wchar_t *, wchar_t, false> {
        using pointer = wchar_t *;
        using element_type = wchar_t;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<char8_t *, char8_t, false> {
        using pointer = char8_t *;
        using element_type = char8_t;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const char8_t *, const char8_t, false> {
        using pointer = const char8_t *;
        using element_type = const char8_t;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<char16_t *, char16_t, false> {
        using pointer = char16_t *;
        using element_type = char16_t;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const char16_t *, const char16_t, false> {
        using pointer = const char16_t *;
        using element_type = const char16_t;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<char32_t *, char32_t, false> {
        using pointer = char32_t *;
        using element_type = char32_t;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template<> struct __ptr_traits_ptr_to<const char32_t *, const char32_t, false> {
        using pointer = const char32_t *;
        using element_type = const char32_t;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Elt> struct __ptr_traits_ptr_to<_Ptr, _Elt, true> {
    };
    template <typename _Tp> struct __ptr_traits_ptr_to<_Tp *, _Tp, false> {
        using pointer = _Tp *;
        using element_type = _Tp;
        static constexpr pointer pointer_to(element_type &__r) noexcept {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Elt> struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt> {
    private:
        template <typename _Tp> using __diff_t = typename _Tp::difference_type;
        template <typename _Tp, typename _Up> using __rebind = __type_identity<typename _Tp::template rebind<_Up>>;
    public:
        using pointer = _Ptr;
        using element_type = _Elt;
        using difference_type = __detected_or_t<ptrdiff_t, __diff_t, _Ptr>;
        template <typename _Up> using rebind = typename __detected_or_t<__replace_first_arg<_Ptr, _Up>, __rebind, _Ptr, _Up>::type;
    };
    template <typename _Ptr> struct __ptr_traits_impl<_Ptr, __undefined> {
    };
    template <typename _Ptr> struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>> {
    };
    template<> struct pointer_traits<char *> : __ptr_traits_ptr_to<char *, char> {
        typedef char *pointer;
        typedef char element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const char *> : __ptr_traits_ptr_to<const char *, const char> {
        typedef const char *pointer;
        typedef const char element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const wchar_t *> : __ptr_traits_ptr_to<const wchar_t *, const wchar_t> {
        typedef const wchar_t *pointer;
        typedef const wchar_t element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<wchar_t *> : __ptr_traits_ptr_to<wchar_t *, wchar_t> {
        typedef wchar_t *pointer;
        typedef wchar_t element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<char8_t *> : __ptr_traits_ptr_to<char8_t *, char8_t> {
        typedef char8_t *pointer;
        typedef char8_t element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const char8_t *> : __ptr_traits_ptr_to<const char8_t *, const char8_t> {
        typedef const char8_t *pointer;
        typedef const char8_t element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<char16_t *> : __ptr_traits_ptr_to<char16_t *, char16_t> {
        typedef char16_t *pointer;
        typedef char16_t element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const char16_t *> : __ptr_traits_ptr_to<const char16_t *, const char16_t> {
        typedef const char16_t *pointer;
        typedef const char16_t element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<char32_t *> : __ptr_traits_ptr_to<char32_t *, char32_t> {
        typedef char32_t *pointer;
        typedef char32_t element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template<> struct pointer_traits<const char32_t *> : __ptr_traits_ptr_to<const char32_t *, const char32_t> {
        typedef const char32_t *pointer;
        typedef const char32_t element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template <typename _Tp> struct pointer_traits<_Tp *> : __ptr_traits_ptr_to<_Tp *, _Tp> {
        typedef _Tp *pointer;
        typedef _Tp element_type;
        typedef ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template <typename _Ptr, typename _Tp> using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
    template <typename _Tp> constexpr _Tp *__to_address(_Tp *__ptr) noexcept {
        static_assert(!std::is_function<_Tp>::value, "not a function pointer");
        return __ptr;
    }
    template <typename _Ptr> constexpr auto __to_address(const _Ptr &__ptr) noexcept -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr)) {
        return std::pointer_traits<_Ptr>::to_address(__ptr);
    }
    template <typename _Ptr, typename ..._None> constexpr auto __to_address(const _Ptr &__ptr, _None ...) noexcept {
        if (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
            return std::__to_address(__ptr.base().operator->());
        else
            return std::__to_address(__ptr.operator->());
    }
    template <typename _Tp> constexpr _Tp *to_address(_Tp *__ptr) noexcept {
        return std::__to_address(__ptr);
    }
    template<> constexpr const char *to_address<const char>(const char *__ptr) noexcept    template<> constexpr const wchar_t *to_address<const wchar_t>(const wchar_t *__ptr) noexcept    template<> constexpr const char8_t *to_address<const char8_t>(const char8_t *__ptr) noexcept    template<> constexpr const char16_t *to_address<const char16_t>(const char16_t *__ptr) noexcept    template<> constexpr const char32_t *to_address<const char32_t>(const char32_t *__ptr) noexcept    template <typename _Ptr> constexpr auto to_address(const _Ptr &__ptr) noexcept {
        return std::__to_address(__ptr);
    }
    template<> constexpr auto to_address<const char *>(const char *const &__ptr) noexcept    template<> constexpr auto to_address<const wchar_t *>(const wchar_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char8_t *>(const char8_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char16_t *>(const char16_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char32_t *>(const char32_t *const &__ptr) noexcept}
namespace std {
    struct __is_transparent;
    struct identity {
        template <typename _Tp> constexpr _Tp &&operator()(_Tp &&__t) const noexcept [[nodiscard("")]] {
            return std::forward<_Tp>(__t);
        }
        using is_transparent = __is_transparent;
    };
    namespace ranges {
        namespace __detail {
            template <typename _Tp, typename _Up> concept __less_builtin_ptr_cmp = requires (_Tp &&__t, _Up &&__u) { { __t < __u } -> same_as<bool>; } && convertible_to<_Tp, const volatile void *> && convertible_to<_Up, const volatile void *> && (!requires (_Tp &&__t, _Up &&__u) { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); } && !requires (_Tp &&__t, _Up &&__u) { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });
        }
        struct equal_to {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>())) {
                return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
            }
            using is_transparent = __is_transparent;
        };
        struct not_equal_to {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>())) {
                return !equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u));
            }
            using is_transparent = __is_transparent;
        };
        struct less {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>())) {
                if (__detail::__less_builtin_ptr_cmp<_Tp, _Up>) {
                    if (std::__is_constant_evaluated())
                        return __t < __u;
                    auto __x = reinterpret_cast<unsigned long>(static_cast<const volatile void *>(std::forward<_Tp>(__t)));
                    auto __y = reinterpret_cast<unsigned long>(static_cast<const volatile void *>(std::forward<_Up>(__u)));
                    return __x < __y;
                } else
                    return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
            }
            using is_transparent = __is_transparent;
        };
        struct greater {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>())) {
                return less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t));
            }
            using is_transparent = __is_transparent;
        };
        struct greater_equal {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>())) {
                return !less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u));
            }
            using is_transparent = __is_transparent;
        };
        struct less_equal {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>())) {
                return !less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t));
            }
            using is_transparent = __is_transparent;
        };
    }
}
namespace std {
    struct default_sentinel_t {
    };
    constexpr default_sentinel_t default_sentinel{};
    struct input_iterator_tag;
    struct output_iterator_tag;
    struct forward_iterator_tag;
    struct bidirectional_iterator_tag;
    struct random_access_iterator_tag;
    struct contiguous_iterator_tag;
    template <typename _Iterator> struct iterator_traits
    template<> struct iterator_traits<const char *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    }
    template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    }
    template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    }
    template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    }
    template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    }
    template<> struct iterator_traits<std::_Bit_iterator> : public __iterator_traits<_Bit_iterator> {
    }
    template<> struct iterator_traits<std::_Bit_const_iterator> : public __iterator_traits<_Bit_const_iterator> {
    }
    template<> struct iterator_traits<unsigned long *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<unsigned long>;
        using difference_type = ptrdiff_t;
        using pointer = unsigned long *;
        using reference = unsigned long &;
    }
    template<> struct iterator_traits<const int *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const int>;
        using difference_type = ptrdiff_t;
        using pointer = const int *;
        using reference = const int &;
    }
    template<> struct iterator_traits<int *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<int>;
        using difference_type = ptrdiff_t;
        using pointer = int *;
        using reference = int &;
    }
    template<> struct iterator_traits<char *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    }
    template<> struct iterator_traits<Base<ChildA, ChildB, ChildC> *const *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<Base<ChildA, ChildB, ChildC> *const>;
        using difference_type = ptrdiff_t;
        using pointer = Base<ChildA, ChildB, ChildC> *const *;
        using reference = Base<ChildA, ChildB, ChildC> *const &;
    }
    template<> struct iterator_traits<Base<ChildA, ChildB, ChildC> **> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<Base<ChildA, ChildB, ChildC> *>;
        using difference_type = ptrdiff_t;
        using pointer = Base<ChildA, ChildB, ChildC> **;
        using reference = Base<ChildA, ChildB, ChildC> *&;
    }
    template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    }
    template<> struct iterator_traits<char8_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char8_t>;
        using difference_type = ptrdiff_t;
        using pointer = char8_t *;
        using reference = char8_t &;
    }
    template<> struct iterator_traits<char16_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char16_t>;
        using difference_type = ptrdiff_t;
        using pointer = char16_t *;
        using reference = char16_t &;
    }
    template<> struct iterator_traits<char32_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char32_t>;
        using difference_type = ptrdiff_t;
        using pointer = char32_t *;
        using reference = char32_t &;
    };
    template <typename _Tp> struct iterator_traits<_Tp *>;
    template <typename _Iterator, typename> struct __iterator_traits
    template<> struct __iterator_traits<std::_Bit_iterator, void> {
    private:
        template <typename _Iter> struct __ptr
        template<> struct __ptr<std::_Bit_iterator> {
            using type = typename _Bit_iterator::pointer;
        };
    public:
        using iterator_category = typename _Bit_iterator::iterator_category;
        using value_type = typename _Bit_iterator::value_type;
        using difference_type = typename _Bit_iterator::difference_type;
        using pointer = typename __ptr<_Bit_iterator>::type;
        using reference = typename _Bit_iterator::reference;
    }
    template<> struct __iterator_traits<std::_Bit_const_iterator, void> {
    private:
        template <typename _Iter> struct __ptr
        template<> struct __ptr<std::_Bit_const_iterator> {
            using type = typename _Bit_const_iterator::pointer;
        };
    public:
        using iterator_category = typename _Bit_const_iterator::iterator_category;
        using value_type = typename _Bit_const_iterator::value_type;
        using difference_type = typename _Bit_const_iterator::difference_type;
        using pointer = typename __ptr<_Bit_const_iterator>::type;
        using reference = typename _Bit_const_iterator::reference;
    };
    namespace __detail {
        template <typename _Tp> using __with_ref = _Tp &;
        template <typename _Tp> concept __can_reference = requires { typename __with_ref<_Tp>; };
        template <typename _Tp> concept __dereferenceable = requires (_Tp &__t) { { *__t } -> __can_reference; };
    }
    template <__detail::__dereferenceable _Tp> using iter_reference_t = decltype(*std::declval<_Tp &>());
    namespace ranges {
        namespace __cust_imove {
            void iter_move();
            template <typename _Tp> concept __adl_imove = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>) && requires (_Tp &&__t) { iter_move(static_cast<_Tp &&>(__t)); };
            struct _IMove {
            private:
                template <typename _Tp> struct __result {
                    using type = iter_reference_t<_Tp>;
                };
                template<> struct __result<const char *&> {
                    using type = remove_reference_t<iter_reference_t<const char *&>> &&;
                };
                template<> struct __result<const char *const &> {
                    using type = remove_reference_t<iter_reference_t<const char *const &>> &&;
                };
                template<> struct __result<const wchar_t *&> {
                    using type = remove_reference_t<iter_reference_t<const wchar_t *&>> &&;
                };
                template<> struct __result<const wchar_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const wchar_t *const &>> &&;
                };
                template<> struct __result<const char8_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char8_t *&>> &&;
                };
                template<> struct __result<const char8_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char8_t *const &>> &&;
                };
                template<> struct __result<const char16_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char16_t *&>> &&;
                };
                template<> struct __result<const char16_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char16_t *const &>> &&;
                };
                template<> struct __result<const char32_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char32_t *&>> &&;
                };
                template<> struct __result<const char32_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char32_t *const &>> &&;
                };
                template<> struct __result<std::_Bit_iterator &> {
                    using type = iter_reference_t<_Bit_iterator &>;
                };
                template<> struct __result<const std::_Bit_iterator &> {
                    using type = iter_reference_t<const _Bit_iterator &>;
                };
                template<> struct __result<std::_Bit_const_iterator &> {
                    using type = iter_reference_t<_Bit_const_iterator &>;
                };
                template<> struct __result<const std::_Bit_const_iterator &> {
                    using type = iter_reference_t<const _Bit_const_iterator &>;
                };
                template <typename _Tp> struct __result<_Tp> {
                    using type = decltype(iter_move(std::declval<_Tp>()));
                };
                template <typename _Tp> struct __result<_Tp> {
                    using type = remove_reference_t<iter_reference_t<_Tp>> &&;
                };
                template <typename _Tp> static constexpr bool _S_noexcept() {
                    if (__adl_imove<_Tp>)
                        return noexcept(iter_move(std::declval<_Tp>()));
                    else
                        return noexcept(*std::declval<_Tp>());
                }
            public:
                template <std::__detail::__dereferenceable _Tp> using __type = typename __result<_Tp>::type;
                template <std::__detail::__dereferenceable _Tp> constexpr __type<_Tp> operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>()) [[nodiscard("")]] {
                    if (__adl_imove<_Tp>)
                        return iter_move(static_cast<_Tp &&>(__e));
                    else if (is_lvalue_reference_v<iter_reference_t<_Tp>>)
                        return static_cast<__type<_Tp>>(*__e);
                    else
                        return *__e;
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_imove::_IMove iter_move{};
        }
    }
    template <__detail::__dereferenceable _Tp> using iter_rvalue_reference_t = ranges::__cust_imove::_IMove::__type<_Tp &>;
    template <typename> struct incrementable_traits {
    };
    template<> struct incrementable_traits<std::_Bit_iterator> {
        using difference_type = typename _Bit_iterator::difference_type;
    };
    template<> struct incrementable_traits<std::_Bit_const_iterator> {
        using difference_type = typename _Bit_const_iterator::difference_type;
    };
    template <typename _Tp> struct incrementable_traits<_Tp *> {
        using difference_type = ptrdiff_t;
    };
    template <typename _Iter> struct incrementable_traits<const _Iter> : incrementable_traits<_Iter> {
    };
    template <typename _Tp> struct incrementable_traits<_Tp> {
        using difference_type = typename _Tp::difference_type;
    };
    template <typename _Tp> struct incrementable_traits<_Tp> {
        using difference_type = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
    };
    template<> struct incrementable_traits<__int128> {
        using difference_type = __int128;
    };
    template<> struct incrementable_traits<unsigned __int128> {
        using difference_type = __int128;
    };
    namespace __detail {
        template <typename _Iter> concept __primary_traits_iter = __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);
        template <typename _Iter, typename _Tp> struct __iter_traits_impl {
            using type = iterator_traits<_Iter>;
        };
        template<> struct __iter_traits_impl<const char *, std::incrementable_traits<const char *>> {
            using type = iterator_traits<const char *>;
        };
        template<> struct __iter_traits_impl<const char *, std::indirectly_readable_traits<const char *>> {
            using type = iterator_traits<const char *>;
        };
        template<> struct __iter_traits_impl<const char *, const char *> {
            using type = iterator_traits<const char *>;
        };
        template<> struct __iter_traits_impl<const wchar_t *, std::incrementable_traits<const wchar_t *>> {
            using type = iterator_traits<const wchar_t *>;
        };
        template<> struct __iter_traits_impl<const wchar_t *, std::indirectly_readable_traits<const wchar_t *>> {
            using type = iterator_traits<const wchar_t *>;
        };
        template<> struct __iter_traits_impl<const wchar_t *, const wchar_t *> {
            using type = iterator_traits<const wchar_t *>;
        };
        template<> struct __iter_traits_impl<const char8_t *, std::incrementable_traits<const char8_t *>> {
            using type = iterator_traits<const char8_t *>;
        };
        template<> struct __iter_traits_impl<const char8_t *, std::indirectly_readable_traits<const char8_t *>> {
            using type = iterator_traits<const char8_t *>;
        };
        template<> struct __iter_traits_impl<const char8_t *, const char8_t *> {
            using type = iterator_traits<const char8_t *>;
        };
        template<> struct __iter_traits_impl<const char16_t *, std::incrementable_traits<const char16_t *>> {
            using type = iterator_traits<const char16_t *>;
        };
        template<> struct __iter_traits_impl<const char16_t *, std::indirectly_readable_traits<const char16_t *>> {
            using type = iterator_traits<const char16_t *>;
        };
        template<> struct __iter_traits_impl<const char16_t *, const char16_t *> {
            using type = iterator_traits<const char16_t *>;
        };
        template<> struct __iter_traits_impl<const char32_t *, std::incrementable_traits<const char32_t *>> {
            using type = iterator_traits<const char32_t *>;
        };
        template<> struct __iter_traits_impl<const char32_t *, std::indirectly_readable_traits<const char32_t *>> {
            using type = iterator_traits<const char32_t *>;
        };
        template<> struct __iter_traits_impl<const char32_t *, const char32_t *> {
            using type = iterator_traits<const char32_t *>;
        };
        template<> struct __iter_traits_impl<std::_Bit_iterator, std::incrementable_traits<std::_Bit_iterator>> {
            using type = std::incrementable_traits<std::_Bit_iterator>;
        };
        template<> struct __iter_traits_impl<std::_Bit_iterator, std::indirectly_readable_traits<std::_Bit_iterator>> {
            using type = std::indirectly_readable_traits<std::_Bit_iterator>;
        };
        template<> struct __iter_traits_impl<std::_Bit_iterator, std::_Bit_iterator> {
            using type = std::_Bit_iterator;
        };
        template<> struct __iter_traits_impl<std::_Bit_const_iterator, std::incrementable_traits<std::_Bit_const_iterator>> {
            using type = std::incrementable_traits<std::_Bit_const_iterator>;
        };
        template<> struct __iter_traits_impl<std::_Bit_const_iterator, std::indirectly_readable_traits<std::_Bit_const_iterator>> {
            using type = std::indirectly_readable_traits<std::_Bit_const_iterator>;
        };
        template<> struct __iter_traits_impl<std::_Bit_const_iterator, std::_Bit_const_iterator> {
            using type = std::_Bit_const_iterator;
        };
        template<> struct __iter_traits_impl<char *, char *> {
            using type = iterator_traits<char *>;
        };
        template<> struct __iter_traits_impl<Base<ChildA, ChildB, ChildC> **, Base<ChildA, ChildB, ChildC> **> {
            using type = iterator_traits<Base<ChildA, ChildB, ChildC> **>;
        };
        template<> struct __iter_traits_impl<int *, int *> {
            using type = iterator_traits<int *>;
        };
        template<> struct __iter_traits_impl<wchar_t *, wchar_t *> {
            using type = iterator_traits<wchar_t *>;
        };
        template<> struct __iter_traits_impl<char8_t *, char8_t *> {
            using type = iterator_traits<char8_t *>;
        };
        template<> struct __iter_traits_impl<char16_t *, char16_t *> {
            using type = iterator_traits<char16_t *>;
        };
        template<> struct __iter_traits_impl<char32_t *, char32_t *> {
            using type = iterator_traits<char32_t *>;
        };
        template <typename _Iter, typename _Tp> struct __iter_traits_impl<_Iter, _Tp> {
            using type = _Tp;
        };
        template <typename _Iter, typename _Tp = _Iter> using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;
        template <typename _Tp> using __iter_diff_t = typename __iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
    }
    template <typename _Tp> using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;
    namespace __detail {
        template <typename> struct __cond_value_type {
        };
        template<> struct __cond_value_type<bool> {
            using value_type = remove_cv_t<bool>;
        };
        template <typename _Tp> struct __cond_value_type<_Tp> {
            using value_type = remove_cv_t<_Tp>;
        };
        template <typename _Tp> concept __has_member_value_type = requires { typename _Tp::value_type; };
        template <typename _Tp> concept __has_member_element_type = requires { typename _Tp::element_type; };
    }
    template <typename> struct indirectly_readable_traits {
    };
    template<> struct indirectly_readable_traits<std::_Bit_iterator> : __detail::__cond_value_type<typename _Bit_iterator::value_type> {
    };
    template<> struct indirectly_readable_traits<std::_Bit_const_iterator> : __detail::__cond_value_type<typename _Bit_const_iterator::value_type> {
    };
    template <typename _Tp> struct indirectly_readable_traits<_Tp *> : __detail::__cond_value_type<_Tp> {
    };
    template <typename _Iter> struct indirectly_readable_traits<_Iter> {
        using value_type = remove_cv_t<remove_extent_t<_Iter>>;
    };
    template <typename _Iter> struct indirectly_readable_traits<const _Iter> : indirectly_readable_traits<_Iter> {
    };
    template <__detail::__has_member_value_type _Tp> struct indirectly_readable_traits<_Tp> : __detail::__cond_value_type<typename _Tp::value_type> {
    };
    template <__detail::__has_member_element_type _Tp> struct indirectly_readable_traits<_Tp> : __detail::__cond_value_type<typename _Tp::element_type> {
    };
    template <__detail::__has_member_value_type _Tp> struct indirectly_readable_traits<_Tp> : __detail::__cond_value_type<typename _Tp::value_type> {
    };
    template <__detail::__has_member_value_type _Tp> struct indirectly_readable_traits<_Tp> {
    };
    namespace __detail {
        template <typename _Tp> using __iter_value_t = typename __iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
    }
    template <typename _Tp> using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;
    namespace __detail {
        template <typename _Iter> concept __cpp17_iterator = requires (_Iter __it) { { *__it } -> __can_reference; { ++__it } -> same_as<_Iter &>; { *__it++ } -> __can_reference; } && copyable<_Iter>;
        template <typename _Iter> concept __cpp17_input_iterator = __cpp17_iterator<_Iter> && equality_comparable<_Iter> && requires (_Iter __it) { typename incrementable_traits<_Iter>::difference_type; typename indirectly_readable_traits<_Iter>::value_type; typename common_reference_t<iter_reference_t<_Iter> &&, typename indirectly_readable_traits<_Iter>::value_type &>; typename common_reference_t<decltype(*__it++) &&, typename indirectly_readable_traits<_Iter>::value_type &>; requires signed_integral<typename incrementable_traits<_Iter>::difference_type>; };
        template <typename _Iter> concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter> && constructible_from<_Iter> && is_lvalue_reference_v<iter_reference_t<_Iter>> && same_as<remove_cvref_t<iter_reference_t<_Iter>>, typename indirectly_readable_traits<_Iter>::value_type> && requires (_Iter __it) { { __it++ } -> convertible_to<const _Iter &>; { *__it++ } -> same_as<iter_reference_t<_Iter>>; };
        template <typename _Iter> concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter> && requires (_Iter __it) { { --__it } -> same_as<_Iter &>; { __it-- } -> convertible_to<const _Iter &>; { *__it-- } -> same_as<iter_reference_t<_Iter>>; };
        template <typename _Iter> concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter> && totally_ordered<_Iter> && requires (_Iter __it, typename incrementable_traits<_Iter>::difference_type __n) { { __it += __n } -> same_as<_Iter &>; { __it -= __n } -> same_as<_Iter &>; { __it + __n } -> same_as<_Iter>; { __n + __it } -> same_as<_Iter>; { __it - __n } -> same_as<_Iter>; { __it - __it } -> same_as<decltype(__n)>; { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>; };
        template <typename _Iter> concept __iter_with_nested_types = requires { typename _Iter::iterator_category; typename _Iter::value_type; typename _Iter::difference_type; typename _Iter::reference; };
        template <typename _Iter> concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;
        template <typename _Iter> concept __iter_without_category = !requires { typename _Iter::iterator_category; };
    }
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = typename _Iter::pointer;
        };
    public:
        using iterator_category = typename _Iterator::iterator_category;
        using value_type = typename _Iterator::value_type;
        using difference_type = typename _Iterator::difference_type;
        using pointer = typename __ptr<_Iterator>::type;
        using reference = typename _Iterator::reference;
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __cat {
            using type = input_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = typename _Iter::iterator_category;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = random_access_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = bidirectional_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = forward_iterator_tag;
        };
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = typename _Iter::pointer;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = decltype(std::declval<_Iter &>().operator->());
        };
        template <typename _Iter> struct __ref {
            using type = iter_reference_t<_Iter>;
        };
        template <typename _Iter> struct __ref<_Iter> {
            using type = typename _Iter::reference;
        };
    public:
        using iterator_category = typename __cat<_Iterator>::type;
        using value_type = typename indirectly_readable_traits<_Iterator>::value_type;
        using difference_type = typename incrementable_traits<_Iterator>::difference_type;
        using pointer = typename __ptr<_Iterator>::type;
        using reference = typename __ref<_Iterator>::type;
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __diff {
            using type = void;
        };
        template <typename _Iter> struct __diff<_Iter> {
            using type = typename incrementable_traits<_Iter>::difference_type;
        };
    public:
        using iterator_category = output_iterator_tag;
        using value_type = void;
        using difference_type = typename __diff<_Iterator>::type;
        using pointer = void;
        using reference = void;
    };
    namespace __detail {
        template <typename _Iter> struct __iter_concept_impl
        template<> struct __iter_concept_impl<const char *> {
            using type = typename __iter_traits<const char *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<const wchar_t *> {
            using type = typename __iter_traits<const wchar_t *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<const char8_t *> {
            using type = typename __iter_traits<const char8_t *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<const char16_t *> {
            using type = typename __iter_traits<const char16_t *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<const char32_t *> {
            using type = typename __iter_traits<const char32_t *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<std::_Bit_iterator> {
            using type = typename __iter_traits<_Bit_iterator>::iterator_category;
        }
        template<> struct __iter_concept_impl<std::_Bit_const_iterator> {
            using type = typename __iter_traits<_Bit_const_iterator>::iterator_category;
        }
        template<> struct __iter_concept_impl<char *> {
            using type = typename __iter_traits<char *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<Base<ChildA, ChildB, ChildC> **> {
            using type = typename __iter_traits<Base<ChildA, ChildB, ChildC> **>::iterator_concept;
        }
        template<> struct __iter_concept_impl<int *> {
            using type = typename __iter_traits<int *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<wchar_t *> {
            using type = typename __iter_traits<wchar_t *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<char8_t *> {
            using type = typename __iter_traits<char8_t *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<char16_t *> {
            using type = typename __iter_traits<char16_t *>::iterator_concept;
        }
        template<> struct __iter_concept_impl<char32_t *> {
            using type = typename __iter_traits<char32_t *>::iterator_concept;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = typename __iter_traits<_Iter>::iterator_concept;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = typename __iter_traits<_Iter>::iterator_category;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = random_access_iterator_tag;
        };
        template <typename _Iter> struct __iter_concept_impl {
        };
        template<> struct __iter_concept_impl<const char *> {
            using type = typename __iter_traits<const char *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<const wchar_t *> {
            using type = typename __iter_traits<const wchar_t *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<const char8_t *> {
            using type = typename __iter_traits<const char8_t *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<const char16_t *> {
            using type = typename __iter_traits<const char16_t *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<const char32_t *> {
            using type = typename __iter_traits<const char32_t *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<std::_Bit_iterator> {
            using type = typename __iter_traits<_Bit_iterator>::iterator_category;
        };
        template<> struct __iter_concept_impl<std::_Bit_const_iterator> {
            using type = typename __iter_traits<_Bit_const_iterator>::iterator_category;
        };
        template<> struct __iter_concept_impl<char *> {
            using type = typename __iter_traits<char *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<Base<ChildA, ChildB, ChildC> **> {
            using type = typename __iter_traits<Base<ChildA, ChildB, ChildC> **>::iterator_concept;
        };
        template<> struct __iter_concept_impl<int *> {
            using type = typename __iter_traits<int *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<wchar_t *> {
            using type = typename __iter_traits<wchar_t *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<char8_t *> {
            using type = typename __iter_traits<char8_t *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<char16_t *> {
            using type = typename __iter_traits<char16_t *>::iterator_concept;
        };
        template<> struct __iter_concept_impl<char32_t *> {
            using type = typename __iter_traits<char32_t *>::iterator_concept;
        };
        template <typename _Iter> using __iter_concept = typename __iter_concept_impl<_Iter>::type;
        template <typename _In> concept __indirectly_readable_impl = requires { typename iter_value_t<_In>; typename iter_reference_t<_In>; typename iter_rvalue_reference_t<_In>; requires same_as<iter_reference_t<const _In>, iter_reference_t<_In>>; requires same_as<iter_rvalue_reference_t<const _In>, iter_rvalue_reference_t<_In>>; } && common_reference_with<iter_reference_t<_In> &&, iter_value_t<_In> &> && common_reference_with<iter_reference_t<_In> &&, iter_rvalue_reference_t<_In> &&> && common_reference_with<iter_rvalue_reference_t<_In> &&, const iter_value_t<_In> &>;
    }
    template <typename _In> concept indirectly_readable = __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;
    template <indirectly_readable _Tp> using iter_common_reference_t = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp> &>;
    template <typename _Out, typename _Tp> concept indirectly_writable = requires (_Out &&__o, _Tp &&__t) { *__o = std::forward<_Tp>(__t); *std::forward<_Out>(__o) = std::forward<_Tp>(__t); const_cast<const iter_reference_t<_Out> &&>(*__o) = std::forward<_Tp>(__t); const_cast<const iter_reference_t<_Out> &&>(*std::forward<_Out>(__o)) = std::forward<_Tp>(__t); };
    namespace ranges {
        namespace __detail {
            class __max_diff_type;
            class __max_size_type;
            template <typename _Tp> concept __is_signed_int128 = same_as<_Tp, __int128>;
            template <typename _Tp> concept __is_unsigned_int128 = same_as<_Tp, unsigned __int128>;
            template <typename _Tp> concept __cv_bool = same_as<const volatile _Tp, const volatile bool>;
            template <typename _Tp> concept __integral_nonbool = integral<_Tp> && !__cv_bool<_Tp>;
            template <typename _Tp> concept __is_int128 = __is_signed_int128<_Tp> || __is_unsigned_int128<_Tp>;
            template <typename _Tp> concept __is_integer_like = __integral_nonbool<_Tp> || __is_int128<_Tp> || same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;
            template <typename _Tp> concept __is_signed_integer_like = signed_integral<_Tp> || __is_signed_int128<_Tp> || same_as<_Tp, __max_diff_type>;
        }
    }
    namespace __detail {
        using ranges::__detail::__is_signed_integer_like;
    }
    template <typename _Iter> concept weakly_incrementable = movable<_Iter> && requires (_Iter __i) { typename iter_difference_t<_Iter>; requires __detail::__is_signed_integer_like<iter_difference_t<_Iter>>; { ++__i } -> same_as<_Iter &>; __i++; };
    template <typename _Iter> concept incrementable = regular<_Iter> && weakly_incrementable<_Iter> && requires (_Iter __i) { { __i++ } -> same_as<_Iter>; };
    template <typename _Iter> concept input_or_output_iterator = requires (_Iter __i) { { *__i } -> __detail::__can_reference; } && weakly_incrementable<_Iter>;
    template <typename _Sent, typename _Iter> concept sentinel_for = semiregular<_Sent> && input_or_output_iterator<_Iter> && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;
    template <typename _Sent, typename _Iter> constexpr bool disable_sized_sentinel_for = false;
    template <typename _Sent, typename _Iter> concept sized_sentinel_for = sentinel_for<_Sent, _Iter> && !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>> && requires (const _Iter &__i, const _Sent &__s) { { __s - __i } -> same_as<iter_difference_t<_Iter>>; { __i - __s } -> same_as<iter_difference_t<_Iter>>; };
    template <typename _Iter> concept input_iterator = input_or_output_iterator<_Iter> && indirectly_readable<_Iter> && requires { typename __detail::__iter_concept<_Iter>; } && derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;
    template <typename _Iter, typename _Tp> concept output_iterator = input_or_output_iterator<_Iter> && indirectly_writable<_Iter, _Tp> && requires (_Iter __i, _Tp &&__t) { *__i++ = std::forward<_Tp>(__t); };
    template <typename _Iter> concept forward_iterator = input_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, forward_iterator_tag> && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;
    template <typename _Iter> concept bidirectional_iterator = forward_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, bidirectional_iterator_tag> && requires (_Iter __i) { { --__i } -> same_as<_Iter &>; { __i-- } -> same_as<_Iter>; };
    template <typename _Iter> concept random_access_iterator = bidirectional_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, random_access_iterator_tag> && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter> && requires (_Iter __i, const _Iter __j, const iter_difference_t<_Iter> __n) { { __i += __n } -> same_as<_Iter &>; { __j + __n } -> same_as<_Iter>; { __n + __j } -> same_as<_Iter>; { __i -= __n } -> same_as<_Iter &>; { __j - __n } -> same_as<_Iter>; { __j[__n] } -> same_as<iter_reference_t<_Iter>>; };
    template <typename _Iter> concept contiguous_iterator = random_access_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, contiguous_iterator_tag> && is_lvalue_reference_v<iter_reference_t<_Iter>> && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>> && requires (const _Iter &__i) { { std::to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_Iter>>>; };
    template <typename _Fn, typename _Iter> concept indirectly_unary_invocable = indirectly_readable<_Iter> && copy_constructible<_Fn> && invocable<_Fn &, iter_value_t<_Iter> &> && invocable<_Fn &, iter_reference_t<_Iter>> && invocable<_Fn &, iter_common_reference_t<_Iter>> && common_reference_with<invoke_result_t<_Fn &, iter_value_t<_Iter> &>, invoke_result_t<_Fn &, iter_reference_t<_Iter>>>;
    template <typename _Fn, typename _Iter> concept indirectly_regular_unary_invocable = indirectly_readable<_Iter> && copy_constructible<_Fn> && regular_invocable<_Fn &, iter_value_t<_Iter> &> && regular_invocable<_Fn &, iter_reference_t<_Iter>> && regular_invocable<_Fn &, iter_common_reference_t<_Iter>> && common_reference_with<invoke_result_t<_Fn &, iter_value_t<_Iter> &>, invoke_result_t<_Fn &, iter_reference_t<_Iter>>>;
    template <typename _Fn, typename _Iter> concept indirect_unary_predicate = indirectly_readable<_Iter> && copy_constructible<_Fn> && predicate<_Fn &, iter_value_t<_Iter> &> && predicate<_Fn &, iter_reference_t<_Iter>> && predicate<_Fn &, iter_common_reference_t<_Iter>>;
    template <typename _Fn, typename _I1, typename _I2> concept indirect_binary_predicate = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && predicate<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && predicate<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && predicate<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && predicate<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && predicate<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;
    template <typename _Fn, typename _I1, typename _I2 = _I1> concept indirect_equivalence_relation = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && equivalence_relation<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && equivalence_relation<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && equivalence_relation<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && equivalence_relation<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && equivalence_relation<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;
    template <typename _Fn, typename _I1, typename _I2 = _I1> concept indirect_strict_weak_order = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && strict_weak_order<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && strict_weak_order<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && strict_weak_order<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && strict_weak_order<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && strict_weak_order<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;
    template <typename _Fn, typename ..._Is> using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;
    namespace __detail {
        template <typename _Iter, typename _Proj> struct __projected {
            struct __type {
                using value_type = remove_cvref_t<indirect_result_t<_Proj &, _Iter>>;
                indirect_result_t<_Proj &, _Iter> operator*() const;
            };
        };
        template <weakly_incrementable _Iter, typename _Proj> struct __projected<_Iter, _Proj> {
            struct __type {
                using value_type = remove_cvref_t<indirect_result_t<_Proj &, _Iter>>;
                using difference_type = iter_difference_t<_Iter>;
                indirect_result_t<_Proj &, _Iter> operator*() const;
            };
        };
    }
    template <indirectly_readable _Iter, indirectly_regular_unary_invocable<_Iter> _Proj> using projected = typename __detail::__projected<_Iter, _Proj>::__type;
    template <typename _In, typename _Out> concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;
    template <typename _In, typename _Out> concept indirectly_movable_storable = indirectly_movable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>> && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>> && assignable_from<iter_value_t<_In> &, iter_rvalue_reference_t<_In>>;
    template <typename _In, typename _Out> concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;
    template <typename _In, typename _Out> concept indirectly_copyable_storable = indirectly_copyable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In> &> && indirectly_writable<_Out, const iter_value_t<_In> &> && indirectly_writable<_Out, iter_value_t<_In> &&> && indirectly_writable<_Out, const iter_value_t<_In> &&> && copyable<iter_value_t<_In>> && constructible_from<iter_value_t<_In>, iter_reference_t<_In>> && assignable_from<iter_value_t<_In> &, iter_reference_t<_In>>;
    namespace ranges {
        namespace __cust_iswap {
            template <typename _It1, typename _It2> void iter_swap(_It1, _It2) = delete
            template <typename _Tp, typename _Up> concept __adl_iswap = (std::__detail::__class_or_enum<remove_reference_t<_Tp>> || std::__detail::__class_or_enum<remove_reference_t<_Up>>) && requires (_Tp &&__t, _Up &&__u) { iter_swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); };
            template <typename _Xp, typename _Yp> constexpr iter_value_t<_Xp> __iter_exchange_move(_Xp &&__x, _Yp &&__y) noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x))) && noexcept(*__x = iter_move(__y))) {
                iter_value_t<_Xp> __old_value(iter_move(__x));
                *__x = iter_move(__y);
                return __old_value;
            }
            struct _IterSwap {
            private:
                template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
                    if (__adl_iswap<_Tp, _Up>)
                        return noexcept(iter_swap(std::declval<_Tp>(), std::declval<_Up>()));
                    else if (indirectly_readable<_Tp> && indirectly_readable<_Up> && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
                        return noexcept(ranges::swap(*std::declval<_Tp>(), *std::declval<_Up>()));
                    else
                        return noexcept(*std::declval<_Tp>() = __iter_exchange_move(std::declval<_Up>(), std::declval<_Tp>()));
                }
            public:
                template <typename _Tp, typename _Up> constexpr void operator()(_Tp &&__e1, _Up &&__e2) const noexcept(_S_noexcept<_Tp, _Up>()) {
                    if (__adl_iswap<_Tp, _Up>)
                        iter_swap(static_cast<_Tp &&>(__e1), static_cast<_Up &&>(__e2));
                    else if (indirectly_readable<_Tp> && indirectly_readable<_Up> && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
                        ranges::swap(*__e1, *__e2);
                    else
                        *__e1 = __iter_exchange_move(__e2, __e1);
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_iswap::_IterSwap iter_swap{};
        }
    }
    template <typename _I1, typename _I2 = _I1> concept indirectly_swappable = indirectly_readable<_I1> && indirectly_readable<_I2> && requires (const _I1 __i1, const _I2 __i2) { ranges::iter_swap(__i1, __i1); ranges::iter_swap(__i2, __i2); ranges::iter_swap(__i1, __i2); ranges::iter_swap(__i2, __i1); };
    template <typename _I1, typename _I2, typename _Rel, typename _P1 = identity, typename _P2 = identity> concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_I1, _P1>, projected<_I2, _P2>>;
    template <typename _Iter> concept permutable = forward_iterator<_Iter> && indirectly_movable_storable<_Iter, _Iter> && indirectly_swappable<_Iter>;
    template <typename _I1, typename _I2, typename _Out, typename _Rel = ranges::less, typename _P1 = identity, typename _P2 = identity> concept mergeable = input_iterator<_I1> && input_iterator<_I2> && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out> && indirectly_copyable<_I2, _Out> && indirect_strict_weak_order<_Rel, projected<_I1, _P1>, projected<_I2, _P2>>;
    template <typename _Iter, typename _Rel = ranges::less, typename _Proj = identity> concept sortable = permutable<_Iter> && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;
    struct unreachable_sentinel_t {
        friend template <weakly_incrementable _It> constexpr bool operator==(unreachable_sentinel_t, const _It &) noexcept {
            return false;
        }
;
    };
    constexpr unreachable_sentinel_t unreachable_sentinel{};
    namespace ranges {
        namespace __cust_access {
            using std::__detail::__class_or_enum;
            constexpr struct final _Decay_copy final {
                template <typename _Tp> constexpr decay_t<_Tp> operator()(_Tp &&__t) const noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>) {
                    return std::forward<_Tp>(__t);
                }
            } __decay_copy{};
            template <typename _Tp> concept __member_begin = requires (_Tp &__t) { { __decay_copy(__t.begin()) } -> input_or_output_iterator; };
            template <> void begin(auto &) = delete
            template <> void begin(const auto &) = delete
            template <typename _Tp> concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(begin(__t)) } -> input_or_output_iterator; };
            template <typename _Tp> auto __begin(_Tp &__t) {
                if (is_array_v<_Tp>)
                    return __t + 0;
                else if (__member_begin<_Tp &>)
                    return __t.begin();
                else
                    return begin(__t);
            }
        }
    }
    namespace __detail {
        template <typename _Tp> using __range_iter_t = decltype(ranges::__cust_access::__begin(std::declval<_Tp &>()));
    }
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
}
namespace std {
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : public input_iterator_tag {
    };
    struct bidirectional_iterator_tag : public forward_iterator_tag {
    };
    struct random_access_iterator_tag : public bidirectional_iterator_tag {
    };
    struct contiguous_iterator_tag : public random_access_iterator_tag {
    };
    template <typename _Category, typename _Tp, typename _Distance = ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp &> struct [[deprecated("")]] iterator {
        typedef _Category iterator_category;
        typedef _Tp value_type;
        typedef _Distance difference_type;
        typedef _Pointer pointer;
        typedef _Reference reference;
    };
    template<> struct [[deprecated("")]] [[deprecated("")]] iterator<std::output_iterator_tag, void, void, void, void> {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
    };
    template<> struct [[deprecated("")]] [[deprecated("")]] iterator<std::random_access_iterator_tag, bool, long, bool *, bool &> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef bool value_type;
        typedef long difference_type;
        typedef bool *pointer;
        typedef bool &reference;
    };
    template<> struct [[deprecated("")]] [[deprecated("")]] iterator<std::random_access_iterator_tag, bool, long, void, std::_Bit_reference> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef bool value_type;
        typedef long difference_type;
        typedef void pointer;
        typedef std::_Bit_reference reference;
    };
    template<> struct [[deprecated("")]] [[deprecated("")]] iterator<std::random_access_iterator_tag, bool, long, void, bool> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef bool value_type;
        typedef long difference_type;
        typedef void pointer;
        typedef bool reference;
    };
    template <typename _Iterator> struct iterator_traits
    template<> struct iterator_traits<const char *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    }
    template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    }
    template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    }
    template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    }
    template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    }
    template<> struct iterator_traits<std::_Bit_iterator> : public __iterator_traits<_Bit_iterator> {
    }
    template<> struct iterator_traits<std::_Bit_const_iterator> : public __iterator_traits<_Bit_const_iterator> {
    }
    template<> struct iterator_traits<unsigned long *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<unsigned long>;
        using difference_type = ptrdiff_t;
        using pointer = unsigned long *;
        using reference = unsigned long &;
    }
    template<> struct iterator_traits<const int *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const int>;
        using difference_type = ptrdiff_t;
        using pointer = const int *;
        using reference = const int &;
    }
    template<> struct iterator_traits<int *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<int>;
        using difference_type = ptrdiff_t;
        using pointer = int *;
        using reference = int &;
    }
    template<> struct iterator_traits<char *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    }
    template<> struct iterator_traits<Base<ChildA, ChildB, ChildC> *const *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<Base<ChildA, ChildB, ChildC> *const>;
        using difference_type = ptrdiff_t;
        using pointer = Base<ChildA, ChildB, ChildC> *const *;
        using reference = Base<ChildA, ChildB, ChildC> *const &;
    }
    template<> struct iterator_traits<Base<ChildA, ChildB, ChildC> **> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<Base<ChildA, ChildB, ChildC> *>;
        using difference_type = ptrdiff_t;
        using pointer = Base<ChildA, ChildB, ChildC> **;
        using reference = Base<ChildA, ChildB, ChildC> *&;
    }
    template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    }
    template<> struct iterator_traits<char8_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char8_t>;
        using difference_type = ptrdiff_t;
        using pointer = char8_t *;
        using reference = char8_t &;
    }
    template<> struct iterator_traits<char16_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char16_t>;
        using difference_type = ptrdiff_t;
        using pointer = char16_t *;
        using reference = char16_t &;
    }
    template<> struct iterator_traits<char32_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char32_t>;
        using difference_type = ptrdiff_t;
        using pointer = char32_t *;
        using reference = char32_t &;
    };
    template <typename _Iterator, typename = __void_t<>> struct __iterator_traits {
    };
    template<> struct __iterator_traits<std::_Bit_iterator, void> {
    private:
        template <typename _Iter> struct __ptr
        template<> struct __ptr<std::_Bit_iterator> {
            using type = typename _Bit_iterator::pointer;
        };
    public:
        using iterator_category = typename _Bit_iterator::iterator_category;
        using value_type = typename _Bit_iterator::value_type;
        using difference_type = typename _Bit_iterator::difference_type;
        using pointer = typename __ptr<_Bit_iterator>::type;
        using reference = typename _Bit_iterator::reference;
    };
    template<> struct __iterator_traits<std::_Bit_const_iterator, void> {
    private:
        template <typename _Iter> struct __ptr
        template<> struct __ptr<std::_Bit_const_iterator> {
            using type = typename _Bit_const_iterator::pointer;
        };
    public:
        using iterator_category = typename _Bit_const_iterator::iterator_category;
        using value_type = typename _Bit_const_iterator::value_type;
        using difference_type = typename _Bit_const_iterator::difference_type;
        using pointer = typename __ptr<_Bit_const_iterator>::type;
        using reference = typename _Bit_const_iterator::reference;
    };
    template <typename _Iterator> struct iterator_traits : public __iterator_traits<_Iterator> {
    };
    template<> struct iterator_traits<const char *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    };
    template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    };
    template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    };
    template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    };
    template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    };
    template<> struct iterator_traits<std::_Bit_iterator> : public __iterator_traits<_Bit_iterator> {
    };
    template<> struct iterator_traits<std::_Bit_const_iterator> : public __iterator_traits<_Bit_const_iterator> {
    };
    template<> struct iterator_traits<unsigned long *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<unsigned long>;
        using difference_type = ptrdiff_t;
        using pointer = unsigned long *;
        using reference = unsigned long &;
    };
    template<> struct iterator_traits<const int *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<const int>;
        using difference_type = ptrdiff_t;
        using pointer = const int *;
        using reference = const int &;
    };
    template<> struct iterator_traits<int *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<int>;
        using difference_type = ptrdiff_t;
        using pointer = int *;
        using reference = int &;
    };
    template<> struct iterator_traits<char *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    };
    template<> struct iterator_traits<Base<ChildA, ChildB, ChildC> *const *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<Base<ChildA, ChildB, ChildC> *const>;
        using difference_type = ptrdiff_t;
        using pointer = Base<ChildA, ChildB, ChildC> *const *;
        using reference = Base<ChildA, ChildB, ChildC> *const &;
    };
    template<> struct iterator_traits<Base<ChildA, ChildB, ChildC> **> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<Base<ChildA, ChildB, ChildC> *>;
        using difference_type = ptrdiff_t;
        using pointer = Base<ChildA, ChildB, ChildC> **;
        using reference = Base<ChildA, ChildB, ChildC> *&;
    };
    template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    };
    template<> struct iterator_traits<char8_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char8_t>;
        using difference_type = ptrdiff_t;
        using pointer = char8_t *;
        using reference = char8_t &;
    };
    template<> struct iterator_traits<char16_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char16_t>;
        using difference_type = ptrdiff_t;
        using pointer = char16_t *;
        using reference = char16_t &;
    };
    template<> struct iterator_traits<char32_t *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<char32_t>;
        using difference_type = ptrdiff_t;
        using pointer = char32_t *;
        using reference = char32_t &;
    };
    template <typename _Tp> struct iterator_traits<_Tp *> {
        using iterator_concept = contiguous_iterator_tag;
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<_Tp>;
        using difference_type = ptrdiff_t;
        using pointer = _Tp *;
        using reference = _Tp &;
    };
    template <typename _Iter> inline constexpr typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &) __attribute__((always_inline)) {
        return typename iterator_traits<_Iter>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const int *>::iterator_category __iterator_category<const int *>(const int *const &) __attribute__((always_inline)) {
        return typename iterator_traits<const int *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char *>::iterator_category __iterator_category<const char *>(const char *const &) __attribute__((always_inline)) {
        return typename iterator_traits<const char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<Base<ChildA, ChildB, ChildC> *const *>::iterator_category __iterator_category<Base<ChildA, ChildB, ChildC> *const *>(Base<ChildA, ChildB, ChildC> *const *const &) __attribute__((always_inline)) {
        return typename iterator_traits<Base<ChildA, ChildB, ChildC> *const *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<char *>::iterator_category __iterator_category<char *>(char *const &) __attribute__((always_inline)) {
        return typename iterator_traits<char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::iterator_category __iterator_category<wchar_t *>(wchar_t *const &) __attribute__((always_inline)) {
        return typename iterator_traits<wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::iterator_category __iterator_category<const wchar_t *>(const wchar_t *const &) __attribute__((always_inline)) {
        return typename iterator_traits<const wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char8_t *>::iterator_category __iterator_category<const char8_t *>(const char8_t *const &) __attribute__((always_inline)) {
        return typename iterator_traits<const char8_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::iterator_category __iterator_category<const char16_t *>(const char16_t *const &) __attribute__((always_inline)) {
        return typename iterator_traits<const char16_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::iterator_category __iterator_category<const char32_t *>(const char32_t *const &) __attribute__((always_inline)) {
        return typename iterator_traits<const char32_t *>::iterator_category();
    }
    template <typename _Iter> using __iterator_category_t = typename iterator_traits<_Iter>::iterator_category;
    template <typename _InIter> using _RequireInputIter = __enable_if_t<is_convertible<__iterator_category_t<_InIter>, input_iterator_tag>::value>;
    template <typename _It, typename _Cat = __iterator_category_t<_It>> struct __is_random_access_iter : is_base_of<random_access_iterator_tag, _Cat> {
        typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
        enum {
            __value = _Base::value
        };
    };
}
namespace std {
    template <typename> struct _List_iterator;
    template <typename> struct _List_const_iterator;
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, input_iterator_tag) {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        while (__first != __last)
            {
                ++__first;
                ++__n;
            }
        return __n;
    }
    template<> inline constexpr typename iterator_traits<const int *>::difference_type __distance<const int *>(const int *__first, const int *__last, input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char *>::difference_type __distance<const char *>(const char *__first, const char *__last, input_iterator_tag)    template<> inline constexpr typename iterator_traits<Base<ChildA, ChildB, ChildC> *const *>::difference_type __distance<Base<ChildA, ChildB, ChildC> *const *>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, input_iterator_tag)    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, input_iterator_tag)    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, input_iterator_tag)    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type __distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last, input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char8_t *>::difference_type __distance<const char8_t *>(const char8_t *__first, const char8_t *__last, input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type __distance<const char16_t *>(const char16_t *__first, const char16_t *__last, input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type __distance<const char32_t *>(const char32_t *__first, const char32_t *__last, input_iterator_tag)    template <typename _RandomAccessIterator> inline constexpr typename iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const int *>::difference_type __distance<const int *>(const int *__first, const int *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char *>::difference_type __distance<const char *>(const char *__first, const char *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<Base<ChildA, ChildB, ChildC> *const *>::difference_type __distance<Base<ChildA, ChildB, ChildC> *const *>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type __distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char8_t *>::difference_type __distance<const char8_t *>(const char8_t *__first, const char8_t *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type __distance<const char16_t *>(const char16_t *__first, const char16_t *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type __distance<const char32_t *>(const char32_t *__first, const char32_t *__last, random_access_iterator_tag) __attribute__((always_inline)) {
        return __last - __first;
    }
    template <typename _Tp> ptrdiff_t __distance(std::_List_iterator<_Tp>, std::_List_iterator<_Tp>, input_iterator_tag);
    template <typename _Tp> ptrdiff_t __distance(std::_List_const_iterator<_Tp>, std::_List_const_iterator<_Tp>, input_iterator_tag);
    template <typename _OutputIterator> void __distance(_OutputIterator, _OutputIterator, output_iterator_tag) = delete
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const int *>::difference_type distance<const int *>(const int *__first, const int *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const char *>::difference_type distance<const char *>(const char *__first, const char *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<Base<ChildA, ChildB, ChildC> *const *>::difference_type distance<Base<ChildA, ChildB, ChildC> *const *>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type distance<char *>(char *__first, char *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type distance<wchar_t *>(wchar_t *__first, wchar_t *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const char8_t *>::difference_type distance<const char8_t *>(const char8_t *__first, const char8_t *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type distance<const char16_t *>(const char16_t *__first, const char16_t *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type distance<const char32_t *>(const char32_t *__first, const char32_t *__last) [[nodiscard("")]] __attribute__((always_inline)) {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Distance> inline constexpr void __advance(_InputIterator &__i, _Distance __n, input_iterator_tag) {
        do {
            if (std::__is_constant_evaluated() && !bool(__n >= 0))
                __builtin_unreachable();
        } while (false);
        while (__n--)
            ++__i;
    }
    template <typename _BidirectionalIterator, typename _Distance> inline constexpr void __advance(_BidirectionalIterator &__i, _Distance __n, bidirectional_iterator_tag) {
        if (__n > 0)
            while (__n--)
                ++__i;
        else
            while (__n++)
                --__i;
    }
    template <typename _RandomAccessIterator, typename _Distance> inline constexpr void __advance(_RandomAccessIterator &__i, _Distance __n, random_access_iterator_tag) {
        if (__builtin_constant_p(__n) && __n == 1)
            ++__i;
        else if (__builtin_constant_p(__n) && __n == -1)
            --__i;
        else
            __i += __n;
    }
    template <typename _OutputIterator, typename _Distance> void __advance(_OutputIterator &, _Distance, output_iterator_tag) = delete
    template <typename _InputIterator, typename _Distance> inline constexpr void advance(_InputIterator &__i, _Distance __n) __attribute__((always_inline)) {
        typename iterator_traits<_InputIterator>::difference_type __d = __n;
        std::__advance(__i, __d, std::__iterator_category(__i));
    }
    template <typename _InputIterator> inline constexpr _InputIterator next(_InputIterator __x, typename iterator_traits<_InputIterator>::difference_type __n = 1) [[nodiscard("")]] [[gnu::always_inline]] {
        std::advance(__x, __n);
        return __x;
    }
    template <typename _BidirectionalIterator> inline constexpr _BidirectionalIterator prev(_BidirectionalIterator __x, typename iterator_traits<_BidirectionalIterator>::difference_type __n = 1) [[nodiscard("")]] [[gnu::always_inline]] {
        std::advance(__x, -__n);
        return __x;
    }
}
namespace std {
    template <typename _Tp> inline constexpr void destroy_at(_Tp *__location) {
        if (202002L > 201703L && is_array_v<_Tp>) {
            for (auto &__x : *__location)
                std::destroy_at(std::__addressof(__x));
        } else
            __location->~_Tp();
    }
    template<> inline constexpr void destroy_at<int>(int *__location) {
        if (202002L > 201703L && is_array_v<int>)
            ;
        else
            __location->~int();
    }
    template<> inline constexpr void destroy_at<Base<ChildA, ChildB, ChildC> *>(Base<ChildA, ChildB, ChildC> **__location) {
        if (202002L > 201703L && is_array_v<Base<ChildA, ChildB, ChildC> *>)
            ;
        else
            __location->~Base<ChildA, ChildB, ChildC> *();
    }
    template <typename _Tp, typename ..._Args> constexpr auto construct_at(_Tp *__location, _Args &&...__args) noexcept(noexcept(::new ((void *)0) _Tp(std::declval<_Args>()...))) -> decltype(::new ((void *)0) _Tp(std::declval<_Args>()...)) {
        return ::new ((void *)__location) _Tp(std::forward<_Args>(__args)...);
    }
    template<> constexpr auto construct_at<char, <const char &>>(char *__location, const char &__args) noexcept(noexcept(::new ((void *)0) char(std::declval<const char &>()))) -> decltype(::new ((void *)0) char(std::declval<const char &>())) {
        return ::new ((void *)__location) char(std::forward<const char &>(__args));
    }
    template<> constexpr auto construct_at<char, <char &>>(char *__location, char &__args) noexcept(noexcept(::new ((void *)0) char(std::declval<char &>()))) -> decltype(::new ((void *)0) char(std::declval<char &>())) {
        return ::new ((void *)__location) char(std::forward<char &>(__args));
    }
    template<> constexpr auto construct_at<wchar_t, <const wchar_t &>>(wchar_t *__location, const wchar_t &__args) noexcept(noexcept(::new ((void *)0) wchar_t(std::declval<const wchar_t &>()))) -> decltype(::new ((void *)0) wchar_t(std::declval<const wchar_t &>())) {
        return ::new ((void *)__location) wchar_t(std::forward<const wchar_t &>(__args));
    }
    template<> constexpr auto construct_at<wchar_t, <wchar_t &>>(wchar_t *__location, wchar_t &__args) noexcept(noexcept(::new ((void *)0) wchar_t(std::declval<wchar_t &>()))) -> decltype(::new ((void *)0) wchar_t(std::declval<wchar_t &>())) {
        return ::new ((void *)__location) wchar_t(std::forward<wchar_t &>(__args));
    }
    template<> constexpr auto construct_at<char8_t, <const char8_t &>>(char8_t *__location, const char8_t &__args) noexcept(noexcept(::new ((void *)0) char8_t(std::declval<const char8_t &>()))) -> decltype(::new ((void *)0) char8_t(std::declval<const char8_t &>())) {
        return ::new ((void *)__location) char8_t(std::forward<const char8_t &>(__args));
    }
    template<> constexpr auto construct_at<char8_t, <char8_t &>>(char8_t *__location, char8_t &__args) noexcept(noexcept(::new ((void *)0) char8_t(std::declval<char8_t &>()))) -> decltype(::new ((void *)0) char8_t(std::declval<char8_t &>())) {
        return ::new ((void *)__location) char8_t(std::forward<char8_t &>(__args));
    }
    template<> constexpr auto construct_at<char16_t, <const char16_t &>>(char16_t *__location, const char16_t &__args) noexcept(noexcept(::new ((void *)0) char16_t(std::declval<const char16_t &>()))) -> decltype(::new ((void *)0) char16_t(std::declval<const char16_t &>())) {
        return ::new ((void *)__location) char16_t(std::forward<const char16_t &>(__args));
    }
    template<> constexpr auto construct_at<char32_t, <const char32_t &>>(char32_t *__location, const char32_t &__args) noexcept(noexcept(::new ((void *)0) char32_t(std::declval<const char32_t &>()))) -> decltype(::new ((void *)0) char32_t(std::declval<const char32_t &>())) {
        return ::new ((void *)__location) char32_t(std::forward<const char32_t &>(__args));
    }
    template<> constexpr auto construct_at<int, <const int &>>(int *__location, const int &__args) noexcept(noexcept(::new ((void *)0) int(std::declval<const int &>()))) -> decltype(::new ((void *)0) int(std::declval<const int &>())) {
        return ::new ((void *)__location) int(std::forward<const int &>(__args));
    }
    template<> constexpr auto construct_at<Base<ChildA, ChildB, ChildC> *, <Base<ChildA, ChildB, ChildC> *const &>>(Base<ChildA, ChildB, ChildC> **__location, Base<ChildA, ChildB, ChildC> *const &__args) noexcept(noexcept(::new ((void *)0) Base<ChildA, ChildB, ChildC> *(std::declval<Base<ChildA, ChildB, ChildC> *const &>()))) -> decltype(::new ((void *)0) Base<ChildA, ChildB, ChildC> *(std::declval<Base<ChildA, ChildB, ChildC> *const &>())) {
        return ::new ((void *)__location) Base<ChildA, ChildB, ChildC> *(std::forward<Base<ChildA, ChildB, ChildC> *const &>(__args));
    }
    template <typename _Tp, typename ..._Args> inline constexpr void _Construct(_Tp *__p, _Args &&...__args) {
        if (std::__is_constant_evaluated()) {
            std::construct_at(__p, std::forward<_Args>(__args)...);
            return;
        }
        ::new ((void *)__p) _Tp(std::forward<_Args>(__args)...);
    }
    template<> inline constexpr void _Construct<int, <const int &>>(int *__p, const int &__args) {
        if (std::__is_constant_evaluated()) {
            std::construct_at(__p, std::forward<const int &>(__args));
            return;
        }
        ::new ((void *)__p) int(std::forward<const int &>(__args));
    }
    template<> inline constexpr void _Construct<Base<ChildA, ChildB, ChildC> *, <Base<ChildA, ChildB, ChildC> *const &>>(Base<ChildA, ChildB, ChildC> **__p, Base<ChildA, ChildB, ChildC> *const &__args) {
        if (std::__is_constant_evaluated()) {
            std::construct_at(__p, std::forward<Base<ChildA, ChildB, ChildC> *const &>(__args));
            return;
        }
        ::new ((void *)__p) Base<ChildA, ChildB, ChildC> *(std::forward<Base<ChildA, ChildB, ChildC> *const &>(__args));
    }
    template <typename _T1> inline void _Construct_novalue(_T1 *__p) {
        ::new ((void *)__p) _T1;
    }
    template <typename _ForwardIterator> constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last);
    template <typename _Tp> inline constexpr void _Destroy(_Tp *__pointer) {
        std::destroy_at(__pointer);
    }
    template<> inline constexpr void _Destroy<int>(int *__pointer) {
        std::destroy_at(__pointer);
    }
    template<> inline constexpr void _Destroy<Base<ChildA, ChildB, ChildC> *>(Base<ChildA, ChildB, ChildC> **__pointer) {
        std::destroy_at(__pointer);
    }
    template <bool> struct _Destroy_aux {
        template <typename _ForwardIterator> static constexpr void __destroy(_ForwardIterator __first, _ForwardIterator __last) {
            for (; __first != __last; ++__first)
                std::_Destroy(std::__addressof(*__first));
        }
    };
    template<> struct _Destroy_aux<false> {
        template <typename _ForwardIterator> static constexpr void __destroy(_ForwardIterator __first, _ForwardIterator __last);
        template<> static constexpr void __destroy<int *>(int *__first, int *__last) {
            for (; __first != __last; ++__first)
                std::_Destroy(std::__addressof(*__first));
        }
;
        template<> static constexpr void __destroy<Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> **__first, Base<ChildA, ChildB, ChildC> **__last) {
            for (; __first != __last; ++__first)
                std::_Destroy(std::__addressof(*__first));
        }
;
    };
    template<> struct _Destroy_aux<true> {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator, _ForwardIterator) {
        }
        template<> static void __destroy<int *>(int *, int *) {
        }
        template<> static void __destroy<Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> **, Base<ChildA, ChildB, ChildC> **) {
        }
    };
    template <typename _ForwardIterator> inline constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        if (std::__is_constant_evaluated())
            return std::_Destroy_aux<false>::__destroy(__first, __last);
        std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
    }
    template<> inline constexpr void _Destroy<int *>(int *__first, int *__last) {
        typedef typename iterator_traits<int *>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        if (std::__is_constant_evaluated())
            return std::_Destroy_aux<false>::__destroy(__first, __last);
        std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
    }
    template<> inline constexpr void _Destroy<Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> **__first, Base<ChildA, ChildB, ChildC> **__last) {
        typedef typename iterator_traits<Base<ChildA, ChildB, ChildC> **>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        if (std::__is_constant_evaluated())
            return std::_Destroy_aux<false>::__destroy(__first, __last);
        std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
    }
    template <bool> struct _Destroy_n_aux {
        template <typename _ForwardIterator, typename _Size> static constexpr _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count) {
            for (; __count > 0; (void)++__first , --__count)
                std::_Destroy(std::__addressof(*__first));
            return __first;
        }
    };
    template<> struct _Destroy_n_aux<false> {
        template <typename _ForwardIterator, typename _Size> static constexpr _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count);
    };
    template<> struct _Destroy_n_aux<true> {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count) {
            std::advance(__first, __count);
            return __first;
        }
    };
    template <typename _ForwardIterator, typename _Size> inline constexpr _ForwardIterator _Destroy_n(_ForwardIterator __first, _Size __count) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        if (std::__is_constant_evaluated())
            return std::_Destroy_n_aux<false>::__destroy_n(__first, __count);
        return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::__destroy_n(__first, __count);
    }
    template <typename _ForwardIterator> inline constexpr void destroy(_ForwardIterator __first, _ForwardIterator __last) {
        std::_Destroy(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline constexpr _ForwardIterator destroy_n(_ForwardIterator __first, _Size __count) {
        return std::_Destroy_n(__first, __count);
    }
}
namespace __gnu_cxx {
    template <typename _CharT> struct _Char_types {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template<> struct _Char_types<char> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template<> struct _Char_types<wchar_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template<> struct _Char_types<char8_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template<> struct _Char_types<char16_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template<> struct _Char_types<char32_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template <typename _CharT> struct char_traits {
        typedef _CharT char_type;
        typedef typename _Char_types<_CharT>::int_type int_type;
        typedef typename _Char_types<_CharT>::pos_type pos_type;
        typedef typename _Char_types<_CharT>::off_type off_type;
        typedef typename _Char_types<_CharT>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2) {
            return __c1 < __c2;
        }
        static constexpr int compare(const char_type *__s1, const char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const char_type *__s);
        static constexpr const char_type *find(const char_type *__s, std::size_t __n, const char_type &__a);
        static constexpr char_type *move(char_type *__s1, const char_type *__s2, std::size_t __n);
        static constexpr char_type *copy(char_type *__s1, const char_type *__s2, std::size_t __n);
        static constexpr char_type *assign(char_type *__s, std::size_t __n, char_type __a);
        static constexpr char_type to_char_type(const int_type &__c) {
            return static_cast<char_type>(__c);
        }
        static constexpr int_type to_int_type(const char_type &__c) {
            return static_cast<int_type>(__c);
        }
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) {
            return __c1 == __c2;
        }
        static constexpr int_type eof() {
            return static_cast<int_type>(-1);
        }
        static constexpr int_type not_eof(const int_type &__c) {
            return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type());
        }
    };
    template<> struct char_traits<char> {
        typedef char char_type;
        typedef typename _Char_types<char>::int_type int_type;
        typedef typename _Char_types<char>::pos_type pos_type;
        typedef typename _Char_types<char>::off_type off_type;
        typedef typename _Char_types<char>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2);
        static constexpr int compare(const char_type *__s1, const char_type *__s2, std::size_t __n);
        static constexpr std::size_t char_traits<char>::length(const char_type *__p) {
            std::size_t __i = 0;
            while (!eq(__p[__i], char_type()))
                ++__i;
            return __i;
        }
        static constexpr const char_type *char_traits<char>::find(const char_type *__s, std::size_t __n, const char_type &__a) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr char_type *char_traits<char>::move(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                const auto __end = __s2 + __n - 1;
                bool __overlap = false;
                for (std::size_t __i = 0; __i < __n - 1; ++__i) {
                    if (__s1 + __i == __end) {
                        __overlap = true;
                        break;
                    }
                }
                if (__overlap) {
                    do {
                        --__n;
                        assign(__s1[__n], __s2[__n]);
                    } while (__n > 0);
                } else
                    copy(__s1, __s2, __n);
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *char_traits<char>::copy(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *char_traits<char>::assign(char_type *__s, std::size_t __n, char_type __a) {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s + __i, __a);
                return __s;
            }
            if (sizeof(char) == 1 && __is_trivial(char)) {
                if (__n) {
                    unsigned char __c;
                    __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
                    __builtin_memset(__s, __c, __n);
                }
            }
            return __s;
        }
        static constexpr char_type to_char_type(const int_type &__c);
        static constexpr int_type to_int_type(const char_type &__c);
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2);
        static constexpr int_type eof();
        static constexpr int_type not_eof(const int_type &__c);
    };
    template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef typename _Char_types<wchar_t>::int_type int_type;
        typedef typename _Char_types<wchar_t>::pos_type pos_type;
        typedef typename _Char_types<wchar_t>::off_type off_type;
        typedef typename _Char_types<wchar_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2) {
            return __c1 < __c2;
        }
        static constexpr int char_traits<wchar_t>::compare(const char_type *__s1, const char_type *__s2, std::size_t __n) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<wchar_t>::length(const char_type *__p) {
            std::size_t __i = 0;
            while (!eq(__p[__i], char_type()))
                ++__i;
            return __i;
        }
        static constexpr const char_type *char_traits<wchar_t>::find(const char_type *__s, std::size_t __n, const char_type &__a) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr char_type *char_traits<wchar_t>::move(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                const auto __end = __s2 + __n - 1;
                bool __overlap = false;
                for (std::size_t __i = 0; __i < __n - 1; ++__i) {
                    if (__s1 + __i == __end) {
                        __overlap = true;
                        break;
                    }
                }
                if (__overlap) {
                    do {
                        --__n;
                        assign(__s1[__n], __s2[__n]);
                    } while (__n > 0);
                } else
                    copy(__s1, __s2, __n);
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *char_traits<wchar_t>::copy(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *char_traits<wchar_t>::assign(char_type *__s, std::size_t __n, char_type __a) {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s + __i, __a);
                return __s;
            }
            if (sizeof(wchar_t) == 1 && __is_trivial(wchar_t))
                ;
            else {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    __s[__i] = __a;
            }
            return __s;
        }
        static constexpr char_type to_char_type(const int_type &__c);
        static constexpr int_type to_int_type(const char_type &__c);
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2);
        static constexpr int_type eof();
        static constexpr int_type not_eof(const int_type &__c);
    };
    template<> struct char_traits<char8_t> {
        typedef char8_t char_type;
        typedef typename _Char_types<char8_t>::int_type int_type;
        typedef typename _Char_types<char8_t>::pos_type pos_type;
        typedef typename _Char_types<char8_t>::off_type off_type;
        typedef typename _Char_types<char8_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2) {
            return __c1 < __c2;
        }
        static constexpr int char_traits<char8_t>::compare(const char_type *__s1, const char_type *__s2, std::size_t __n) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<char8_t>::length(const char_type *__p) {
            std::size_t __i = 0;
            while (!eq(__p[__i], char_type()))
                ++__i;
            return __i;
        }
        static constexpr const char_type *char_traits<char8_t>::find(const char_type *__s, std::size_t __n, const char_type &__a) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr char_type *char_traits<char8_t>::move(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                const auto __end = __s2 + __n - 1;
                bool __overlap = false;
                for (std::size_t __i = 0; __i < __n - 1; ++__i) {
                    if (__s1 + __i == __end) {
                        __overlap = true;
                        break;
                    }
                }
                if (__overlap) {
                    do {
                        --__n;
                        assign(__s1[__n], __s2[__n]);
                    } while (__n > 0);
                } else
                    copy(__s1, __s2, __n);
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *char_traits<char8_t>::copy(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *char_traits<char8_t>::assign(char_type *__s, std::size_t __n, char_type __a) {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s + __i, __a);
                return __s;
            }
            if (sizeof(char8_t) == 1 && __is_trivial(char8_t)) {
                if (__n) {
                    unsigned char __c;
                    __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
                    __builtin_memset(__s, __c, __n);
                }
            }
            return __s;
        }
        static constexpr char_type to_char_type(const int_type &__c);
        static constexpr int_type to_int_type(const char_type &__c);
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2);
        static constexpr int_type eof();
        static constexpr int_type not_eof(const int_type &__c);
    };
    template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef typename _Char_types<char16_t>::int_type int_type;
        typedef typename _Char_types<char16_t>::pos_type pos_type;
        typedef typename _Char_types<char16_t>::off_type off_type;
        typedef typename _Char_types<char16_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2);
        static constexpr bool lt(const char_type &__c1, const char_type &__c2);
        static constexpr int compare(const char_type *__s1, const char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const char_type *__s);
        static constexpr const char_type *find(const char_type *__s, std::size_t __n, const char_type &__a);
        static constexpr char_type *char_traits<char16_t>::move(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                const auto __end = __s2 + __n - 1;
                bool __overlap = false;
                for (std::size_t __i = 0; __i < __n - 1; ++__i) {
                    if (__s1 + __i == __end) {
                        __overlap = true;
                        break;
                    }
                }
                if (__overlap) {
                    do {
                        --__n;
                        assign(__s1[__n], __s2[__n]);
                    } while (__n > 0);
                } else
                    copy(__s1, __s2, __n);
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *char_traits<char16_t>::copy(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *assign(char_type *__s, std::size_t __n, char_type __a);
        static constexpr char_type to_char_type(const int_type &__c);
        static constexpr int_type to_int_type(const char_type &__c);
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2);
        static constexpr int_type eof();
        static constexpr int_type not_eof(const int_type &__c);
    };
    template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef typename _Char_types<char32_t>::int_type int_type;
        typedef typename _Char_types<char32_t>::pos_type pos_type;
        typedef typename _Char_types<char32_t>::off_type off_type;
        typedef typename _Char_types<char32_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2);
        static constexpr bool lt(const char_type &__c1, const char_type &__c2);
        static constexpr int compare(const char_type *__s1, const char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const char_type *__s);
        static constexpr const char_type *find(const char_type *__s, std::size_t __n, const char_type &__a);
        static constexpr char_type *char_traits<char32_t>::move(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                const auto __end = __s2 + __n - 1;
                bool __overlap = false;
                for (std::size_t __i = 0; __i < __n - 1; ++__i) {
                    if (__s1 + __i == __end) {
                        __overlap = true;
                        break;
                    }
                }
                if (__overlap) {
                    do {
                        --__n;
                        assign(__s1[__n], __s2[__n]);
                    } while (__n > 0);
                } else
                    copy(__s1, __s2, __n);
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *char_traits<char32_t>::copy(char_type *__s1, const char_type *__s2, std::size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
            return __s1;
        }
        static constexpr char_type *assign(char_type *__s, std::size_t __n, char_type __a);
        static constexpr char_type to_char_type(const int_type &__c);
        static constexpr int_type to_int_type(const char_type &__c);
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2);
        static constexpr int_type eof();
        static constexpr int_type not_eof(const int_type &__c);
    };
    template <typename _CharT> constexpr int char_traits<_CharT>::compare(const char_type *__s1, const char_type *__s2, std::size_t __n) {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (lt(__s1[__i], __s2[__i]))
                return -1;
            else if (lt(__s2[__i], __s1[__i]))
                return 1;
        return 0;
    }
    template <typename _CharT> constexpr std::size_t char_traits<_CharT>::length(const char_type *__p) {
        std::size_t __i = 0;
        while (!eq(__p[__i], char_type()))
            ++__i;
        return __i;
    }
    template <typename _CharT> constexpr const typename char_traits<_CharT>::char_type *char_traits<_CharT>::find(const char_type *__s, std::size_t __n, const char_type &__a) {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (eq(__s[__i], __a))
                return __s + __i;
        return 0;
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(char_type *__s1, const char_type *__s2, std::size_t __n) {
        if (__n == 0)
            return __s1;
        if (std::__is_constant_evaluated()) {
            if (__s1 == __s2)
                return __s1;
            const auto __end = __s2 + __n - 1;
            bool __overlap = false;
            for (std::size_t __i = 0; __i < __n - 1; ++__i) {
                if (__s1 + __i == __end) {
                    __overlap = true;
                    break;
                }
            }
            if (__overlap) {
                do {
                    --__n;
                    assign(__s1[__n], __s2[__n]);
                } while (__n > 0);
            } else
                copy(__s1, __s2, __n);
            return __s1;
        }
        __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
        return __s1;
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(char_type *__s1, const char_type *__s2, std::size_t __n) {
        if (__n == 0)
            return __s1;
        if (std::__is_constant_evaluated()) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                std::construct_at(__s1 + __i, __s2[__i]);
            return __s1;
        }
        __builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
        return __s1;
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::assign(char_type *__s, std::size_t __n, char_type __a) {
        if (std::__is_constant_evaluated()) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                std::construct_at(__s + __i, __a);
            return __s;
        }
        if (sizeof(_CharT) == 1 && __is_trivial(_CharT)) {
            if (__n) {
                unsigned char __c;
                __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
                __builtin_memset(__s, __c, __n);
            }
        } else {
            for (std::size_t __i = 0; __i < __n; ++__i)
                __s[__i] = __a;
        }
        return __s;
    }
}
namespace std {
    template <typename _CharT> struct char_traits : public __gnu_cxx::char_traits<_CharT> {
    };
    template<> struct char_traits<char> {
        typedef char char_type;
        typedef int int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        using comparison_category = strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) noexcept {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }
        static constexpr int compare(const char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated()) {
                for (size_t __i = 0; __i < __n; ++__i)
                    if (lt(__s1[__i], __s2[__i]))
                        return -1;
                    else if (lt(__s2[__i], __s1[__i]))
                        return 1;
                return 0;
            }
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static constexpr size_t length(const char_type *__s) {
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::length(__s);
            return __builtin_strlen(__s);
        }
        static constexpr const char_type *find(const char_type *__s, size_t __n, const char_type &__a) {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static constexpr char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static constexpr char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static constexpr char_type *assign(char_type *__s, size_t __n, char_type __a) {
            if (__n == 0)
                return __s;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr char_type to_char_type(const int_type &__c) noexcept {
            return static_cast<char_type>(__c);
        }
        static constexpr int_type to_int_type(const char_type &__c) noexcept {
            return static_cast<int_type>(static_cast<unsigned char>(__c));
        }
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr int_type eof() noexcept {
            return static_cast<int_type>(-1);
        }
        static constexpr int_type not_eof(const int_type &__c) noexcept {
            return (__c == eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef streamoff off_type;
        typedef wstreampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) noexcept {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 < __c2;
        }
        static constexpr int compare(const char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return wmemcmp(__s1, __s2, __n);
        }
        static constexpr size_t length(const char_type *__s) {
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::length(__s);
            return wcslen(__s);
        }
        static constexpr const char_type *find(const char_type *__s, size_t __n, const char_type &__a) {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return wmemchr(__s, __a, __n);
        }
        static constexpr char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return wmemmove(__s1, __s2, __n);
        }
        static constexpr char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return wmemcpy(__s1, __s2, __n);
        }
        static constexpr char_type *assign(char_type *__s, size_t __n, char_type __a) {
            if (__n == 0)
                return __s;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return wmemset(__s, __a, __n);
        }
        static constexpr char_type to_char_type(const int_type &__c) noexcept {
            return char_type(__c);
        }
        static constexpr int_type to_int_type(const char_type &__c) noexcept {
            return int_type(__c);
        }
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr int_type eof() noexcept {
            return static_cast<int_type>((4294967295U));
        }
        static constexpr int_type not_eof(const int_type &__c) noexcept {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char8_t> {
        typedef char8_t char_type;
        typedef unsigned int int_type;
        typedef u8streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        using comparison_category = strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) noexcept {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 < __c2;
        }
        static constexpr int compare(const char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static constexpr size_t length(const char_type *__s) {
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::length(__s);
            size_t __i = 0;
            while (!eq(__s[__i], char_type()))
                ++__i;
            return __i;
        }
        static constexpr const char_type *find(const char_type *__s, size_t __n, const char_type &__a) {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static constexpr char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static constexpr char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static constexpr char_type *assign(char_type *__s, size_t __n, char_type __a) {
            if (__n == 0)
                return __s;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr char_type to_char_type(const int_type &__c) noexcept {
            return char_type(__c);
        }
        static constexpr int_type to_int_type(const char_type &__c) noexcept {
            return int_type(__c);
        }
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr int_type eof() noexcept {
            return static_cast<int_type>(-1);
        }
        static constexpr int_type not_eof(const int_type &__c) noexcept {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
namespace std {
    template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef unsigned short int_type;
        typedef streamoff off_type;
        typedef u16streampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) noexcept {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 < __c2;
        }
        static constexpr int compare(const char_type *__s1, const char_type *__s2, size_t __n) {
            for (size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr size_t length(const char_type *__s) {
            size_t __i = 0;
            while (!eq(__s[__i], char_type()))
                ++__i;
            return __i;
        }
        static constexpr const char_type *find(const char_type *__s, size_t __n, const char_type &__a) {
            for (size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return (static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
        }
        static constexpr char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return (static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
        }
        static constexpr char_type *assign(char_type *__s, size_t __n, char_type __a) {
            for (size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr char_type to_char_type(const int_type &__c) noexcept {
            return char_type(__c);
        }
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr int_type to_int_type(const char_type &__c) noexcept {
            return __c == eof() ? int_type(65533) : int_type(__c);
        }
        static constexpr int_type eof() noexcept {
            return static_cast<int_type>(-1);
        }
        static constexpr int_type not_eof(const int_type &__c) noexcept {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef unsigned int int_type;
        typedef streamoff off_type;
        typedef u32streampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = strong_ordering;
        static constexpr void assign(char_type &__c1, const char_type &__c2) noexcept {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept {
            return __c1 < __c2;
        }
        static constexpr int compare(const char_type *__s1, const char_type *__s2, size_t __n) {
            for (size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr size_t length(const char_type *__s) {
            size_t __i = 0;
            while (!eq(__s[__i], char_type()))
                ++__i;
            return __i;
        }
        static constexpr const char_type *find(const char_type *__s, size_t __n, const char_type &__a) {
            for (size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return (static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
        }
        static constexpr char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return (static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
        }
        static constexpr char_type *assign(char_type *__s, size_t __n, char_type __a) {
            for (size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr char_type to_char_type(const int_type &__c) noexcept {
            return char_type(__c);
        }
        static constexpr int_type to_int_type(const char_type &__c) noexcept {
            return int_type(__c);
        }
        static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept {
            return __c1 == __c2;
        }
        static constexpr int_type eof() noexcept {
            return static_cast<int_type>(-1);
        }
        static constexpr int_type not_eof(const int_type &__c) noexcept {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    namespace __detail {
        template <typename _ChTraits> constexpr auto __char_traits_cmp_cat(int __cmp) noexcept {
            if (requires { typename _ChTraits::comparison_category; }) {
                using _Cat = typename _ChTraits::comparison_category;
                static_assert(!is_void_v<common_comparison_category_t<_Cat>>);
                return static_cast<_Cat>(__cmp <=> 0);
            } else
                return static_cast<weak_ordering>(__cmp <=> 0);
        }
    }
}
extern "C" {
    struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        char int_p_cs_precedes;
        char int_p_sep_by_space;
        char int_n_cs_precedes;
        char int_n_sep_by_space;
        char int_p_sign_posn;
        char int_n_sign_posn;
    };
    extern char *setlocale(int __category, const char *__locale) noexcept(true);
    extern struct lconv *localeconv() noexcept(true);
    extern locale_t newlocale(int __category_mask, const char *__locale, locale_t __base) noexcept(true);
    extern locale_t duplocale(locale_t __dataset) noexcept(true);
    extern void freelocale(locale_t __dataset) noexcept(true);
    extern locale_t uselocale(locale_t __dataset) noexcept(true);
}
namespace std {
    using ::lconv;
    using ::setlocale;
    using ::localeconv;
}
namespace __gnu_cxx {
    extern "C" locale_t __uselocale(locale_t) noexcept(true)
}
namespace std {
    typedef __locale_t __c_locale;
    inline int __convert_from_v(const __c_locale &__cloc __attribute__((unused)), char *__out, const int __size __attribute__((unused)), const char *__fmt, ...) {
        __c_locale __old = __gnu_cxx::__uselocale(__cloc);
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
        __builtin_va_end(__args);
        __gnu_cxx::__uselocale(__old);
        return __ret;
    }
}
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef struct {
    int __val[2];
} __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef long __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
extern "C" {
    enum {
        _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
        _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
        _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
        _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
        _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
        _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
        _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
        _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
        _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
        _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
        _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
        _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
    };
    extern const unsigned short **__ctype_b_loc() noexcept(true) __attribute__((const));
    extern const __int32_t **__ctype_tolower_loc() noexcept(true) __attribute__((const));
    extern const __int32_t **__ctype_toupper_loc() noexcept(true) __attribute__((const));
    extern int isalnum(int) noexcept(true);
    extern int isalpha(int) noexcept(true);
    extern int iscntrl(int) noexcept(true);
    extern int isdigit(int) noexcept(true);
    extern int islower(int) noexcept(true);
    extern int isgraph(int) noexcept(true);
    extern int isprint(int) noexcept(true);
    extern int ispunct(int) noexcept(true);
    extern int isspace(int) noexcept(true);
    extern int isupper(int) noexcept(true);
    extern int isxdigit(int) noexcept(true);
    extern int tolower(int __c) noexcept(true);
    extern int toupper(int __c) noexcept(true);
    extern int isblank(int) noexcept(true);
    extern int isctype(int __c, int __mask) noexcept(true);
    extern int isascii(int __c) noexcept(true);
    extern int toascii(int __c) noexcept(true);
    extern int _toupper(int) noexcept(true);
    extern int _tolower(int) noexcept(true);
    extern int isalnum_l(int, locale_t) noexcept(true);
    extern int isalpha_l(int, locale_t) noexcept(true);
    extern int iscntrl_l(int, locale_t) noexcept(true);
    extern int isdigit_l(int, locale_t) noexcept(true);
    extern int islower_l(int, locale_t) noexcept(true);
    extern int isgraph_l(int, locale_t) noexcept(true);
    extern int isprint_l(int, locale_t) noexcept(true);
    extern int ispunct_l(int, locale_t) noexcept(true);
    extern int isspace_l(int, locale_t) noexcept(true);
    extern int isupper_l(int, locale_t) noexcept(true);
    extern int isxdigit_l(int, locale_t) noexcept(true);
    extern int isblank_l(int, locale_t) noexcept(true);
    extern int __tolower_l(int __c, locale_t __l) noexcept(true);
    extern int tolower_l(int __c, locale_t __l) noexcept(true);
    extern int __toupper_l(int __c, locale_t __l) noexcept(true);
    extern int toupper_l(int __c, locale_t __l) noexcept(true);
}
namespace std {
    using ::isalnum;
    using ::isalpha;
    using ::iscntrl;
    using ::isdigit;
    using ::isgraph;
    using ::islower;
    using ::isprint;
    using ::ispunct;
    using ::isspace;
    using ::isupper;
    using ::isxdigit;
    using ::tolower;
    using ::toupper;
}
namespace std {
    using ::isblank;
}
namespace std {
    class locale;
    template <typename _Facet> bool has_facet(const locale &) throw();
    template <typename _Facet> const _Facet &use_facet(const locale &);
    template <typename _CharT> bool isspace(_CharT, const locale &);
    template <typename _CharT> bool isprint(_CharT, const locale &);
    template <typename _CharT> bool iscntrl(_CharT, const locale &);
    template <typename _CharT> bool isupper(_CharT, const locale &);
    template <typename _CharT> bool islower(_CharT, const locale &);
    template <typename _CharT> bool isalpha(_CharT, const locale &);
    template <typename _CharT> bool isdigit(_CharT, const locale &);
    template <typename _CharT> bool ispunct(_CharT, const locale &);
    template <typename _CharT> bool isxdigit(_CharT, const locale &);
    template <typename _CharT> bool isalnum(_CharT, const locale &);
    template <typename _CharT> bool isgraph(_CharT, const locale &);
    template <typename _CharT> bool isblank(_CharT, const locale &);
    template <typename _CharT> _CharT toupper(_CharT, const locale &);
    template <typename _CharT> _CharT tolower(_CharT, const locale &);
    struct ctype_base;
    template <typename _CharT> class ctype;
    template<> class ctype<char>;
    template<> class ctype<wchar_t>;
    template <typename _CharT> class ctype_byname;
    class codecvt_base;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt;
    template<> class codecvt<char, char, mbstate_t>;
    template<> class codecvt<wchar_t, char, mbstate_t>;
    template<> class codecvt<char16_t, char, mbstate_t>;
    template<> class codecvt<char32_t, char, mbstate_t>;
    template<> class codecvt<char16_t, char8_t, mbstate_t>;
    template<> class codecvt<char32_t, char8_t, mbstate_t>;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt_byname;
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put;
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct;
        template <typename _CharT> class numpunct_byname;
    }
    inline namespace __cxx11 {
        template <typename _CharT> class collate;
        template <typename _CharT> class collate_byname;
    }
    class time_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get;
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get_byname;
    }
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put_byname;
    class money_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class money_get;
        template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class money_put;
    }
    inline namespace __cxx11 {
        template <typename _CharT, bool _Intl = false> class moneypunct;
        template <typename _CharT, bool _Intl = false> class moneypunct_byname;
    }
    struct messages_base;
    inline namespace __cxx11 {
        template <typename _CharT> class messages;
        template <typename _CharT> class messages_byname;
    }
}
typedef unsigned long size_t;
typedef __time_t time_t;
struct timespec {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
};
typedef __pid_t pid_t;
struct sched_param {
    int sched_priority;
};
extern "C" {
    extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) noexcept(true);
    extern int unshare(int __flags) noexcept(true);
    extern int sched_getcpu() noexcept(true);
    extern int getcpu(unsigned int *, unsigned int *) noexcept(true);
    extern int setns(int __fd, int __nstype) noexcept(true);
}
typedef unsigned long __cpu_mask;
typedef struct {
    __cpu_mask __bits[16];
} cpu_set_t;
extern "C" {
    extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp) noexcept(true);
    extern cpu_set_t *__sched_cpualloc(size_t __count) noexcept(true);
    extern void __sched_cpufree(cpu_set_t *__set) noexcept(true);
}
extern "C" {
    extern int sched_setparam(__pid_t __pid, const struct sched_param *__param) noexcept(true);
    extern int sched_getparam(__pid_t __pid, struct sched_param *__param) noexcept(true);
    extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param) noexcept(true);
    extern int sched_getscheduler(__pid_t __pid) noexcept(true);
    extern int sched_yield() noexcept(true);
    extern int sched_get_priority_max(int __algorithm) noexcept(true);
    extern int sched_get_priority_min(int __algorithm) noexcept(true);
    extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t) noexcept(true);
    extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true);
    extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true);
}
typedef unsigned long size_t;
struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};
struct timex {
    unsigned int modes;
    __syscall_slong_t offset;
    __syscall_slong_t freq;
    __syscall_slong_t maxerror;
    __syscall_slong_t esterror;
    int status;
    __syscall_slong_t constant;
    __syscall_slong_t precision;
    __syscall_slong_t tolerance;
    struct timeval time;
    __syscall_slong_t tick;
    __syscall_slong_t ppsfreq;
    __syscall_slong_t jitter;
    int shift;
    __syscall_slong_t stabil;
    __syscall_slong_t jitcnt;
    __syscall_slong_t calcnt;
    __syscall_slong_t errcnt;
    __syscall_slong_t stbcnt;
    int tai;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
};
extern "C" {
    extern int clock_adjtime(__clockid_t __clock_id, struct timex *__utx) noexcept(true) __attribute__((nonnull(2)));
}
typedef __clock_t clock_t;
struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    const char *tm_zone;
};
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};
struct sigevent;
extern "C" {
    extern clock_t clock() noexcept(true);
    extern time_t time(time_t *__timer) noexcept(true);
    extern double difftime(time_t __time1, time_t __time0) noexcept(true) __attribute__((const));
    extern time_t mktime(struct tm *__tp) noexcept(true);
    extern size_t strftime(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp) noexcept(true) __attribute__((nonnull(1, 3, 4)));
    extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp) noexcept(true);
    extern size_t strftime_l(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) noexcept(true);
    extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp, locale_t __loc) noexcept(true);
    extern struct tm *gmtime(const time_t *__timer) noexcept(true);
    extern struct tm *localtime(const time_t *__timer) noexcept(true);
    extern struct tm *gmtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) noexcept(true);
    extern struct tm *localtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) noexcept(true);
    extern char *asctime(const struct tm *__tp) noexcept(true);
    extern char *ctime(const time_t *__timer) noexcept(true);
    extern char *asctime_r(const struct tm *__restrict __tp, char *__restrict __buf) noexcept(true);
    extern char *ctime_r(const time_t *__restrict __timer, char *__restrict __buf) noexcept(true);
    extern char *__tzname[2];
    extern int __daylight;
    extern long __timezone;
    extern char *tzname[2];
    extern void tzset() noexcept(true);
    extern int daylight;
    extern long timezone;
    extern time_t timegm(struct tm *__tp) noexcept(true);
    extern time_t timelocal(struct tm *__tp) noexcept(true);
    extern int dysize(int __year) noexcept(true) __attribute__((const));
    extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining);
    extern int clock_getres(clockid_t __clock_id, struct timespec *__res) noexcept(true);
    extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp) noexcept(true) __attribute__((nonnull(2)));
    extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp) noexcept(true) __attribute__((nonnull(2)));
    extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem);
    extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id) noexcept(true);
    extern int timer_create(clockid_t __clock_id, struct sigevent *__restrict __evp, timer_t *__restrict __timerid) noexcept(true);
    extern int timer_delete(timer_t __timerid) noexcept(true);
    extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *__restrict __value, struct itimerspec *__restrict __ovalue) noexcept(true);
    extern int timer_gettime(timer_t __timerid, struct itimerspec *__value) noexcept(true);
    extern int timer_getoverrun(timer_t __timerid) noexcept(true);
    extern int timespec_get(struct timespec *__ts, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern int timespec_getres(struct timespec *__ts, int __base) noexcept(true);
    extern int getdate_err;
    extern struct tm *getdate(const char *__string);
    extern int getdate_r(const char *__restrict __string, struct tm *__restrict __resbufp);
}
typedef union {
    unsigned long long __value64;
    struct {
        unsigned int __low;
        unsigned int __high;
    } __value32;
} __atomic_wide_counter;
typedef struct __pthread_internal_list {
    struct __pthread_internal_list *__prev;
    struct __pthread_internal_list *__next;
} __pthread_list_t;
typedef struct __pthread_internal_slist {
    struct __pthread_internal_slist *__next;
} __pthread_slist_t;
struct __pthread_mutex_s {
    int __lock;
    unsigned int __count;
    int __owner;
    unsigned int __nusers;
    int __kind;
    short __spins;
    short __elision;
    __pthread_list_t __list;
};
struct __pthread_rwlock_arch_t {
    unsigned int __readers;
    unsigned int __writers;
    unsigned int __wrphase_futex;
    unsigned int __writers_futex;
    unsigned int __pad3;
    unsigned int __pad4;
    int __cur_writer;
    int __shared;
    signed char __rwelision;
    unsigned char __pad1[7];
    unsigned long __pad2;
    unsigned int __flags;
};
struct __pthread_cond_s {
    __atomic_wide_counter __wseq;
    __atomic_wide_counter __g1_start;
    unsigned int __g_refs[2];
    unsigned int __g_size[2];
    unsigned int __g1_orig_size;
    unsigned int __wrefs;
    unsigned int __g_signals[2];
};
typedef unsigned int __tss_t;
typedef unsigned long __thrd_t;
typedef struct {
    int __data;
} __once_flag;
typedef unsigned long pthread_t;
typedef union {
    char __size[4];
    int __align;
} pthread_mutexattr_t;
typedef union {
    char __size[4];
    int __align;
} pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union pthread_attr_t {
    char __size[56];
    long __align;
};
typedef union pthread_attr_t pthread_attr_t;
typedef union {
    struct __pthread_mutex_s __data;
    char __size[40];
    long __align;
} pthread_mutex_t;
typedef union {
    struct __pthread_cond_s __data;
    char __size[48];
    long long __align;
} pthread_cond_t;
typedef union {
    struct __pthread_rwlock_arch_t __data;
    char __size[56];
    long __align;
} pthread_rwlock_t;
typedef union {
    char __size[8];
    long __align;
} pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union {
    char __size[32];
    long __align;
} pthread_barrier_t;
typedef union {
    char __size[4];
    int __align;
} pthread_barrierattr_t;
typedef long __jmp_buf[8];
typedef struct {
    unsigned long __val[16];
} __sigset_t;
struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
};
extern "C" {
    extern long __sysconf(int __name) noexcept(true);
}
enum {
    PTHREAD_CREATE_JOINABLE,
    PTHREAD_CREATE_DETACHED
};
enum {
    PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP,
    PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL,
    PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
};
enum {
    PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_ROBUST,
    PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};
enum {
    PTHREAD_PRIO_NONE,
    PTHREAD_PRIO_INHERIT,
    PTHREAD_PRIO_PROTECT
};
enum {
    PTHREAD_RWLOCK_PREFER_READER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum {
    PTHREAD_INHERIT_SCHED,
    PTHREAD_EXPLICIT_SCHED
};
enum {
    PTHREAD_SCOPE_SYSTEM,
    PTHREAD_SCOPE_PROCESS
};
enum {
    PTHREAD_PROCESS_PRIVATE,
    PTHREAD_PROCESS_SHARED
};
struct _pthread_cleanup_buffer {
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
enum {
    PTHREAD_CANCEL_ENABLE,
    PTHREAD_CANCEL_DISABLE
};
enum {
    PTHREAD_CANCEL_DEFERRED,
    PTHREAD_CANCEL_ASYNCHRONOUS
};
extern "C" {
    extern int pthread_create(pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) noexcept(true) __attribute__((nonnull(1, 3)));
    extern void pthread_exit(void *__retval);
    extern int pthread_join(pthread_t __th, void **__thread_return);
    extern int pthread_tryjoin_np(pthread_t __th, void **__thread_return) noexcept(true);
    extern int pthread_timedjoin_np(pthread_t __th, void **__thread_return, const struct timespec *__abstime);
    extern int pthread_clockjoin_np(pthread_t __th, void **__thread_return, clockid_t __clockid, const struct timespec *__abstime);
    extern int pthread_detach(pthread_t __th) noexcept(true);
    extern pthread_t pthread_self() noexcept(true) __attribute__((const));
    extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) noexcept(true) __attribute__((const));
    extern int pthread_attr_init(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_destroy(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict __attr, struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedparam(pthread_attr_t *__restrict __attr, const struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict __attr, int *__restrict __policy) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict __attr, int *__restrict __inherit) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getscope(const pthread_attr_t *__restrict __attr, int *__restrict __scope) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) noexcept(true) __attribute__((nonnull(1, 2))) __attribute__((deprecated("")));
    extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr) noexcept(true) __attribute__((nonnull(1))) __attribute__((deprecated("")));
    extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict __attr, size_t *__restrict __stacksize) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getstack(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, size_t *__restrict __stacksize) noexcept(true) __attribute__((nonnull(1, 2, 3)));
    extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_setaffinity_np(pthread_attr_t *__attr, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_attr_getaffinity_np(const pthread_attr_t *__attr, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_getattr_default_np(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr, const __sigset_t *sigmask);
    extern int pthread_attr_getsigmask_np(const pthread_attr_t *__attr, __sigset_t *sigmask);
    extern int pthread_setattr_default_np(const pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_getattr_np(pthread_t __th, pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict __policy, struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(2, 3)));
    extern int pthread_setschedprio(pthread_t __target_thread, int __prio) noexcept(true);
    extern int pthread_getname_np(pthread_t __target_thread, char *__buf, size_t __buflen) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_setname_np(pthread_t __target_thread, const char *__name) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_getconcurrency() noexcept(true);
    extern int pthread_setconcurrency(int __level) noexcept(true);
    extern int pthread_yield() noexcept(true);
    extern int pthread_yield() noexcept(true) asm("sched_yield") __attribute__((deprecated("pthread_yield is deprecated, use sched_yield instead")));
    extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((nonnull(1, 2)));
    extern int pthread_setcancelstate(int __state, int *__oldstate);
    extern int pthread_setcanceltype(int __type, int *__oldtype);
    extern int pthread_cancel(pthread_t __th);
    extern void pthread_testcancel();
    struct __cancel_jmp_buf_tag {
        __jmp_buf __cancel_jmp_buf;
        int __mask_was_saved;
    };
    typedef struct {
        struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
        void *__pad[4];
    } __pthread_unwind_buf_t __attribute__((aligned));
    struct __pthread_cleanup_frame {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    };
    class __pthread_cleanup_class {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    public:
        __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1) {
        }
        ~__pthread_cleanup_class() noexcept {
            if (this->__do_it)
                this->__cancel_routine(this->__cancel_arg);
        }
        void __setdoit(int __newval) {
            this->__do_it = __newval;
        }
        void __defer() {
            pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &this->__cancel_type);
        }
        void __restore() const {
            pthread_setcanceltype(this->__cancel_type, 0);
        }
    };
    extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask) noexcept(true);
    extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_destroy(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_trylock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_lock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_clocklock(pthread_mutex_t *__restrict __mutex, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_unlock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_consistent(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_consistent_np(pthread_mutex_t *) noexcept(true) asm("pthread_mutex_consistent") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")));
    extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_getrobust_np(pthread_mutexattr_t *, int *) noexcept(true) asm("pthread_mutexattr_getrobust") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")));
    extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *, int) noexcept(true) asm("pthread_mutexattr_setrobust") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")));
    extern int pthread_rwlock_init(pthread_rwlock_t *__restrict __rwlock, const pthread_rwlockattr_t *__restrict __attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_clockrdlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_clockwrlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_init(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_destroy(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_signal(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_broadcast(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_wait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __attribute__((nonnull(1, 2)));
    extern int pthread_cond_timedwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 3)));
    extern int pthread_cond_clockwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, __clockid_t __clock_id, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 4)));
    extern int pthread_condattr_init(pthread_condattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_destroy(pthread_condattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict __attr, __clockid_t *__restrict __clock_id) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_destroy(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_lock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_trylock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_unlock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_init(pthread_barrier_t *__restrict __barrier, const pthread_barrierattr_t *__restrict __attr, unsigned int __count) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_destroy(pthread_barrier_t *__barrier) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_wait(pthread_barrier_t *__barrier) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *)) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_key_delete(pthread_key_t __key) noexcept(true);
    extern void *pthread_getspecific(pthread_key_t __key) noexcept(true);
    extern int pthread_setspecific(pthread_key_t __key, const void *__pointer) noexcept(true);
    extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) noexcept(true);
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static inline int __gthread_active_p() {
    return 1;
}
static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *__args) {
    return pthread_create(__threadid, __null, __func, __args);
}
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) {
    return pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(__gthread_t __threadid) {
    return pthread_detach(__threadid);
}
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) {
    return pthread_equal(__t1, __t2);
}
static inline __gthread_t __gthread_self() {
    return pthread_self();
}
static inline int __gthread_yield() {
    return sched_yield();
}
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)()) {
    if (__gthread_active_p())
        return pthread_once(__once, __func);
    else
        return -1;
}
static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) {
    return pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(__gthread_key_t __key) {
    return pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(__gthread_key_t __key) {
    return pthread_getspecific(__key);
}
static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) {
    return pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        pthread_mutex_init(__mutex, __null);
}
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_destroy(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_lock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_trylock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    if (__gthread_active_p())
        return pthread_mutex_timedlock(__mutex, __abs_timeout);
    else
        return 0;
}
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_unlock(__mutex);
    else
        return 0;
}
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_unlock(__mutex);
}
static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) {
    return pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(__gthread_cond_t *__cond) {
    return pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) {
    return pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *__mutex) {
    return __gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) {
    return pthread_cond_destroy(__cond);
}
typedef int _Atomic_word;
extern "C" {
    extern char __libc_single_threaded;
}
namespace __gnu_cxx {
    inline bool __is_single_threaded() noexcept __attribute__((always_inline)) {
        return ::__libc_single_threaded;
    }
    inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        return __atomic_fetch_add(__mem, __val, 4);
    }
    inline void __atomic_add(volatile _Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        __atomic_fetch_add(__mem, __val, 4);
    }
    inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        _Atomic_word __result = *__mem;
        *__mem += __val;
        return __result;
    }
    inline void __atomic_add_single(_Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        *__mem += __val;
    }
    inline _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        if (__is_single_threaded())
            return __exchange_and_add_single(__mem, __val);
        else
            return __exchange_and_add(__mem, __val);
    }
    inline void __atomic_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((always_inline)) {
        if (__is_single_threaded())
            __atomic_add_single(__mem, __val);
        else
            __atomic_add(__mem, __val);
    }
}
namespace std {
    void __throw_bad_exception();
    void __throw_bad_alloc();
    void __throw_bad_array_new_length();
    void __throw_bad_cast();
    void __throw_bad_typeid();
    void __throw_logic_error(const char *);
    void __throw_domain_error(const char *);
    void __throw_invalid_argument(const char *);
    void __throw_length_error(const char *);
    void __throw_out_of_range(const char *);
    void __throw_out_of_range_fmt(const char *, ...);
    void __throw_runtime_error(const char *);
    void __throw_range_error(const char *);
    void __throw_overflow_error(const char *);
    void __throw_underflow_error(const char *);
    void __throw_ios_failure(const char *);
    void __throw_ios_failure(const char *, int);
    void __throw_system_error(int);
    void __throw_future_error(int);
    void __throw_bad_function_call();
}
namespace std {
    template <typename _Tp> class __new_allocator {
    public:
        typedef _Tp value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator<_Tp>() noexcept __attribute__((always_inline)) {
        }
        constexpr __new_allocator<_Tp>(const __new_allocator<_Tp> &) noexcept __attribute__((always_inline)) {
        }
        template <typename _Tp1> constexpr __new_allocator<_Tp>(const __new_allocator<_Tp1> &) noexcept __attribute__((always_inline)) {
        }
        _Tp *allocate(size_type __n, const void * = static_cast<const void *>(0)) [[nodiscard("")]] {
            static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(_Tp)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(_Tp) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(_Tp));
                return static_cast<_Tp *>(__builtin_operator_new(__n * sizeof(_Tp), __al));
            }
            return static_cast<_Tp *>(__builtin_operator_new(__n * sizeof(_Tp)));
        }
        void deallocate(_Tp *__p, size_type __n __attribute__((unused))) {
            if (alignof(_Tp) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(_Tp)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<_Tp> &, const __new_allocator<_Up> &) noexcept __attribute__((always_inline)) {
            return true;
        }
;
    private:
        constexpr size_type _M_max_size() const noexcept __attribute__((always_inline)) {
            return std::size_t(9223372036854775807L) / sizeof(_Tp);
        }
    };
    template<> class __new_allocator<char> {
    public:
        typedef char value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept __attribute__((always_inline)) {
        }
        constexpr __new_allocator(const __new_allocator<char> &) noexcept __attribute__((always_inline)) {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr __new_allocator<char>(const __new_allocator<char> &) noexcept __attribute__((always_inline));
        char *allocate(size_type __n, const void *) [[nodiscard("")]] {
            static_assert(sizeof(char) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(char)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(char) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(char));
                return static_cast<char *>(__builtin_operator_new(__n * sizeof(char), __al));
            }
            return static_cast<char *>(__builtin_operator_new(__n * sizeof(char)));
        }
        void deallocate(char *__p, size_type __n __attribute__((unused))) {
            if (alignof(char) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(char)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<char> &, const __new_allocator<_Up> &) noexcept __attribute__((always_inline));
    private:
        constexpr size_type _M_max_size() const noexcept __attribute__((always_inline)) {
            return std::size_t(9223372036854775807L) / sizeof(char);
        }
    };
    template<> class __new_allocator<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept __attribute__((always_inline)) {
        }
        constexpr __new_allocator(const __new_allocator<wchar_t> &) noexcept __attribute__((always_inline)) {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr __new_allocator<wchar_t>(const __new_allocator<wchar_t> &) noexcept __attribute__((always_inline));
        wchar_t *allocate(size_type __n, const void *) [[nodiscard("")]] {
            static_assert(sizeof(wchar_t) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(wchar_t)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(wchar_t) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(wchar_t));
                return static_cast<wchar_t *>(__builtin_operator_new(__n * sizeof(wchar_t), __al));
            }
            return static_cast<wchar_t *>(__builtin_operator_new(__n * sizeof(wchar_t)));
        }
        void deallocate(wchar_t *__p, size_type __n __attribute__((unused))) {
            if (alignof(wchar_t) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(wchar_t)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<wchar_t> &, const __new_allocator<_Up> &) noexcept __attribute__((always_inline));
    private:
        constexpr size_type _M_max_size() const noexcept __attribute__((always_inline)) {
            return std::size_t(9223372036854775807L) / sizeof(wchar_t);
        }
    };
    template<> class __new_allocator<char8_t> {
    public:
        typedef char8_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept __attribute__((always_inline)) {
        }
        constexpr __new_allocator(const __new_allocator<char8_t> &) noexcept __attribute__((always_inline)) {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr __new_allocator<char8_t>(const __new_allocator<char8_t> &) noexcept __attribute__((always_inline));
        char8_t *allocate(size_type __n, const void *) [[nodiscard("")]] {
            static_assert(sizeof(char8_t) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(char8_t)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(char8_t) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(char8_t));
                return static_cast<char8_t *>(__builtin_operator_new(__n * sizeof(char8_t), __al));
            }
            return static_cast<char8_t *>(__builtin_operator_new(__n * sizeof(char8_t)));
        }
        void deallocate(char8_t *__p, size_type __n __attribute__((unused))) {
            if (alignof(char8_t) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(char8_t)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<char8_t> &, const __new_allocator<_Up> &) noexcept __attribute__((always_inline));
    private:
        constexpr size_type _M_max_size() const noexcept __attribute__((always_inline)) {
            return std::size_t(9223372036854775807L) / sizeof(char8_t);
        }
    };
    template<> class __new_allocator<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept __attribute__((always_inline)) {
        }
        constexpr __new_allocator(const __new_allocator<char16_t> &) noexcept __attribute__((always_inline)) {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr __new_allocator<char16_t>(const __new_allocator<char16_t> &) noexcept __attribute__((always_inline));
        char16_t *allocate(size_type __n, const void *) [[nodiscard("")]] {
            static_assert(sizeof(char16_t) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(char16_t)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(char16_t) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(char16_t));
                return static_cast<char16_t *>(__builtin_operator_new(__n * sizeof(char16_t), __al));
            }
            return static_cast<char16_t *>(__builtin_operator_new(__n * sizeof(char16_t)));
        }
        void deallocate(char16_t *__p, size_type __n __attribute__((unused))) {
            if (alignof(char16_t) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(char16_t)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<char16_t> &, const __new_allocator<_Up> &) noexcept __attribute__((always_inline));
    private:
        constexpr size_type _M_max_size() const noexcept __attribute__((always_inline)) {
            return std::size_t(9223372036854775807L) / sizeof(char16_t);
        }
    };
    template<> class __new_allocator<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept __attribute__((always_inline)) {
        }
        constexpr __new_allocator(const __new_allocator<char32_t> &) noexcept __attribute__((always_inline)) {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr __new_allocator<char32_t>(const __new_allocator<char32_t> &) noexcept __attribute__((always_inline));
        char32_t *allocate(size_type __n, const void *) [[nodiscard("")]] {
            static_assert(sizeof(char32_t) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(char32_t)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(char32_t) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(char32_t));
                return static_cast<char32_t *>(__builtin_operator_new(__n * sizeof(char32_t), __al));
            }
            return static_cast<char32_t *>(__builtin_operator_new(__n * sizeof(char32_t)));
        }
        void deallocate(char32_t *__p, size_type __n __attribute__((unused))) {
            if (alignof(char32_t) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(char32_t)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<char32_t> &, const __new_allocator<_Up> &) noexcept __attribute__((always_inline));
    private:
        constexpr size_type _M_max_size() const noexcept __attribute__((always_inline)) {
            return std::size_t(9223372036854775807L) / sizeof(char32_t);
        }
    };
    template<> class __new_allocator<int> {
    public:
        typedef int value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept __attribute__((always_inline)) {
        }
        constexpr __new_allocator(const __new_allocator<int> &) noexcept __attribute__((always_inline)) {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr __new_allocator<int>(const __new_allocator<int> &) noexcept __attribute__((always_inline));
        int *allocate(size_type __n, const void *) [[nodiscard("")]] {
            static_assert(sizeof(int) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(int)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(int) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(int));
                return static_cast<int *>(__builtin_operator_new(__n * sizeof(int), __al));
            }
            return static_cast<int *>(__builtin_operator_new(__n * sizeof(int)));
        }
        void deallocate(int *__p, size_type __n __attribute__((unused))) {
            if (alignof(int) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(int)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<int> &, const __new_allocator<_Up> &) noexcept __attribute__((always_inline));
    private:
        constexpr size_type _M_max_size() const noexcept __attribute__((always_inline)) {
            return std::size_t(9223372036854775807L) / sizeof(int);
        }
    };
    template<> class __new_allocator<Base<ChildA, ChildB, ChildC> *> {
    public:
        typedef Base<ChildA, ChildB, ChildC> *value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept __attribute__((always_inline)) {
        }
        constexpr __new_allocator(const __new_allocator<Base<ChildA, ChildB, ChildC> *> &) noexcept __attribute__((always_inline)) {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr __new_allocator<Base<ChildA, ChildB, ChildC> *>(const __new_allocator<Base<ChildA, ChildB, ChildC> *> &) noexcept __attribute__((always_inline));
        Base<ChildA, ChildB, ChildC> **allocate(size_type __n, const void *) [[nodiscard("")]] {
            static_assert(sizeof(Base<ChildA, ChildB, ChildC> *) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(Base<ChildA, ChildB, ChildC> *)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(Base<ChildA, ChildB, ChildC> *) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(Base<ChildA, ChildB, ChildC> *));
                return static_cast<Base<ChildA, ChildB, ChildC> **>(__builtin_operator_new(__n * sizeof(Base<ChildA, ChildB, ChildC> *), __al));
            }
            return static_cast<Base<ChildA, ChildB, ChildC> **>(__builtin_operator_new(__n * sizeof(Base<ChildA, ChildB, ChildC> *)));
        }
        void deallocate(Base<ChildA, ChildB, ChildC> **__p, size_type __n __attribute__((unused))) {
            if (alignof(Base<ChildA, ChildB, ChildC> *) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(Base<ChildA, ChildB, ChildC> *)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<Base<ChildA, ChildB, ChildC> *> &, const __new_allocator<_Up> &) noexcept __attribute__((always_inline));
    private:
        constexpr size_type _M_max_size() const noexcept __attribute__((always_inline)) {
            return std::size_t(9223372036854775807L) / sizeof(Base<ChildA, ChildB, ChildC> *);
        }
    };
}
namespace std {
    template <typename _Tp> using __allocator_base = __new_allocator<_Tp>;
}
namespace std {
    template<> class allocator<void> {
    public:
        typedef void value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        allocator() = default
        ~allocator<void>() = default
        template <typename _Up> constexpr allocator(const allocator<_Up> &) noexcept __attribute__((always_inline)) {
        }
        template<> constexpr allocator<void>(const allocator<void> &) noexcept __attribute__((always_inline))    };
    template <typename _Tp> class allocator : public __allocator_base<_Tp> {
    public:
        typedef _Tp value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator<type-parameter-0-0>() noexcept __attribute__((always_inline)) {
        }
        constexpr allocator<type-parameter-0-0>(const allocator<type-parameter-0-0> &__a) noexcept : __allocator_base<_Tp>(__a) __attribute__((always_inline)) {
        }
        allocator<type-parameter-0-0> &operator=(const allocator<type-parameter-0-0> &) = default
        template <typename _Tp1> constexpr allocator<type-parameter-0-0>(const allocator<_Tp1> &) noexcept __attribute__((always_inline)) {
        }
        constexpr ~allocator<type-parameter-0-0>() noexcept __attribute__((always_inline)) {
        }
        constexpr _Tp *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(_Tp), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<_Tp *>(::operator new(__n));
            }
            return __allocator_base<_Tp>::allocate(__n, 0);
        }
        constexpr void deallocate(_Tp *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            __allocator_base<_Tp>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<type-parameter-0-0> &, const allocator<type-parameter-0-0> &) noexcept __attribute__((always_inline)) {
            return true;
        }
;
    };
    template<> class allocator<char8_t> : public __allocator_base<char8_t> {
    public:
        typedef char8_t value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<char8_t>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<char8_t> &__a) noexcept : __allocator_base<char8_t>(__a) __attribute__((always_inline)) {
        }
        allocator<char8_t> &operator=(const allocator<char8_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<char8_t>(const allocator<char8_t> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<char8_t>() noexcept __attribute__((always_inline)) {
        }
        constexpr char8_t *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(char8_t), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<char8_t *>(::operator new(__n));
            }
            return this->__allocator_base<char8_t>::allocate(__n, 0);
        }
        constexpr void deallocate(char8_t *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char8_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<char8_t> &, const allocator<char8_t> &) noexcept __attribute__((always_inline));
    };
    template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef char16_t value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<char16_t>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a) __attribute__((always_inline)) {
        }
        allocator<char16_t> &operator=(const allocator<char16_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<char16_t>(const allocator<char16_t> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<char16_t>() noexcept __attribute__((always_inline)) {
        }
        constexpr char16_t *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(char16_t), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<char16_t *>(::operator new(__n));
            }
            return this->__allocator_base<char16_t>::allocate(__n, 0);
        }
        constexpr void deallocate(char16_t *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char16_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<char16_t> &, const allocator<char16_t> &) noexcept __attribute__((always_inline));
    };
    template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef char32_t value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<char32_t>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a) __attribute__((always_inline)) {
        }
        allocator<char32_t> &operator=(const allocator<char32_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<char32_t>(const allocator<char32_t> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<char32_t>() noexcept __attribute__((always_inline)) {
        }
        constexpr char32_t *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(char32_t), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<char32_t *>(::operator new(__n));
            }
            return this->__allocator_base<char32_t>::allocate(__n, 0);
        }
        constexpr void deallocate(char32_t *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char32_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<char32_t> &, const allocator<char32_t> &) noexcept __attribute__((always_inline));
    };
    template<> class allocator<int> : public __allocator_base<int> {
    public:
        typedef int value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<int>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<int> &__a) noexcept : __allocator_base<int>(__a) __attribute__((always_inline)) {
        }
        allocator<int> &operator=(const allocator<int> &) noexcept = default        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<int>(const allocator<int> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<int>() noexcept __attribute__((always_inline)) {
        }
        constexpr int *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(int), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<int *>(::operator new(__n));
            }
            return this->__allocator_base<int>::allocate(__n, 0);
        }
        constexpr void deallocate(int *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<int>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<int> &, const allocator<int> &) noexcept __attribute__((always_inline));
    };
    template<> class allocator<Base<ChildA, ChildB, ChildC> *> : public __allocator_base<Base<ChildA, ChildB, ChildC> *> {
    public:
        typedef Base<ChildA, ChildB, ChildC> *value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<Base<ChildA, ChildB, ChildC> *>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<Base<ChildA, ChildB, ChildC> *> &__a) noexcept : __allocator_base<Base<ChildA, ChildB, ChildC> *>(__a) __attribute__((always_inline)) {
        }
        allocator<Base<ChildA, ChildB, ChildC> *> &operator=(const allocator<Base<ChildA, ChildB, ChildC> *> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<Base<ChildA, ChildB, ChildC> *>(const allocator<Base<ChildA, ChildB, ChildC> *> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<Base<ChildA, ChildB, ChildC> *>() noexcept __attribute__((always_inline)) {
        }
        constexpr Base<ChildA, ChildB, ChildC> **allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(Base<ChildA, ChildB, ChildC> *), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<Base<ChildA, ChildB, ChildC> **>(::operator new(__n));
            }
            return this->__allocator_base<Base<ChildA, ChildB, ChildC> *>::allocate(__n, 0);
        }
        constexpr void deallocate(Base<ChildA, ChildB, ChildC> **__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<Base<ChildA, ChildB, ChildC> *>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<Base<ChildA, ChildB, ChildC> *> &, const allocator<Base<ChildA, ChildB, ChildC> *> &) noexcept __attribute__((always_inline));
    };
    template <typename _T1, typename _T2> inline constexpr bool operator==(const allocator<_T1> &, const allocator<_T2> &) noexcept __attribute__((always_inline)) {
        return true;
    }
    template <typename _Tp> class allocator<const _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const type-parameter-0-0>(const allocator<_Up> &) {
        }
    };
    template <typename _Tp> class allocator<volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<volatile type-parameter-0-0>(const allocator<_Up> &) {
        }
    };
    template <typename _Tp> class allocator<const volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const volatile type-parameter-0-0>(const allocator<_Up> &) {
        }
    };
    template<> class allocator<char> : public __allocator_base<char> {
    public:
        typedef char value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<char>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<char> &__a) noexcept : __allocator_base<char>(__a) __attribute__((always_inline)) {
        }
        allocator<char> &operator=(const allocator<char> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<char>(const allocator<char> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<char>() noexcept __attribute__((always_inline)) {
        }
        constexpr char *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(char), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<char *>(::operator new(__n));
            }
            return this->__allocator_base<char>::allocate(__n, 0);
        }
        constexpr void deallocate(char *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<char> &, const allocator<char> &) noexcept __attribute__((always_inline));
    };
    template<> class allocator<wchar_t> : public __allocator_base<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = true_type;
        constexpr allocator() noexcept : __allocator_base<wchar_t>() __attribute__((always_inline)) {
        }
        constexpr allocator(const allocator<wchar_t> &__a) noexcept : __allocator_base<wchar_t>(__a) __attribute__((always_inline)) {
        }
        allocator<wchar_t> &operator=(const allocator<wchar_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept __attribute__((always_inline));
        template<> constexpr allocator<wchar_t>(const allocator<wchar_t> &) noexcept __attribute__((always_inline));
        constexpr ~allocator<wchar_t>() noexcept __attribute__((always_inline)) {
        }
        constexpr wchar_t *allocate(size_t __n) [[nodiscard("")]] [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(wchar_t), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<wchar_t *>(::operator new(__n));
            }
            return this->__allocator_base<wchar_t>::allocate(__n, 0);
        }
        constexpr void deallocate(wchar_t *__p, size_t __n) [[gnu::always_inline]] {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<wchar_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<wchar_t> &, const allocator<wchar_t> &) noexcept __attribute__((always_inline));
    };
}
extern "C++" {
    namespace std {
        struct __true_type {
        };
        struct __false_type {
        };
        template <bool> struct __truth_type {
            typedef __false_type __type;
        };
        template<> struct __truth_type<true> {
            typedef __true_type __type;
        };
        template <class _Sp, class _Tp> struct __traitor {
            enum {
                __value = bool(_Sp::__value) || bool(_Tp::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
        template<> struct __traitor<std::__is_arithmetic<bool>, std::__is_pointer<bool>> {
            enum {
                __value = bool(__is_arithmetic<bool>::__value) || bool(__is_pointer<bool>::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
        template<> struct __traitor<std::__is_integer<bool>, std::__is_floating<bool>> {
            enum {
                __value = bool(__is_integer<bool>::__value) || bool(__is_floating<bool>::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
        template <typename, typename> struct __are_same {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __are_same<float, float> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __are_same<float, double> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __are_same<double, float> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __are_same<double, double> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __are_same<long double, float> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __are_same<long double, double> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template <typename _Tp> struct __are_same<_Tp, _Tp> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template <typename _Tp> struct __is_void {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_void<void> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template <typename _Tp> struct __is_integer {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_integer<long double> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_integer<double> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_integer<float> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_integer<bool> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<char> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<signed char> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<unsigned char> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<wchar_t> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<char8_t> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<char16_t> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<char32_t> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<short> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<unsigned short> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<int> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<unsigned int> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<long> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<unsigned long> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<long long> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_integer<unsigned long long> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template <typename _Tp> struct __is_floating {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_floating<bool> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_floating<float> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_floating<double> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_floating<long double> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template <typename _Tp> struct __is_pointer {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_pointer<bool> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template <typename _Tp> struct __is_pointer<_Tp *> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template <typename _Tp> struct __is_arithmetic : public __traitor<__is_integer<_Tp>, __is_floating<_Tp>> {
        };
        template<> struct __is_arithmetic<bool> : public __traitor<__is_integer<bool>, __is_floating<bool>> {
        };
        template <typename _Tp> struct __is_scalar : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>> {
        };
        template<> struct __is_scalar<bool> : public __traitor<__is_arithmetic<bool>, __is_pointer<bool>> {
        };
        template <typename _Tp> struct __is_char {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_char<char> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_char<wchar_t> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template <typename _Tp> struct __is_byte {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_byte<char> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_byte<signed char> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_byte<unsigned char> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        enum class byte : unsigned char;
        template<> struct __is_byte<byte> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template<> struct __is_byte<char8_t> {
            enum {
                __value = 1
            };
            typedef __true_type __type;
        };
        template <typename> struct iterator_traits
        template<> struct iterator_traits<const char *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<const char>;
            using difference_type = ptrdiff_t;
            using pointer = const char *;
            using reference = const char &;
        }
        template<> struct iterator_traits<const wchar_t *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<const wchar_t>;
            using difference_type = ptrdiff_t;
            using pointer = const wchar_t *;
            using reference = const wchar_t &;
        }
        template<> struct iterator_traits<const char8_t *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<const char8_t>;
            using difference_type = ptrdiff_t;
            using pointer = const char8_t *;
            using reference = const char8_t &;
        }
        template<> struct iterator_traits<const char16_t *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<const char16_t>;
            using difference_type = ptrdiff_t;
            using pointer = const char16_t *;
            using reference = const char16_t &;
        }
        template<> struct iterator_traits<const char32_t *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<const char32_t>;
            using difference_type = ptrdiff_t;
            using pointer = const char32_t *;
            using reference = const char32_t &;
        }
        template<> struct iterator_traits<std::_Bit_iterator> : public __iterator_traits<_Bit_iterator> {
        }
        template<> struct iterator_traits<std::_Bit_const_iterator> : public __iterator_traits<_Bit_const_iterator> {
        }
        template<> struct iterator_traits<unsigned long *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<unsigned long>;
            using difference_type = ptrdiff_t;
            using pointer = unsigned long *;
            using reference = unsigned long &;
        }
        template<> struct iterator_traits<const int *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<const int>;
            using difference_type = ptrdiff_t;
            using pointer = const int *;
            using reference = const int &;
        }
        template<> struct iterator_traits<int *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<int>;
            using difference_type = ptrdiff_t;
            using pointer = int *;
            using reference = int &;
        }
        template<> struct iterator_traits<char *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<char>;
            using difference_type = ptrdiff_t;
            using pointer = char *;
            using reference = char &;
        }
        template<> struct iterator_traits<Base<ChildA, ChildB, ChildC> *const *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<Base<ChildA, ChildB, ChildC> *const>;
            using difference_type = ptrdiff_t;
            using pointer = Base<ChildA, ChildB, ChildC> *const *;
            using reference = Base<ChildA, ChildB, ChildC> *const &;
        }
        template<> struct iterator_traits<Base<ChildA, ChildB, ChildC> **> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<Base<ChildA, ChildB, ChildC> *>;
            using difference_type = ptrdiff_t;
            using pointer = Base<ChildA, ChildB, ChildC> **;
            using reference = Base<ChildA, ChildB, ChildC> *&;
        }
        template<> struct iterator_traits<wchar_t *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<wchar_t>;
            using difference_type = ptrdiff_t;
            using pointer = wchar_t *;
            using reference = wchar_t &;
        }
        template<> struct iterator_traits<char8_t *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<char8_t>;
            using difference_type = ptrdiff_t;
            using pointer = char8_t *;
            using reference = char8_t &;
        }
        template<> struct iterator_traits<char16_t *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<char16_t>;
            using difference_type = ptrdiff_t;
            using pointer = char16_t *;
            using reference = char16_t &;
        }
        template<> struct iterator_traits<char32_t *> {
            using iterator_concept = contiguous_iterator_tag;
            using iterator_category = random_access_iterator_tag;
            using value_type = remove_cv_t<char32_t>;
            using difference_type = ptrdiff_t;
            using pointer = char32_t *;
            using reference = char32_t &;
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable {
            enum {
                __value = __is_trivially_copyable(_Tp)
            };
        };
        template<> struct __is_nonvolatile_trivially_copyable<unsigned long> {
            enum {
                __value = __is_trivially_copyable(unsigned long)
            };
        };
        template<> struct __is_nonvolatile_trivially_copyable<int> {
            enum {
                __value = __is_trivially_copyable(int)
            };
        };
        template<> struct __is_nonvolatile_trivially_copyable<Base<ChildA, ChildB, ChildC> *> {
            enum {
                __value = __is_trivially_copyable(Base<ChildA, ChildB, ChildC> *)
            };
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable<volatile _Tp> {
            enum {
                __value = 0
            };
        };
        template <typename _OutputIter, typename _InputIter> struct __memcpyable {
            enum {
                __value = 0
            };
        };
        template<> struct __memcpyable<unsigned long *, unsigned long *> : __is_nonvolatile_trivially_copyable<unsigned long> {
        };
        template<> struct __memcpyable<std::_Bit_iterator, std::_Bit_const_iterator> {
            enum {
                __value = 0
            };
        };
        template<> struct __memcpyable<std::_Bit_iterator, std::_Bit_iterator> {
            enum {
                __value = 0
            };
        };
        template<> struct __memcpyable<int *, const int *> : __is_nonvolatile_trivially_copyable<int> {
        };
        template<> struct __memcpyable<Base<ChildA, ChildB, ChildC> **, Base<ChildA, ChildB, ChildC> *const *> : __is_nonvolatile_trivially_copyable<Base<ChildA, ChildB, ChildC> *> {
        };
        template <typename _Tp> struct __memcpyable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcpyable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Iter1, typename _Iter2> struct __memcmpable {
            enum {
                __value = 0
            };
        };
        template <typename _Tp> struct __memcmpable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<const _Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp, bool _TreatAsBytes = __is_byte<_Tp>::__value> struct __is_memcmp_ordered {
            static const bool __value = _Tp(-1) > _Tp(1);
        };
        template <typename _Tp> struct __is_memcmp_ordered<_Tp, false> {
            static const bool __value = false;
        };
        template <typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)> struct __is_memcmp_ordered_with {
            static const bool __value = __is_memcmp_ordered<_Tp>::__value && __is_memcmp_ordered<_Up>::__value;
        };
        template <typename _Tp, typename _Up> struct __is_memcmp_ordered_with<_Tp, _Up, false> {
            static const bool __value = false;
        };
        template<> struct __is_memcmp_ordered_with<std::byte, std::byte, true> {
            static constexpr bool __value = true;
        };
        template <typename _Tp, bool _SameSize> struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize> {
            static constexpr bool __value = false;
        };
        template <typename _Up, bool _SameSize> struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize> {
            static constexpr bool __value = false;
        };
        template <typename _Tp> struct __is_move_iterator {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_move_iterator<unsigned long *> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_move_iterator<std::_Bit_const_iterator> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_move_iterator<std::_Bit_iterator> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_move_iterator<const int *> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template<> struct __is_move_iterator<Base<ChildA, ChildB, ChildC> *const *> {
            enum {
                __value = 0
            };
            typedef __false_type __type;
        };
        template <typename _Iterator> inline constexpr _Iterator __miter_base(_Iterator __it) {
            return __it;
        }
        template<> inline constexpr unsigned long *__miter_base<unsigned long *>(unsigned long *__it) {
            return __it;
        }
        template<> inline constexpr std::_Bit_const_iterator __miter_base<std::_Bit_const_iterator>(std::_Bit_const_iterator __it) {
            return __it;
        }
        template<> inline constexpr std::_Bit_iterator __miter_base<std::_Bit_iterator>(std::_Bit_iterator __it) {
            return __it;
        }
        template<> inline constexpr const int *__miter_base<const int *>(const int *__it) {
            return __it;
        }
        template<> inline constexpr Base<ChildA, ChildB, ChildC> *const *__miter_base<Base<ChildA, ChildB, ChildC> *const *>(Base<ChildA, ChildB, ChildC> *const *__it) {
            return __it;
        }
    }
}
namespace __cxxabiv1 {
    class __forced_unwind {
        virtual ~__forced_unwind() throw();
        virtual void __pure_dummy() = 0;
    };
}
namespace std {
    template <typename _CharT, typename _Traits> inline void __ostream_write(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, streamsize __n) {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const streamsize __put = __out.rdbuf()->sputn(__s, __n);
        if (__put != __n)
            __out.setstate(__ios_base::badbit);
    }
    template <typename _CharT, typename _Traits> inline void __ostream_fill(basic_ostream<_CharT, _Traits> &__out, streamsize __n) {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const _CharT __c = __out.fill();
        for (; __n > 0; --__n) {
            const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
            if (_Traits::eq_int_type(__put, _Traits::eof())) {
                __out.setstate(__ios_base::badbit);
                break;
            }
        }
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &__ostream_insert(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, streamsize __n) {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        typename __ostream_type::sentry __cerb(__out);
        if (__cerb) {
            try {
                const streamsize __w = __out.width();
                if (__w > __n) {
                    const bool __left = ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
                    if (!__left)
                        __ostream_fill(__out, __w - __n);
                    if (__out.good())
                        __ostream_write(__out, __s, __n);
                    if (__left && __out.good())
                        __ostream_fill(__out, __w - __n);
                } else
                    __ostream_write(__out, __s, __n);
                __out.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(__ios_base::badbit);
            }
        }
        return __out;
    }
}
extern "C++" {
    namespace __gnu_cxx {
        template <bool, typename> struct __enable_if {
        };
        template<> struct __enable_if<false, void> {
        };
        template<> struct __enable_if<true, void> {
            typedef void __type;
        };
        template <typename _Tp> struct __enable_if<true, _Tp> {
            typedef _Tp __type;
        };
        template <bool _Cond, typename _Iftrue, typename _Iffalse> struct __conditional_type {
            typedef _Iftrue __type;
        };
        template<> struct __conditional_type<true, unsigned long, unsigned long long> {
            typedef unsigned long __type;
        };
        template <typename _Iftrue, typename _Iffalse> struct __conditional_type<false, _Iftrue, _Iffalse> {
            typedef _Iffalse __type;
        };
        template <typename _Tp> struct __add_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __add_unsigned<char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<signed char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<short> {
            typedef unsigned short __type;
        };
        template<> struct __add_unsigned<int> {
            typedef unsigned int __type;
        };
        template<> struct __add_unsigned<long> {
            typedef unsigned long __type;
        };
        template<> struct __add_unsigned<long long> {
            typedef unsigned long long __type;
        };
        template<> struct __add_unsigned<bool>;
        template<> struct __add_unsigned<wchar_t>;
        template <typename _Tp> struct __remove_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __remove_unsigned<char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned short> {
            typedef short __type;
        };
        template<> struct __remove_unsigned<unsigned int> {
            typedef int __type;
        };
        template<> struct __remove_unsigned<unsigned long> {
            typedef long __type;
        };
        template<> struct __remove_unsigned<unsigned long long> {
            typedef long long __type;
        };
        template<> struct __remove_unsigned<bool>;
        template<> struct __remove_unsigned<wchar_t>;
        template <typename _Type> inline constexpr bool __is_null_pointer(_Type *__ptr) {
            return __ptr == 0;
        }
        template <typename _Type> inline constexpr bool __is_null_pointer(_Type) {
            return false;
        }
        constexpr bool __is_null_pointer(std::nullptr_t) {
            return true;
        }
        template <typename _Tp, bool = std::__is_integer<_Tp>::__value> struct __promote {
            typedef double __type;
        };
        template <typename _Tp> struct __promote<_Tp, false> {
        };
        template<> struct __promote<long double> {
            typedef long double __type;
        };
        template<> struct __promote<double> {
            typedef double __type;
        };
        template<> struct __promote<float> {
            typedef float __type;
        };
        template <typename ..._Tp> using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));
        template <typename _Tp, typename _Up> using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;
        template <typename _Tp, typename _Up, typename _Vp> using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;
        template <typename _Tp, typename _Up, typename _Vp, typename _Wp> using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
    }
}
namespace std {
    namespace __detail {
        template <typename _Cat, typename _Limit, typename _Otherwise = _Cat> using __clamp_iter_cat = __conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
        template <typename _Tp, typename _Up> concept __different_from = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
    }
    template <typename _Iterator> class reverse_iterator : public iterator<typename iterator_traits<_Iterator>::iterator_category, typename iterator_traits<_Iterator>::value_type, typename iterator_traits<_Iterator>::difference_type, typename iterator_traits<_Iterator>::pointer, typename iterator_traits<_Iterator>::reference> {
        friend template <typename _Iter> class reverse_iterator;
        template <typename _Iter> static constexpr bool __convertible = !is_same_v<_Iter, _Iterator> && convertible_to<const _Iter &, _Iterator>;
    protected:
        _Iterator current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = __conditional_t<random_access_iterator<_Iterator>, random_access_iterator_tag, bidirectional_iterator_tag>;
        using iterator_category = __detail::__clamp_iter_cat<typename __traits_type::iterator_category, random_access_iterator_tag>;
        using value_type = iter_value_t<_Iterator>;
        using difference_type = iter_difference_t<_Iterator>;
        using reference = iter_reference_t<_Iterator>;
        constexpr reverse_iterator<_Iterator>() noexcept(noexcept(_Iterator())) : current() {
        }
        constexpr explicit reverse_iterator<_Iterator>(iterator_type __x) noexcept(noexcept(_Iterator(__x))) : current(__x) {
        }
        constexpr reverse_iterator<_Iterator>(const reverse_iterator<_Iterator> &__x) noexcept(noexcept(_Iterator(__x.current))) : current(__x.current) {
        }
        reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iterator> &) = default
        template <typename _Iter> constexpr reverse_iterator<_Iterator>(const reverse_iterator<_Iter> &__x) noexcept(noexcept(_Iterator(__x.current))) : current(__x.current) {
        }
        template <typename _Iter> constexpr reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iter> &__x) noexcept(noexcept(this->current = __x.current)) {
            this->current = __x.current;
            return *this;
        }
        constexpr iterator_type base() const noexcept(noexcept(_Iterator(this->current))) [[nodiscard("")]] {
            return this->current;
        }
        constexpr reference operator*() const [[nodiscard("")]] {
            _Iterator __tmp = this->current;
            return *--__tmp;
        }
        constexpr pointer operator->() const requires is_pointer_v<_Iterator> || requires (const _Iterator __i) { __i.operator->(); } [[nodiscard("")]] {
            _Iterator __tmp = this->current;
            --__tmp;
            return _S_to_pointer(__tmp);
        }
        constexpr reverse_iterator<_Iterator> &operator++() {
            --this->current;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator++(int) {
            reverse_iterator<_Iterator> __tmp = *this;
            --this->current;
            return __tmp;
        }
        constexpr reverse_iterator<_Iterator> &operator--() {
            ++this->current;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator--(int) {
            reverse_iterator<_Iterator> __tmp = *this;
            ++this->current;
            return __tmp;
        }
        constexpr reverse_iterator<_Iterator> operator+(difference_type __n) const [[nodiscard("")]] {
            return reverse_iterator<_Iterator>(this->current - __n);
        }
        constexpr reverse_iterator<_Iterator> &operator+=(difference_type __n) {
            this->current -= __n;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator-(difference_type __n) const [[nodiscard("")]] {
            return reverse_iterator<_Iterator>(this->current + __n);
        }
        constexpr reverse_iterator<_Iterator> &operator-=(difference_type __n) {
            this->current += __n;
            return *this;
        }
        constexpr reference operator[](difference_type __n) const [[nodiscard("")]] {
            return *(*this + __n);
        }
        friend constexpr iter_rvalue_reference_t<_Iterator> iter_move(const reverse_iterator<_Iterator> &__i) noexcept(is_nothrow_copy_constructible_v<_Iterator> && noexcept(ranges::iter_move(--std::declval<_Iterator &>()))) [[nodiscard("")]] {
            auto __tmp = __i.base();
            return ranges::iter_move(--__tmp);
        }
;
        friend template <indirectly_swappable<_Iterator> _Iter2> constexpr void iter_swap(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iter2> &__y) noexcept(is_nothrow_copy_constructible_v<_Iterator> && is_nothrow_copy_constructible_v<_Iter2> && noexcept(ranges::iter_swap(--std::declval<_Iterator &>(), --std::declval<_Iter2 &>()))) {
            auto __xtmp = __x.base();
            auto __ytmp = __y.base();
            ranges::iter_swap(--__xtmp, --__ytmp);
        }
;
    private:
        template <typename _Tp> static constexpr _Tp *_S_to_pointer(_Tp *__p) {
            return __p;
        }
        template <typename _Tp> static constexpr pointer _S_to_pointer(_Tp __t) {
            return __t.operator->();
        }
    };
    template<> class reverse_iterator<std::_Bit_const_iterator> : public iterator<typename iterator_traits<_Bit_const_iterator>::iterator_category, typename iterator_traits<_Bit_const_iterator>::value_type, typename iterator_traits<_Bit_const_iterator>::difference_type, typename iterator_traits<_Bit_const_iterator>::pointer, typename iterator_traits<_Bit_const_iterator>::reference> {
        friend template <typename _Iter> class reverse_iterator;
        template <typename _Iter> static constexpr bool __convertible;
    protected:
        std::_Bit_const_iterator current;
        typedef iterator_traits<_Bit_const_iterator> __traits_type;
    public:
        typedef std::_Bit_const_iterator iterator_type;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = __conditional_t<random_access_iterator<_Bit_const_iterator>, random_access_iterator_tag, bidirectional_iterator_tag>;
        using iterator_category = __detail::__clamp_iter_cat<typename __traits_type::iterator_category, random_access_iterator_tag>;
        using value_type = iter_value_t<_Bit_const_iterator>;
        using difference_type = iter_difference_t<_Bit_const_iterator>;
        using reference = iter_reference_t<_Bit_const_iterator>;
        constexpr reverse_iterator();
        constexpr explicit reverse_iterator(iterator_type __x);
        constexpr reverse_iterator(const reverse_iterator<_Bit_const_iterator> &__x);
        reverse_iterator<_Bit_const_iterator> &operator=(const reverse_iterator<_Bit_const_iterator> &) = default
        template <typename _Iter> constexpr reverse_iterator(const reverse_iterator<_Iter> &__x);
        template <typename _Iter> constexpr reverse_iterator<_Bit_const_iterator> &operator=(const reverse_iterator<_Iter> &__x);
        constexpr iterator_type base() const [[nodiscard("")]];
        constexpr reference operator*() const [[nodiscard("")]];
        constexpr pointer operator->() const requires is_pointer_v<_Iterator> || requires (const _Iterator __i) { __i.operator->(); } [[nodiscard("")]];
        constexpr reverse_iterator<_Bit_const_iterator> &operator++();
        constexpr reverse_iterator<_Bit_const_iterator> operator++(int);
        constexpr reverse_iterator<_Bit_const_iterator> &operator--();
        constexpr reverse_iterator<_Bit_const_iterator> operator--(int);
        constexpr reverse_iterator<_Bit_const_iterator> operator+(difference_type __n) const [[nodiscard("")]];
        constexpr reverse_iterator<_Bit_const_iterator> &operator+=(difference_type __n);
        constexpr reverse_iterator<_Bit_const_iterator> operator-(difference_type __n) const [[nodiscard("")]];
        constexpr reverse_iterator<_Bit_const_iterator> &operator-=(difference_type __n);
        constexpr reference operator[](difference_type __n) const [[nodiscard("")]];
        friend constexpr iter_rvalue_reference_t<_Bit_const_iterator> iter_move(const reverse_iterator<_Bit_const_iterator> &__i) [[nodiscard("")]];
        friend template <indirectly_swappable<_Iterator> _Iter2> constexpr void iter_swap(const reverse_iterator<_Bit_const_iterator> &__x, const reverse_iterator<_Iter2> &__y);
    private:
        template <typename _Tp> static constexpr _Tp *_S_to_pointer(_Tp *__p);
        template <typename _Tp> static constexpr pointer _S_to_pointer(_Tp __t);
    };
    template<> class reverse_iterator<std::_Bit_iterator> : public iterator<typename iterator_traits<_Bit_iterator>::iterator_category, typename iterator_traits<_Bit_iterator>::value_type, typename iterator_traits<_Bit_iterator>::difference_type, typename iterator_traits<_Bit_iterator>::pointer, typename iterator_traits<_Bit_iterator>::reference> {
        friend template <typename _Iter> class reverse_iterator;
        template <typename _Iter> static constexpr bool __convertible;
    protected:
        std::_Bit_iterator current;
        typedef iterator_traits<_Bit_iterator> __traits_type;
    public:
        typedef std::_Bit_iterator iterator_type;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = __conditional_t<random_access_iterator<_Bit_iterator>, random_access_iterator_tag, bidirectional_iterator_tag>;
        using iterator_category = __detail::__clamp_iter_cat<typename __traits_type::iterator_category, random_access_iterator_tag>;
        using value_type = iter_value_t<_Bit_iterator>;
        using difference_type = iter_difference_t<_Bit_iterator>;
        using reference = iter_reference_t<_Bit_iterator>;
        constexpr reverse_iterator();
        constexpr explicit reverse_iterator(iterator_type __x);
        constexpr reverse_iterator(const reverse_iterator<_Bit_iterator> &__x);
        reverse_iterator<_Bit_iterator> &operator=(const reverse_iterator<_Bit_iterator> &) = default
        template <typename _Iter> constexpr reverse_iterator(const reverse_iterator<_Iter> &__x);
        template <typename _Iter> constexpr reverse_iterator<_Bit_iterator> &operator=(const reverse_iterator<_Iter> &__x);
        constexpr iterator_type base() const [[nodiscard("")]];
        constexpr reference operator*() const [[nodiscard("")]];
        constexpr pointer operator->() const requires is_pointer_v<_Iterator> || requires (const _Iterator __i) { __i.operator->(); } [[nodiscard("")]];
        constexpr reverse_iterator<_Bit_iterator> &operator++();
        constexpr reverse_iterator<_Bit_iterator> operator++(int);
        constexpr reverse_iterator<_Bit_iterator> &operator--();
        constexpr reverse_iterator<_Bit_iterator> operator--(int);
        constexpr reverse_iterator<_Bit_iterator> operator+(difference_type __n) const [[nodiscard("")]];
        constexpr reverse_iterator<_Bit_iterator> &operator+=(difference_type __n);
        constexpr reverse_iterator<_Bit_iterator> operator-(difference_type __n) const [[nodiscard("")]];
        constexpr reverse_iterator<_Bit_iterator> &operator-=(difference_type __n);
        constexpr reference operator[](difference_type __n) const [[nodiscard("")]];
        friend constexpr iter_rvalue_reference_t<_Bit_iterator> iter_move(const reverse_iterator<_Bit_iterator> &__i) [[nodiscard("")]];
        friend template <indirectly_swappable<_Iterator> _Iter2> constexpr void iter_swap(const reverse_iterator<_Bit_iterator> &__x, const reverse_iterator<_Iter2> &__y);
    private:
        template <typename _Tp> static constexpr _Tp *_S_to_pointer(_Tp *__p);
        template <typename _Tp> static constexpr pointer _S_to_pointer(_Tp __t);
    };
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator==(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator!=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() != __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator<(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() > __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator<=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() >= __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator>=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() <= __y.base();
    }
    template <typename _IteratorL, three_way_comparable_with<_IteratorL> _IteratorR> constexpr compare_three_way_result_t<_IteratorL, _IteratorR> operator<=>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) [[nodiscard("")]] {
        return __y.base() <=> __x.base();
    }
    template <typename _Iterator> constexpr bool operator==(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() == __y.base();
    }
    template <three_way_comparable _Iterator> constexpr compare_three_way_result_t<_Iterator, _Iterator> operator<=>(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return __y.base() <=> __x.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr auto operator-(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base()) [[nodiscard("")]] {
        return __y.base() - __x.base();
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> operator+(typename reverse_iterator<_Iterator>::difference_type __n, const reverse_iterator<_Iterator> &__x) [[nodiscard("")]] {
        return reverse_iterator<_Iterator>(__x.base() - __n);
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> __make_reverse_iterator(_Iterator __i) {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> make_reverse_iterator(_Iterator __i) [[nodiscard("")]] {
        return reverse_iterator<_Iterator>(__i);
    }
    constexpr bool disable_sized_sentinel_for = true;
    template <typename _Iterator> constexpr auto __niter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__niter_base(__it.base()))) {
        return __make_reverse_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<reverse_iterator<_Iterator>> : __is_move_iterator<_Iterator> {
    };
    template <typename _Iterator> constexpr auto __miter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__miter_base(__it.base()))) {
        return __make_reverse_iterator(__miter_base(__it.base()));
    }
    template <typename _Container> class back_insert_iterator : public iterator<output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        using difference_type = ptrdiff_t;
        constexpr explicit back_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x)) {
        }
        constexpr back_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value) {
            this->container->push_back(__value);
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value) {
            this->container->push_back(std::move(__value));
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator*() [[nodiscard("")]] {
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator++() {
            return *this;
        }
        constexpr back_insert_iterator<_Container> operator++(int) {
            return *this;
        }
    };
    template <typename _Container> inline constexpr back_insert_iterator<_Container> back_inserter(_Container &__x) [[nodiscard("")]] {
        return back_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class front_insert_iterator : public iterator<output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        using difference_type = ptrdiff_t;
        constexpr explicit front_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x)) {
        }
        constexpr front_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value) {
            this->container->push_front(__value);
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value) {
            this->container->push_front(std::move(__value));
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator*() [[nodiscard("")]] {
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator++() {
            return *this;
        }
        constexpr front_insert_iterator<_Container> operator++(int) {
            return *this;
        }
    };
    template <typename _Container> inline constexpr front_insert_iterator<_Container> front_inserter(_Container &__x) [[nodiscard("")]] {
        return front_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class insert_iterator : public iterator<output_iterator_tag, void, void, void, void> {
        using _Iter = std::__detail::__range_iter_t<_Container>;
    protected:
        _Container *container;
        _Iter iter;
    public:
        typedef _Container container_type;
        using difference_type = ptrdiff_t;
        constexpr insert_iterator<_Container>(_Container &__x, _Iter __i) : container(std::__addressof(__x)), iter(__i) {
        }
        constexpr insert_iterator<_Container> &operator=(const typename _Container::value_type &__value) {
            this->iter = this->container->insert(this->iter, __value);
            ++this->iter;
            return *this;
        }
        constexpr insert_iterator<_Container> &operator=(typename _Container::value_type &&__value) {
            this->iter = this->container->insert(this->iter, std::move(__value));
            ++this->iter;
            return *this;
        }
        constexpr insert_iterator<_Container> &operator*() [[nodiscard("")]] {
            return *this;
        }
        constexpr insert_iterator<_Container> &operator++() {
            return *this;
        }
        constexpr insert_iterator<_Container> &operator++(int) {
            return *this;
        }
    };
    template <typename _Container> constexpr insert_iterator<_Container> inserter(_Container &__x, std::__detail::__range_iter_t<_Container> __i) [[nodiscard("")]] {
        return insert_iterator<_Container>(__x, __i);
    }
}
namespace __gnu_cxx {
    template <typename _Iterator, typename _Container> class __normal_iterator {
    protected:
        _Iterator _M_current;
        typedef std::iterator_traits<_Iterator> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<_Iterator>;
        constexpr __normal_iterator<_Iterator, _Container>() noexcept : _M_current(_Iterator()) {
        }
        constexpr explicit __normal_iterator<_Iterator, _Container>(const _Iterator &__i) noexcept : _M_current(__i) {
        }
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator<_Iterator, _Container>(const __normal_iterator<_Iter, _Container> &__i) noexcept : _M_current(__i.base()) {
        }
        constexpr reference operator*() const noexcept {
            return *this->_M_current;
        }
        constexpr pointer operator->() const noexcept {
            return this->_M_current;
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator++() noexcept {
            ++this->_M_current;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator++(int) noexcept {
            return __normal_iterator<_Iterator, _Container>(this->_M_current++);
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator--() noexcept {
            --this->_M_current;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator--(int) noexcept {
            return __normal_iterator<_Iterator, _Container>(this->_M_current--);
        }
        constexpr reference operator[](difference_type __n) const noexcept {
            return this->_M_current[__n];
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator+=(difference_type __n) noexcept {
            this->_M_current += __n;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator+(difference_type __n) const noexcept {
            return __normal_iterator<_Iterator, _Container>(this->_M_current + __n);
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator-=(difference_type __n) noexcept {
            this->_M_current -= __n;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator-(difference_type __n) const noexcept {
            return __normal_iterator<_Iterator, _Container>(this->_M_current - __n);
        }
        constexpr const _Iterator &base() const noexcept {
            return this->_M_current;
        }
    };
    template<> class __normal_iterator<char *, std::basic_string<char>> {
    protected:
        char *_M_current;
        typedef std::iterator_traits<char *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, char *>::value>;
    public:
        typedef char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<char *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(char *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<char, char_traits<char>, allocator<char>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<char *, basic_string<char>> &operator++() noexcept;
        constexpr __normal_iterator<char *, basic_string<char>> operator++(int) noexcept;
        constexpr __normal_iterator<char *, basic_string<char>> &operator--() noexcept;
        constexpr __normal_iterator<char *, basic_string<char>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<char *, basic_string<char>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<char *, basic_string<char>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<char *, basic_string<char>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<char *, basic_string<char>> operator-(difference_type __n) const noexcept;
        constexpr char *const &base() const noexcept;
    };
    template<> class __normal_iterator<const char *, std::basic_string<char>> {
    protected:
        const char *_M_current;
        typedef std::iterator_traits<const char *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const char *>::value>;
    public:
        typedef const char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<const char *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(const char *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<char, char_traits<char>, allocator<char>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<const char *, basic_string<char>> &operator++() noexcept;
        constexpr __normal_iterator<const char *, basic_string<char>> operator++(int) noexcept;
        constexpr __normal_iterator<const char *, basic_string<char>> &operator--() noexcept;
        constexpr __normal_iterator<const char *, basic_string<char>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<const char *, basic_string<char>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<const char *, basic_string<char>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<const char *, basic_string<char>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<const char *, basic_string<char>> operator-(difference_type __n) const noexcept;
        constexpr const char *const &base() const noexcept;
    };
    template<> class __normal_iterator<wchar_t *, std::basic_string<wchar_t>> {
    protected:
        wchar_t *_M_current;
        typedef std::iterator_traits<wchar_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, wchar_t *>::value>;
    public:
        typedef wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<wchar_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(wchar_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<wchar_t *, basic_string<wchar_t>> &operator++() noexcept;
        constexpr __normal_iterator<wchar_t *, basic_string<wchar_t>> operator++(int) noexcept;
        constexpr __normal_iterator<wchar_t *, basic_string<wchar_t>> &operator--() noexcept;
        constexpr __normal_iterator<wchar_t *, basic_string<wchar_t>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<wchar_t *, basic_string<wchar_t>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<wchar_t *, basic_string<wchar_t>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<wchar_t *, basic_string<wchar_t>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<wchar_t *, basic_string<wchar_t>> operator-(difference_type __n) const noexcept;
        constexpr wchar_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<const wchar_t *, std::basic_string<wchar_t>> {
    protected:
        const wchar_t *_M_current;
        typedef std::iterator_traits<const wchar_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const wchar_t *>::value>;
    public:
        typedef const wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<const wchar_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(const wchar_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<const wchar_t *, basic_string<wchar_t>> &operator++() noexcept;
        constexpr __normal_iterator<const wchar_t *, basic_string<wchar_t>> operator++(int) noexcept;
        constexpr __normal_iterator<const wchar_t *, basic_string<wchar_t>> &operator--() noexcept;
        constexpr __normal_iterator<const wchar_t *, basic_string<wchar_t>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<const wchar_t *, basic_string<wchar_t>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<const wchar_t *, basic_string<wchar_t>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<const wchar_t *, basic_string<wchar_t>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<const wchar_t *, basic_string<wchar_t>> operator-(difference_type __n) const noexcept;
        constexpr const wchar_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<char8_t *, std::basic_string<char8_t>> {
    protected:
        char8_t *_M_current;
        typedef std::iterator_traits<char8_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, char8_t *>::value>;
    public:
        typedef char8_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<char8_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(char8_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<char8_t *, basic_string<char8_t>> &operator++() noexcept;
        constexpr __normal_iterator<char8_t *, basic_string<char8_t>> operator++(int) noexcept;
        constexpr __normal_iterator<char8_t *, basic_string<char8_t>> &operator--() noexcept;
        constexpr __normal_iterator<char8_t *, basic_string<char8_t>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<char8_t *, basic_string<char8_t>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<char8_t *, basic_string<char8_t>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<char8_t *, basic_string<char8_t>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<char8_t *, basic_string<char8_t>> operator-(difference_type __n) const noexcept;
        constexpr char8_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<const char8_t *, std::basic_string<char8_t>> {
    protected:
        const char8_t *_M_current;
        typedef std::iterator_traits<const char8_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const char8_t *>::value>;
    public:
        typedef const char8_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<const char8_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(const char8_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<const char8_t *, basic_string<char8_t>> &operator++() noexcept;
        constexpr __normal_iterator<const char8_t *, basic_string<char8_t>> operator++(int) noexcept;
        constexpr __normal_iterator<const char8_t *, basic_string<char8_t>> &operator--() noexcept;
        constexpr __normal_iterator<const char8_t *, basic_string<char8_t>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<const char8_t *, basic_string<char8_t>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<const char8_t *, basic_string<char8_t>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<const char8_t *, basic_string<char8_t>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<const char8_t *, basic_string<char8_t>> operator-(difference_type __n) const noexcept;
        constexpr const char8_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<char16_t *, std::basic_string<char16_t>> {
    protected:
        char16_t *_M_current;
        typedef std::iterator_traits<char16_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, char16_t *>::value>;
    public:
        typedef char16_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<char16_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(char16_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<char16_t *, basic_string<char16_t>> &operator++() noexcept;
        constexpr __normal_iterator<char16_t *, basic_string<char16_t>> operator++(int) noexcept;
        constexpr __normal_iterator<char16_t *, basic_string<char16_t>> &operator--() noexcept;
        constexpr __normal_iterator<char16_t *, basic_string<char16_t>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<char16_t *, basic_string<char16_t>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<char16_t *, basic_string<char16_t>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<char16_t *, basic_string<char16_t>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<char16_t *, basic_string<char16_t>> operator-(difference_type __n) const noexcept;
        constexpr char16_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<const char16_t *, std::basic_string<char16_t>> {
    protected:
        const char16_t *_M_current;
        typedef std::iterator_traits<const char16_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const char16_t *>::value>;
    public:
        typedef const char16_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<const char16_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(const char16_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<const char16_t *, basic_string<char16_t>> &operator++() noexcept;
        constexpr __normal_iterator<const char16_t *, basic_string<char16_t>> operator++(int) noexcept;
        constexpr __normal_iterator<const char16_t *, basic_string<char16_t>> &operator--() noexcept;
        constexpr __normal_iterator<const char16_t *, basic_string<char16_t>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<const char16_t *, basic_string<char16_t>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<const char16_t *, basic_string<char16_t>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<const char16_t *, basic_string<char16_t>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<const char16_t *, basic_string<char16_t>> operator-(difference_type __n) const noexcept;
        constexpr const char16_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<char32_t *, std::basic_string<char32_t>> {
    protected:
        char32_t *_M_current;
        typedef std::iterator_traits<char32_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, char32_t *>::value>;
    public:
        typedef char32_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<char32_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(char32_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<char32_t *, basic_string<char32_t>> &operator++() noexcept;
        constexpr __normal_iterator<char32_t *, basic_string<char32_t>> operator++(int) noexcept;
        constexpr __normal_iterator<char32_t *, basic_string<char32_t>> &operator--() noexcept;
        constexpr __normal_iterator<char32_t *, basic_string<char32_t>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<char32_t *, basic_string<char32_t>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<char32_t *, basic_string<char32_t>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<char32_t *, basic_string<char32_t>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<char32_t *, basic_string<char32_t>> operator-(difference_type __n) const noexcept;
        constexpr char32_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<const char32_t *, std::basic_string<char32_t>> {
    protected:
        const char32_t *_M_current;
        typedef std::iterator_traits<const char32_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const char32_t *>::value>;
    public:
        typedef const char32_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<const char32_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(const char32_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &__i) noexcept;
        constexpr reference operator*() const noexcept;
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<const char32_t *, basic_string<char32_t>> &operator++() noexcept;
        constexpr __normal_iterator<const char32_t *, basic_string<char32_t>> operator++(int) noexcept;
        constexpr __normal_iterator<const char32_t *, basic_string<char32_t>> &operator--() noexcept;
        constexpr __normal_iterator<const char32_t *, basic_string<char32_t>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<const char32_t *, basic_string<char32_t>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<const char32_t *, basic_string<char32_t>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<const char32_t *, basic_string<char32_t>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<const char32_t *, basic_string<char32_t>> operator-(difference_type __n) const noexcept;
        constexpr const char32_t *const &base() const noexcept;
    };
    template<> class __normal_iterator<int *, std::vector<int>> {
    protected:
        int *_M_current;
        typedef std::iterator_traits<int *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, int *>::value>;
    public:
        typedef int *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<int *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(int *const &__i) noexcept : _M_current(__i) {
        }
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, vector<int, allocator<int>>> &__i) noexcept;
        constexpr reference operator*() const noexcept {
            return *this->_M_current;
        }
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<int *, vector<int>> &operator++() noexcept {
            ++this->_M_current;
            return *this;
        }
        constexpr __normal_iterator<int *, vector<int>> operator++(int) noexcept;
        constexpr __normal_iterator<int *, vector<int>> &operator--() noexcept;
        constexpr __normal_iterator<int *, vector<int>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<int *, vector<int>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<int *, vector<int>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<int *, vector<int>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<int *, vector<int>> operator-(difference_type __n) const noexcept;
        constexpr int *const &base() const noexcept {
            return this->_M_current;
        }
    };
    template<> class __normal_iterator<Base<ChildA, ChildB, ChildC> **, std::vector<Base<ChildA, ChildB, ChildC> *>> {
    protected:
        Base<ChildA, ChildB, ChildC> **_M_current;
        typedef std::iterator_traits<Base<ChildA, ChildB, ChildC> **> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, Base<ChildA, ChildB, ChildC> **>::value>;
    public:
        typedef Base<ChildA, ChildB, ChildC> **iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<Base<ChildA, ChildB, ChildC> **>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(Base<ChildA, ChildB, ChildC> **const &__i) noexcept : _M_current(__i) {
        }
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, vector<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>>> &__i) noexcept;
        constexpr reference operator*() const noexcept {
            return *this->_M_current;
        }
        constexpr pointer operator->() const noexcept;
        constexpr __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *>> &operator++() noexcept {
            ++this->_M_current;
            return *this;
        }
        constexpr __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *>> operator++(int) noexcept;
        constexpr __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *>> &operator--() noexcept;
        constexpr __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *>> operator--(int) noexcept;
        constexpr reference operator[](difference_type __n) const noexcept;
        constexpr __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *>> &operator+=(difference_type __n) noexcept;
        constexpr __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *>> operator+(difference_type __n) const noexcept;
        constexpr __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *>> &operator-=(difference_type __n) noexcept;
        constexpr __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *>> operator-(difference_type __n) const noexcept;
        constexpr Base<ChildA, ChildB, ChildC> **const &base() const noexcept {
            return this->_M_current;
        }
    };
    template <typename _IteratorL, typename _IteratorR, typename _Container> constexpr bool operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())) requires requires { { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>; } [[nodiscard("")]] {
        return __lhs.base() == __rhs.base();
    }
    template<> constexpr bool operator==<Base<ChildA, ChildB, ChildC> **, Base<ChildA, ChildB, ChildC> **, std::vector<Base<ChildA, ChildB, ChildC> *>>(const __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>>> &__lhs, const __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>>> &__rhs) requires requires { { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>; } [[nodiscard("")]]    template<> constexpr bool operator==<int *, int *, std::vector<int>>(const __normal_iterator<int *, vector<int, allocator<int>>> &__lhs, const __normal_iterator<int *, vector<int, allocator<int>>> &__rhs) requires requires { { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>; } [[nodiscard("")]]    template <typename _IteratorL, typename _IteratorR, typename _Container> constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL> operator<=>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base()))) [[nodiscard("")]] {
        return std::__detail::__synth3way(__lhs.base(), __rhs.base());
    }
    template <typename _Iterator, typename _Container> constexpr bool operator==(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())) requires requires { { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>; } [[nodiscard("")]] {
        return __lhs.base() == __rhs.base();
    }
    template<> constexpr bool operator==<Base<ChildA, ChildB, ChildC> **, std::vector<Base<ChildA, ChildB, ChildC> *>>(const __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>>> &__lhs, const __normal_iterator<Base<ChildA, ChildB, ChildC> **, vector<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>>> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())) requires requires { { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>; } [[nodiscard("")]] {
        return __lhs.base() == __rhs.base();
    }
    template<> constexpr bool operator==<int *, std::vector<int>>(const __normal_iterator<int *, vector<int, allocator<int>>> &__lhs, const __normal_iterator<int *, vector<int, allocator<int>>> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())) requires requires { { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>; } [[nodiscard("")]] {
        return __lhs.base() == __rhs.base();
    }
    template <typename _Iterator, typename _Container> constexpr std::__detail::__synth3way_t<_Iterator> operator<=>(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base()))) [[nodiscard("")]] {
        return std::__detail::__synth3way(__lhs.base(), __rhs.base());
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline constexpr auto operator-(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept -> decltype(__lhs.base() - __rhs.base()) [[nodiscard("")]] {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline constexpr typename __normal_iterator<_Iterator, _Container>::difference_type operator-(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept [[nodiscard("")]] {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline constexpr __normal_iterator<_Iterator, _Container> operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n, const __normal_iterator<_Iterator, _Container> &__i) noexcept [[nodiscard("")]] {
        return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
    }
}
namespace std {
    template <typename _Iterator, typename _Container> constexpr _Iterator __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value) {
        return __it.base();
    }
    template <semiregular _Sent> class move_sentinel {
    public:
        constexpr move_sentinel<_Sent>() noexcept(is_nothrow_default_constructible_v<_Sent>) : _M_last() {
        }
        constexpr explicit move_sentinel<_Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>) : _M_last(std::move(__s)) {
        }
        template <typename _S2> constexpr move_sentinel<_Sent>(const move_sentinel<_S2> &__s) noexcept(is_nothrow_constructible_v<_Sent, const _S2 &>) : _M_last(__s.base()) {
        }
        template <typename _S2> constexpr move_sentinel<_Sent> &operator=(const move_sentinel<_S2> &__s) noexcept(is_nothrow_assignable_v<_Sent, const _S2 &>) {
            this->_M_last = __s.base();
            return *this;
        }
        constexpr _Sent base() const noexcept(is_nothrow_copy_constructible_v<_Sent>) [[nodiscard("")]] {
            return this->_M_last;
        }
    private:
        _Sent _M_last;
    };
    namespace __detail {
        template <typename _Iterator> struct __move_iter_cat {
        };
        template <typename _Iterator> struct __move_iter_cat<_Iterator> {
            using iterator_category = __clamp_iter_cat<typename iterator_traits<_Iterator>::iterator_category, random_access_iterator_tag>;
        };
    }
    template <typename _Iterator> class move_iterator : public __detail::__move_iter_cat<_Iterator> {
        _Iterator _M_current;
        using __traits_type = iterator_traits<_Iterator>;
        friend template <typename _Iter2> class move_iterator;
        template <typename _Iter2> static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator> && convertible_to<const _Iter2 &, _Iterator>;
        static auto _S_iter_concept() {
            if (random_access_iterator<_Iterator>)
                return random_access_iterator_tag{};
            else if (bidirectional_iterator<_Iterator>)
                return bidirectional_iterator_tag{};
            else if (forward_iterator<_Iterator>)
                return forward_iterator_tag{};
            else
                return input_iterator_tag{};
        }
    public:
        using iterator_type = _Iterator;
        using iterator_concept = decltype(_S_iter_concept());
        using value_type = iter_value_t<_Iterator>;
        using difference_type = iter_difference_t<_Iterator>;
        using pointer = _Iterator;
        using reference = iter_rvalue_reference_t<_Iterator>;
        constexpr move_iterator<_Iterator>() : _M_current() {
        }
        constexpr explicit move_iterator<_Iterator>(iterator_type __i) : _M_current(std::move(__i)) {
        }
        template <typename _Iter> constexpr move_iterator<_Iterator>(const move_iterator<_Iter> &__i) : _M_current(__i._M_current) {
        }
        template <typename _Iter> constexpr move_iterator<_Iterator> &operator=(const move_iterator<_Iter> &__i) {
            this->_M_current = __i._M_current;
            return *this;
        }
        constexpr const iterator_type &base() const & noexcept [[nodiscard("")]] {
            return this->_M_current;
        }
        constexpr iterator_type base() && [[nodiscard("")]] {
            return std::move(this->_M_current);
        }
        constexpr reference operator*() const [[nodiscard("")]] {
            return ranges::iter_move(this->_M_current);
        }
        constexpr pointer operator->() const [[nodiscard("")]] {
            return this->_M_current;
        }
        constexpr move_iterator<_Iterator> &operator++() {
            ++this->_M_current;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator++(int) {
            move_iterator<_Iterator> __tmp = *this;
            ++this->_M_current;
            return __tmp;
        }
        constexpr void operator++(int) requires (!forward_iterator<_Iterator>) {
            ++this->_M_current;
        }
        constexpr move_iterator<_Iterator> &operator--() {
            --this->_M_current;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator--(int) {
            move_iterator<_Iterator> __tmp = *this;
            --this->_M_current;
            return __tmp;
        }
        constexpr move_iterator<_Iterator> operator+(difference_type __n) const [[nodiscard("")]] {
            return move_iterator<_Iterator>(this->_M_current + __n);
        }
        constexpr move_iterator<_Iterator> &operator+=(difference_type __n) {
            this->_M_current += __n;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator-(difference_type __n) const [[nodiscard("")]] {
            return move_iterator<_Iterator>(this->_M_current - __n);
        }
        constexpr move_iterator<_Iterator> &operator-=(difference_type __n) {
            this->_M_current -= __n;
            return *this;
        }
        constexpr reference operator[](difference_type __n) const [[nodiscard("")]] {
            return ranges::iter_move(this->_M_current + __n);
        }
        friend template <sentinel_for<_Iterator> _Sent> constexpr bool operator==(const move_iterator<_Iterator> &__x, const move_sentinel<_Sent> &__y) [[nodiscard("")]] {
            return __x.base() == __y.base();
        }
;
        friend template <sized_sentinel_for<_Iterator> _Sent> constexpr iter_difference_t<_Iterator> operator-(const move_sentinel<_Sent> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
            return __x.base() - __y.base();
        }
;
        friend template <sized_sentinel_for<_Iterator> _Sent> constexpr iter_difference_t<_Iterator> operator-(const move_iterator<_Iterator> &__x, const move_sentinel<_Sent> &__y) [[nodiscard("")]] {
            return __x.base() - __y.base();
        }
;
        friend constexpr iter_rvalue_reference_t<_Iterator> iter_move(const move_iterator<_Iterator> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))) [[nodiscard("")]] {
            return ranges::iter_move(__i._M_current);
        }
;
        friend template <indirectly_swappable<_Iterator> _Iter2> constexpr void iter_swap(const move_iterator<_Iterator> &__x, const move_iterator<_Iter2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current))) {
            return ranges::iter_swap(__x._M_current, __y._M_current);
        }
;
    };
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator==(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, three_way_comparable_with<_IteratorL> _IteratorR> constexpr compare_three_way_result_t<_IteratorL, _IteratorR> operator<=>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) [[nodiscard("")]] {
        return __x.base() <=> __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return !(__y < __x);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return __y < __x;
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; } [[nodiscard("")]] {
        return !(__x < __y);
    }
    template <typename _Iterator> inline constexpr bool operator==(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return __x.base() == __y.base();
    }
    template <three_way_comparable _Iterator> constexpr compare_three_way_result_t<_Iterator> operator<=>(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]] {
        return __x.base() <=> __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr auto operator-(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base()) [[nodiscard("")]] {
        return __x.base() - __y.base();
    }
    template <typename _Iterator> inline constexpr move_iterator<_Iterator> operator+(typename move_iterator<_Iterator>::difference_type __n, const move_iterator<_Iterator> &__x) [[nodiscard("")]] {
        return __x + __n;
    }
    template <typename _Iterator> inline constexpr move_iterator<_Iterator> make_move_iterator(_Iterator __i) [[nodiscard("")]] {
        return move_iterator<_Iterator>(std::move(__i));
    }
    template <typename _Iterator, typename _ReturnType = __conditional_t<__move_if_noexcept_cond<typename iterator_traits<_Iterator>::value_type>::value, _Iterator, move_iterator<_Iterator>>> inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Iterator __i) {
        return _ReturnType(__i);
    }
    template <typename _Tp, typename _ReturnType = __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp *, move_iterator<_Tp *>>> inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Tp *__i) {
        return _ReturnType(__i);
    }
    namespace __detail {
        template <typename _It> concept __common_iter_has_arrow = indirectly_readable<const _It> && (requires (const _It &__it) { __it.operator->(); } || is_reference_v<iter_reference_t<_It>> || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);
        template <typename _It> concept __common_iter_use_postfix_proxy = (!requires (_It &__i) { { *__i++ } -> __can_reference; }) && constructible_from<iter_value_t<_It>, iter_reference_t<_It>> && move_constructible<iter_value_t<_It>>;
    }
    template <input_or_output_iterator _It, sentinel_for<_It> _Sent> class common_iterator {
        template <typename _Tp, typename _Up> static constexpr bool _S_noexcept1() {
            if (is_trivially_default_constructible_v<_Tp>)
                return is_nothrow_assignable_v<_Tp &, _Up>;
            else
                return is_nothrow_constructible_v<_Tp, _Up>;
        }
        template <typename _It2, typename _Sent2> static constexpr bool _S_noexcept() {
            return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>();
        }
        class __arrow_proxy {
            iter_value_t<_It> _M_keep;
            constexpr __arrow_proxy(iter_reference_t<_It> &&__x) : _M_keep(std::move(__x)) {
            }
            friend  class common_iterator<_It, _Sent>;
        public:
            constexpr const iter_value_t<_It> *operator->() const noexcept {
                return std::__addressof(this->_M_keep);
            }
        };
        class __postfix_proxy {
            iter_value_t<_It> _M_keep;
            constexpr __postfix_proxy(iter_reference_t<_It> &&__x) : _M_keep(std::forward<iter_reference_t<_It>>(__x)) {
            }
            friend  class common_iterator<_It, _Sent>;
        public:
            constexpr const iter_value_t<_It> &operator*() const noexcept {
                return this->_M_keep;
            }
        };
    public:
        constexpr common_iterator<_It, _Sent>() noexcept(is_nothrow_default_constructible_v<_It>) : _M_it(), _M_index(0) requires default_initializable<_It> {
        }
        constexpr common_iterator<_It, _Sent>(_It __i) noexcept(is_nothrow_move_constructible_v<_It>) : _M_it(std::move(__i)), _M_index(0) {
        }
        constexpr common_iterator<_It, _Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>) : _M_sent(std::move(__s)), _M_index(1) {
        }
        template <typename _It2, typename _Sent2> constexpr common_iterator<_It, _Sent>(const common_iterator<_It2, _Sent2> &__x) noexcept(_S_noexcept<const _It2 &, const _Sent2 &>()) : _M_valueless(/*implicit*/(unsigned char)0), _M_index(__x._M_index) {
            do {
                if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                    __builtin_unreachable();
            } while (false);
            if (this->_M_index == 0) {
                if (is_trivially_default_constructible_v<_It>)
                    this->_M_it = std::move(__x._M_it);
                else
                    std::construct_at(std::__addressof(this->_M_it), __x._M_it);
            } else if (this->_M_index == 1) {
                if (is_trivially_default_constructible_v<_Sent>)
                    this->_M_sent = std::move(__x._M_sent);
                else
                    std::construct_at(std::__addressof(this->_M_sent), __x._M_sent);
            }
        }
        common_iterator<_It, _Sent>(const common_iterator<_It, _Sent> &) = default
        constexpr common_iterator<_It, _Sent>(const common_iterator<_It, _Sent> &__x) noexcept(_S_noexcept<const _It &, const _Sent &>()) : _M_valueless(/*implicit*/(unsigned char)0), _M_index(__x._M_index) requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>) {
            if (this->_M_index == 0) {
                if (is_trivially_default_constructible_v<_It>)
                    this->_M_it = __x._M_it;
                else
                    std::construct_at(std::__addressof(this->_M_it), __x._M_it);
            } else if (this->_M_index == 1) {
                if (is_trivially_default_constructible_v<_Sent>)
                    this->_M_sent = __x._M_sent;
                else
                    std::construct_at(std::__addressof(this->_M_sent), __x._M_sent);
            }
        }
        common_iterator<_It, _Sent>(common_iterator<_It, _Sent> &&) = default
        constexpr common_iterator<_It, _Sent>(common_iterator<_It, _Sent> &&__x) noexcept(_S_noexcept<_It, _Sent>()) : _M_valueless(/*implicit*/(unsigned char)0), _M_index(__x._M_index) requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>) {
            if (this->_M_index == 0) {
                if (is_trivially_default_constructible_v<_It>)
                    this->_M_it = std::move(__x._M_it);
                else
                    std::construct_at(std::__addressof(this->_M_it), std::move(__x._M_it));
            } else if (this->_M_index == 1) {
                if (is_trivially_default_constructible_v<_Sent>)
                    this->_M_sent = std::move(__x._M_sent);
                else
                    std::construct_at(std::__addressof(this->_M_sent), std::move(__x._M_sent));
            }
        }
        common_iterator<_It, _Sent> &operator=(const common_iterator<_It, _Sent> &) = default
        constexpr common_iterator<_It, _Sent> &operator=(const common_iterator<_It, _Sent> &__x) noexcept(is_nothrow_copy_assignable_v<_It> && is_nothrow_copy_assignable_v<_Sent> && is_nothrow_copy_constructible_v<_It> && is_nothrow_copy_constructible_v<_Sent>) requires (!is_trivially_copy_assignable_v<_It> || !is_trivially_copy_assignable_v<_Sent>) {
            _M_assign(__x);
            return *this;
        }
        common_iterator<_It, _Sent> &operator=(common_iterator<_It, _Sent> &&) = default
        constexpr common_iterator<_It, _Sent> &operator=(common_iterator<_It, _Sent> &&__x) noexcept(is_nothrow_move_assignable_v<_It> && is_nothrow_move_assignable_v<_Sent> && is_nothrow_move_constructible_v<_It> && is_nothrow_move_constructible_v<_Sent>) requires (!is_trivially_move_assignable_v<_It> || !is_trivially_move_assignable_v<_Sent>) {
            _M_assign(std::move(__x));
            return *this;
        }
        template <typename _It2, typename _Sent2> constexpr common_iterator<_It, _Sent> &operator=(const common_iterator<_It2, _Sent2> &__x) noexcept(is_nothrow_constructible_v<_It, const _It2 &> && is_nothrow_constructible_v<_Sent, const _Sent2 &> && is_nothrow_assignable_v<_It &, const _It2 &> && is_nothrow_assignable_v<_Sent &, const _Sent2 &>) {
            do {
                if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                    __builtin_unreachable();
            } while (false);
            _M_assign(__x);
            return *this;
        }
        constexpr ~common_iterator<_It, _Sent>() {
            if (this->_M_index == 0)
                this->_M_it.~_It();
            else if (this->_M_index == 1)
                this->_M_sent.~_Sent();
        }
        constexpr decltype(auto) operator*() [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_it;
        }
        constexpr decltype(auto) operator*() const requires __detail::__dereferenceable<const _It> [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_it;
        }
        constexpr auto operator->() const requires __detail::__common_iter_has_arrow<_It> [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            if (is_pointer_v<_It> || requires { this->_M_it.operator->(); })
                return this->_M_it;
            else if (is_reference_v<iter_reference_t<_It>>) {
                auto &&__tmp = *this->_M_it;
                return std::__addressof(__tmp);
            } else
                return __arrow_proxy{*this->_M_it};
        }
        constexpr common_iterator<_It, _Sent> &operator++() {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            ++this->_M_it;
            return *this;
        }
        constexpr decltype(auto) operator++(int) {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            if (forward_iterator<_It>) {
                common_iterator<_It, _Sent> __tmp = *this;
                ++*this;
                return __tmp;
            } else if (!__detail::__common_iter_use_postfix_proxy<_It>)
                return this->_M_it++;
            else {
                __postfix_proxy __p(**this);
                ++*this;
                return __p;
            }
        }
        friend template <typename _It2, sentinel_for<_It> _Sent2> constexpr bool operator==(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) [[nodiscard("")]] {
            switch (__x._M_index << 2 | __y._M_index) {
              case 0:
              case 5:
                return true;
              case 1:
                return __x._M_it == __y._M_sent;
              case 4:
                return __x._M_sent == __y._M_it;
              default:
                do {
                    if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                do {
                    if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                __builtin_unreachable();
            }
        }
;
        friend template <typename _It2, sentinel_for<_It> _Sent2> constexpr bool operator==(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) [[nodiscard("")]] {
            switch (__x._M_index << 2 | __y._M_index) {
              case 5:
                return true;
              case 0:
                return __x._M_it == __y._M_it;
              case 1:
                return __x._M_it == __y._M_sent;
              case 4:
                return __x._M_sent == __y._M_it;
              default:
                do {
                    if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                do {
                    if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                __builtin_unreachable();
            }
        }
;
        friend template <sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2> constexpr iter_difference_t<_It2> operator-(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) [[nodiscard("")]] {
            switch (__x._M_index << 2 | __y._M_index) {
              case 5:
                return 0;
              case 0:
                return __x._M_it - __y._M_it;
              case 1:
                return __x._M_it - __y._M_sent;
              case 4:
                return __x._M_sent - __y._M_it;
              default:
                do {
                    if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                do {
                    if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                __builtin_unreachable();
            }
        }
;
        friend constexpr iter_rvalue_reference_t<_It> iter_move(const common_iterator<_It, _Sent> &__i) noexcept(noexcept(ranges::iter_move(std::declval<const _It &>()))) requires input_iterator<_It> [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(__i._M_index == 0))
                    __builtin_unreachable();
            } while (false);
            return ranges::iter_move(__i._M_it);
        }
;
        friend template <indirectly_swappable<_It> _It2, typename _Sent2> constexpr void iter_swap(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) noexcept(noexcept(ranges::iter_swap(std::declval<const _It &>(), std::declval<const _It2 &>()))) {
            do {
                if (std::__is_constant_evaluated() && !bool(__x._M_index == 0))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__y._M_index == 0))
                    __builtin_unreachable();
            } while (false);
            return ranges::iter_swap(__x._M_it, __y._M_it);
        }
;
    private:
        friend template <input_or_output_iterator _It2, sentinel_for<_It2> _Sent2> class common_iterator;
        constexpr bool _M_has_value() const noexcept {
            return this->_M_index != _S_valueless;
        }
        template <typename _CIt> constexpr void _M_assign(_CIt &&__x) {
            if (this->_M_index == __x._M_index) {
                if (this->_M_index == 0)
                    this->_M_it = std::forward<_CIt>(__x)._M_it;
                else if (this->_M_index == 1)
                    this->_M_sent = std::forward<_CIt>(__x)._M_sent;
            } else {
                if (this->_M_index == 0)
                    this->_M_it.~_It();
                else if (this->_M_index == 1)
                    this->_M_sent.~_Sent();
                this->_M_index = _S_valueless;
                if (__x._M_index == 0)
                    std::construct_at(std::__addressof(this->_M_it), std::forward<_CIt>(__x)._M_it);
                else if (__x._M_index == 1)
                    std::construct_at(std::__addressof(this->_M_sent), std::forward<_CIt>(__x)._M_sent);
                this->_M_index = __x._M_index;
            }
        }
        union {
            _It _M_it;
            _Sent _M_sent;
            unsigned char _M_valueless;
        };
        unsigned char _M_index;
        static constexpr unsigned char _S_valueless{2};
    };
    template <typename _It, typename _Sent> struct incrementable_traits<common_iterator<_It, _Sent>> {
        using difference_type = iter_difference_t<_It>;
    };
    template <input_iterator _It, typename _Sent> struct iterator_traits<common_iterator<_It, _Sent>> {
    private:
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using _CIter = common_iterator<_Iter, _Sent>;
            using type = decltype(std::declval<const _CIter &>().operator->());
        };
        static auto _S_iter_cat() {
            using _Traits = iterator_traits<_It>;
            if (requires { requires derived_from<typename _Traits::iterator_category, forward_iterator_tag>; })
                return forward_iterator_tag{};
            else
                return input_iterator_tag{};
        }
    public:
        using iterator_concept = __conditional_t<forward_iterator<_It>, forward_iterator_tag, input_iterator_tag>;
        using iterator_category = decltype(_S_iter_cat());
        using value_type = iter_value_t<_It>;
        using difference_type = iter_difference_t<_It>;
        using pointer = typename __ptr<_It>::type;
        using reference = iter_reference_t<_It>;
    };
    namespace __detail {
        template <typename _It> struct __counted_iter_value_type {
        };
        template <indirectly_readable _It> struct __counted_iter_value_type<_It> {
            using value_type = iter_value_t<_It>;
        };
        template <typename _It> struct __counted_iter_concept {
        };
        template <typename _It> struct __counted_iter_concept<_It> {
            using iterator_concept = typename _It::iterator_concept;
        };
        template <typename _It> struct __counted_iter_cat {
        };
        template <typename _It> struct __counted_iter_cat<_It> {
            using iterator_category = typename _It::iterator_category;
        };
    }
    template <input_or_output_iterator _It> class counted_iterator : public __detail::__counted_iter_value_type<_It>, public __detail::__counted_iter_concept<_It>, public __detail::__counted_iter_cat<_It> {
    public:
        using iterator_type = _It;
        using difference_type = iter_difference_t<_It>;
        counted_iterator<_It>() requires default_initializable<_It> = default
        constexpr counted_iterator<_It>(_It __i, iter_difference_t<_It> __n) : _M_current(std::move(__i)), _M_length(__n) {
            do {
                if (std::__is_constant_evaluated() && !bool(__n >= 0))
                    __builtin_unreachable();
            } while (false);
        }
        template <typename _It2> constexpr counted_iterator<_It>(const counted_iterator<_It2> &__x) : _M_current(__x._M_current), _M_length(__x._M_length) {
        }
        template <typename _It2> constexpr counted_iterator<_It> &operator=(const counted_iterator<_It2> &__x) {
            this->_M_current = __x._M_current;
            this->_M_length = __x._M_length;
            return *this;
        }
        constexpr const _It &base() const & noexcept [[nodiscard("")]] {
            return this->_M_current;
        }
        constexpr _It base() && noexcept(is_nothrow_move_constructible_v<_It>) [[nodiscard("")]] {
            return std::move(this->_M_current);
        }
        constexpr iter_difference_t<_It> count() const noexcept [[nodiscard("")]] {
            return this->_M_length;
        }
        constexpr decltype(auto) operator*() noexcept(noexcept(*this->_M_current)) [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_length > 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_current;
        }
        constexpr decltype(auto) operator*() const noexcept(noexcept(*this->_M_current)) requires __detail::__dereferenceable<const _It> [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_length > 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_current;
        }
        constexpr auto operator->() const noexcept requires contiguous_iterator<_It> [[nodiscard("")]] {
            return std::to_address(this->_M_current);
        }
        constexpr counted_iterator<_It> &operator++() {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_length > 0))
                    __builtin_unreachable();
            } while (false);
            ++this->_M_current;
            --this->_M_length;
            return *this;
        }
        constexpr decltype(auto) operator++(int) {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_length > 0))
                    __builtin_unreachable();
            } while (false);
            --this->_M_length;
            try {
                return this->_M_current++;
            } catch (...) {
                ++this->_M_length;
                throw;
            }
        }
        constexpr counted_iterator<_It> operator++(int) requires forward_iterator<_It> {
            auto __tmp = *this;
            ++*this;
            return __tmp;
        }
        constexpr counted_iterator<_It> &operator--() requires bidirectional_iterator<_It> {
            --this->_M_current;
            ++this->_M_length;
            return *this;
        }
        constexpr counted_iterator<_It> operator--(int) requires bidirectional_iterator<_It> {
            auto __tmp = *this;
            --*this;
            return __tmp;
        }
        constexpr counted_iterator<_It> operator+(iter_difference_t<_It> __n) const requires random_access_iterator<_It> [[nodiscard("")]] {
            return counted_iterator<_It>(this->_M_current + __n, this->_M_length - __n);
        }
        friend constexpr counted_iterator<_It> operator+(iter_difference_t<_It> __n, const counted_iterator<_It> &__x) requires random_access_iterator<_It> [[nodiscard("")]] {
            return __x + __n;
        }
;
        constexpr counted_iterator<_It> &operator+=(iter_difference_t<_It> __n) requires random_access_iterator<_It> {
            do {
                if (std::__is_constant_evaluated() && !bool(__n <= this->_M_length))
                    __builtin_unreachable();
            } while (false);
            this->_M_current += __n;
            this->_M_length -= __n;
            return *this;
        }
        constexpr counted_iterator<_It> operator-(iter_difference_t<_It> __n) const requires random_access_iterator<_It> [[nodiscard("")]] {
            return counted_iterator<_It>(this->_M_current - __n, this->_M_length + __n);
        }
        friend template <common_with<_It> _It2> constexpr iter_difference_t<_It2> operator-(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) [[nodiscard("")]] {
            return __y._M_length - __x._M_length;
        }
;
        friend constexpr iter_difference_t<_It> operator-(const counted_iterator<_It> &__x, default_sentinel_t) [[nodiscard("")]] {
            return - __x._M_length;
        }
;
        friend constexpr iter_difference_t<_It> operator-(default_sentinel_t, const counted_iterator<_It> &__y) [[nodiscard("")]] {
            return __y._M_length;
        }
;
        constexpr counted_iterator<_It> &operator-=(iter_difference_t<_It> __n) requires random_access_iterator<_It> {
            do {
                if (std::__is_constant_evaluated() && !bool(- __n <= this->_M_length))
                    __builtin_unreachable();
            } while (false);
            this->_M_current -= __n;
            this->_M_length += __n;
            return *this;
        }
        constexpr decltype(auto) operator[](iter_difference_t<_It> __n) const noexcept(noexcept(this->_M_current[__n])) requires random_access_iterator<_It> [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(__n < this->_M_length))
                    __builtin_unreachable();
            } while (false);
            return this->_M_current[__n];
        }
        friend template <common_with<_It> _It2> constexpr bool operator==(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) [[nodiscard("")]] {
            return __x._M_length == __y._M_length;
        }
;
        friend constexpr bool operator==(const counted_iterator<_It> &__x, default_sentinel_t) [[nodiscard("")]] {
            return __x._M_length == 0;
        }
;
        friend template <common_with<_It> _It2> constexpr strong_ordering operator<=>(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) [[nodiscard("")]] {
            return __y._M_length <=> __x._M_length;
        }
;
        friend constexpr iter_rvalue_reference_t<_It> iter_move(const counted_iterator<_It> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))) requires input_iterator<_It> [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(__i._M_length > 0))
                    __builtin_unreachable();
            } while (false);
            return ranges::iter_move(__i._M_current);
        }
;
        friend template <indirectly_swappable<_It> _It2> constexpr void iter_swap(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current))) {
            do {
                if (std::__is_constant_evaluated() && !bool(__x._M_length > 0 && __y._M_length > 0))
                    __builtin_unreachable();
            } while (false);
            ranges::iter_swap(__x._M_current, __y._M_current);
        }
;
    private:
        friend template <input_or_output_iterator _It2> class counted_iterator;
        _It _M_current = _It();
        iter_difference_t<_It> _M_length = 0;
    };
    template <input_iterator _It> struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It> {
        using pointer = __conditional_t<contiguous_iterator<_It>, add_pointer_t<iter_reference_t<_It>>, void>;
    };
    template <typename _Iterator> constexpr auto __niter_base(move_iterator<_Iterator> __it) -> decltype(make_move_iterator(__niter_base(__it.base()))) {
        return make_move_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<move_iterator<_Iterator>> {
        enum {
            __value = 1
        };
        typedef __true_type __type;
    };
    template <typename _Iterator> constexpr auto __miter_base(move_iterator<_Iterator> __it) -> decltype(__miter_base(__it.base())) {
        return __miter_base(__it.base());
    }
    template <typename _InputIterator> using __iter_key_t = remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;
    template <typename _InputIterator> using __iter_val_t = typename iterator_traits<_InputIterator>::value_type::second_type;
    template <typename _T1, typename _T2> struct pair;
    template <typename _InputIterator> using __iter_to_alloc_t = pair<const __iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>>;
}
namespace std {
    template <typename _Arg, typename _Result> struct __attribute__((deprecated(""))) unary_function {
        typedef _Arg argument_type;
        typedef _Result result_type;
    };
    template <typename _Arg1, typename _Arg2, typename _Result> struct __attribute__((deprecated(""))) binary_function {
        typedef _Arg1 first_argument_type;
        typedef _Arg2 second_argument_type;
        typedef _Result result_type;
    };
    template<> struct __attribute__((deprecated(""))) __attribute__((deprecated(""))) binary_function<const volatile void *, const volatile void *, bool> {
        typedef const volatile void *first_argument_type;
        typedef const volatile void *second_argument_type;
        typedef bool result_type;
    };
    template<> struct __attribute__((deprecated(""))) __attribute__((deprecated(""))) binary_function<const char *, const char *, bool> {
        typedef const char *first_argument_type;
        typedef const char *second_argument_type;
        typedef bool result_type;
    };
    struct __is_transparent;
    template <typename _Tp = void> struct plus;
    template <typename _Tp = void> struct minus;
    template <typename _Tp = void> struct multiplies;
    template <typename _Tp = void> struct divides;
    template <typename _Tp = void> struct modulus;
    template <typename _Tp = void> struct negate;
    template <typename _Tp = void> struct plus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x + __y;
        }
    };
    template <typename _Tp = void> struct minus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x - __y;
        }
    };
    template <typename _Tp = void> struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x * __y;
        }
    };
    template <typename _Tp = void> struct divides : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x / __y;
        }
    };
    template <typename _Tp = void> struct modulus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x % __y;
        }
    };
    template <typename _Tp = void> struct negate : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const {
            return - __x;
        }
    };
    template<> struct plus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) + std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct minus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) - std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct multiplies<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) * std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct divides<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) / std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct modulus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) % std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct negate<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(- std::forward<_Tp>(__t))) -> decltype(- std::forward<_Tp>(__t)) {
            return - std::forward<_Tp>(__t);
        }
        typedef __is_transparent is_transparent;
    };
    template <typename _Tp = void> struct equal_to;
    template <typename _Tp = void> struct not_equal_to;
    template <typename _Tp = void> struct greater
    template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less
    template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    }
    template<> struct less<const char *> : public binary_function<const char *, const char *, bool> {
        constexpr bool operator()(const char *__x, const char *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal
    template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal
    template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x == __y;
        }
    };
    template <typename _Tp = void> struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x != __y;
        }
    };
    template <typename _Tp = void> struct greater : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x > __y;
        }
    };
    template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x < __y;
        }
    };
    template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template<> struct less<const char *> : public binary_function<const char *, const char *, bool> {
        constexpr bool operator()(const char *__x, const char *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x >= __y;
        }
    };
    template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x <= __y;
        }
    };
    template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template<> struct equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct not_equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) != std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct greater<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u)) {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>{});
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
            return greater<common_type_t<_Tp *, _Up *>>{}(__t, __u);
        }
        typedef __is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
            return std::forward<_Tp>(__t) > std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
            return greater<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>> : false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>> : false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct less<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u)) {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>{});
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
            return less<common_type_t<_Tp *, _Up *>>{}(__t, __u);
        }
        typedef __is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
            return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
            return less<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>> : false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>> : false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct greater_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)) {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>{});
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
            return greater_equal<common_type_t<_Tp *, _Up *>>{}(__t, __u);
        }
        typedef __is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
            return std::forward<_Tp>(__t) >= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
            return greater_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>> : false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>> : false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct less_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)) {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>{});
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
            return less_equal<common_type_t<_Tp *, _Up *>>{}(__t, __u);
        }
        typedef __is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
            return std::forward<_Tp>(__t) <= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
            return less_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>> : false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>> : false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template <typename _Tp = void> struct logical_and;
    template <typename _Tp = void> struct logical_or;
    template <typename _Tp = void> struct logical_not;
    template <typename _Tp = void> struct logical_and : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x && __y;
        }
    };
    template <typename _Tp = void> struct logical_or : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
            return __x || __y;
        }
    };
    template <typename _Tp = void> struct logical_not : public unary_function<_Tp, bool> {
        constexpr bool operator()(const _Tp &__x) const {
            return !__x;
        }
    };
    template<> struct logical_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) && std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct logical_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) || std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct logical_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(!std::forward<_Tp>(__t))) -> decltype(!std::forward<_Tp>(__t)) {
            return !std::forward<_Tp>(__t);
        }
        typedef __is_transparent is_transparent;
    };
    template <typename _Tp = void> struct bit_and;
    template <typename _Tp = void> struct bit_or;
    template <typename _Tp = void> struct bit_xor;
    template <typename _Tp = void> struct bit_not;
    template <typename _Tp = void> struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x & __y;
        }
    };
    template <typename _Tp = void> struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x | __y;
        }
    };
    template <typename _Tp = void> struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
            return __x ^ __y;
        }
    };
    template <typename _Tp = void> struct bit_not : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const {
            return ~__x;
        }
    };
    template<> struct bit_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) & std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct bit_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) | std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct bit_xor<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)) {
            return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u);
        }
        typedef __is_transparent is_transparent;
    };
    template<> struct bit_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(~std::forward<_Tp>(__t))) -> decltype(~std::forward<_Tp>(__t)) {
            return ~std::forward<_Tp>(__t);
        }
        typedef __is_transparent is_transparent;
    };
    template <typename _Predicate> class [[deprecated("")]] unary_negate : public unary_function<typename _Predicate::argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit unary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x) {
        }
        constexpr bool operator()(const typename _Predicate::argument_type &__x) const {
            return !this->_M_pred(__x);
        }
    };
    template <typename _Predicate> inline constexpr unary_negate<_Predicate> not1(const _Predicate &__pred) __attribute__((deprecated("use 'std::not_fn' instead"))) {
        return unary_negate<_Predicate>(__pred);
    }
    template <typename _Predicate> class [[deprecated("")]] binary_negate : public binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit binary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x) {
        }
        constexpr bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const {
            return !this->_M_pred(__x, __y);
        }
    };
    template <typename _Predicate> inline constexpr binary_negate<_Predicate> not2(const _Predicate &__pred) __attribute__((deprecated("use 'std::not_fn' instead"))) {
        return binary_negate<_Predicate>(__pred);
    }
    template <typename _Arg, typename _Result> class __attribute__((deprecated(""))) pointer_to_unary_function : public unary_function<_Arg, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg);
    public:
        pointer_to_unary_function<_Arg, _Result>() {
        }
        explicit pointer_to_unary_function<_Arg, _Result>(_Result (*__x)(_Arg)) : _M_ptr(__x) {
        }
        _Result operator()(_Arg __x) const {
            return this->_M_ptr(__x);
        }
    };
    template <typename _Arg, typename _Result> inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg)) __attribute__((deprecated("use 'std::function' instead"))) {
        return pointer_to_unary_function<_Arg, _Result>(__x);
    }
    template <typename _Arg1, typename _Arg2, typename _Result> class __attribute__((deprecated(""))) pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
        pointer_to_binary_function<_Arg1, _Arg2, _Result>() {
        }
        explicit pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x) {
        }
        _Result operator()(_Arg1 __x, _Arg2 __y) const {
            return this->_M_ptr(__x, __y);
        }
    };
    template <typename _Arg1, typename _Arg2, typename _Result> inline pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2)) __attribute__((deprecated("use 'std::function' instead"))) {
        return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
    }
    template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp> {
        _Tp &operator()(_Tp &__x) const {
            return __x;
        }
        const _Tp &operator()(const _Tp &__x) const {
            return __x;
        }
    };
    template <typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> {
    };
    template <typename _Pair> struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
        typename _Pair::first_type &operator()(_Pair &__x) const {
            return __x.first;
        }
        const typename _Pair::first_type &operator()(const _Pair &__x) const {
            return __x.first;
        }
        template <typename _Pair2> typename _Pair2::first_type &operator()(_Pair2 &__x) const {
            return __x.first;
        }
        template <typename _Pair2> const typename _Pair2::first_type &operator()(const _Pair2 &__x) const {
            return __x.first;
        }
    };
    template <typename _Pair> struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type> {
        typename _Pair::second_type &operator()(_Pair &__x) const {
            return __x.second;
        }
        const typename _Pair::second_type &operator()(const _Pair &__x) const {
            return __x.second;
        }
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) mem_fun_t : public unary_function<_Tp *, _Ret> {
    public:
        explicit mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf) {
        }
        _Ret operator()(_Tp *__p) const {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
    public:
        explicit const_mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {
        }
        _Ret operator()(const _Tp *__p) const {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf) {
        }
        _Ret operator()(_Tp &__r) const {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit const_mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {
        }
        _Ret operator()(const _Tp &__r) const {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
    public:
        explicit mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {
        }
        _Ret operator()(_Tp *__p, _Arg __x) const {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) const_mem_fun1_t : public binary_function<const _Tp *, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {
        }
        _Ret operator()(const _Tp *__p, _Arg __x) const {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {
        }
        _Ret operator()(_Tp &__r, _Arg __x) const {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {
        }
        _Ret operator()(const _Tp &__r, _Arg __x) const {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp> inline mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)()) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return const_mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)()) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return const_mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg)) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg)) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const) __attribute__((deprecated("use 'std::mem_fn' instead"))) {
        return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Func, typename _SfinaeType, typename = __void_t<>> struct __has_is_transparent {
    };
    template <typename _Func, typename _SfinaeType> struct __has_is_transparent<_Func, _SfinaeType, __void_t<typename _Func::is_transparent>> {
        typedef void type;
    };
    template <typename _Func, typename _SfinaeType> using __has_is_transparent_t = typename __has_is_transparent<_Func, _SfinaeType>::type;
}
namespace std {
    template <typename _Operation> class __attribute__((deprecated("use 'std::bind' instead"))) binder1st : public unary_function<typename _Operation::second_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::first_argument_type value;
    public:
        binder1st<_Operation>(const _Operation &__x, const typename _Operation::first_argument_type &__y) : op(__x), value(__y) {
        }
        typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const {
            return this->op(this->value, __x);
        }
        typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const {
            return this->op(this->value, __x);
        }
    };
    template <typename _Operation, typename _Tp> inline binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x) __attribute__((deprecated("use 'std::bind' instead"))) {
        typedef typename _Operation::first_argument_type _Arg1_type;
        return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
    template <typename _Operation> class __attribute__((deprecated("use 'std::bind' instead"))) binder2nd : public unary_function<typename _Operation::first_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::second_argument_type value;
    public:
        binder2nd<_Operation>(const _Operation &__x, const typename _Operation::second_argument_type &__y) : op(__x), value(__y) {
        }
        typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const {
            return this->op(__x, this->value);
        }
        typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const {
            return this->op(__x, this->value);
        }
    };
    template <typename _Operation, typename _Tp> inline binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x) __attribute__((deprecated("use 'std::bind' instead"))) {
        typedef typename _Operation::second_argument_type _Arg2_type;
        return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
}
namespace __gnu_cxx {
    template <typename _Tp> struct __is_integer_nonstrict : public std::__is_integer<_Tp> {
        using std::__is_integer<_Tp>::__value;
        enum {
            __width = __value ? sizeof(_Tp) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<unsigned long long> : public std::__is_integer<unsigned long long> {
        using std::__is_integer<unsigned long long>::__value;
        enum {
            __width = __value ? sizeof(unsigned long long) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<unsigned long> : public std::__is_integer<unsigned long> {
        using std::__is_integer<unsigned long>::__value;
        enum {
            __width = __value ? sizeof(unsigned long) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<unsigned int> : public std::__is_integer<unsigned int> {
        using std::__is_integer<unsigned int>::__value;
        enum {
            __width = __value ? sizeof(unsigned int) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<long> : public std::__is_integer<long> {
        using std::__is_integer<long>::__value;
        enum {
            __width = __value ? sizeof(long) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<int> : public std::__is_integer<int> {
        using std::__is_integer<int>::__value;
        enum {
            __width = __value ? sizeof(int) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<char> : public std::__is_integer<char> {
        using std::__is_integer<char>::__value;
        enum {
            __width = __value ? sizeof(char) * 8 : 0
        };
    };
    template<> struct __is_integer_nonstrict<short> : public std::__is_integer<short> {
        using std::__is_integer<short>::__value;
        enum {
            __width = __value ? sizeof(short) * 8 : 0
        };
    };
    template <typename _Value> struct __numeric_traits_integer {
        static_assert(__is_integer_nonstrict<_Value>::__value, "invalid specialization");
        static const bool __is_signed = (_Value)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<_Value>::__width - __is_signed;
        static const _Value __max = __is_signed ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1) : ~(_Value)0;
        static const _Value __min = __is_signed ? - __max - 1 : (_Value)0;
    };
    template<> struct __numeric_traits_integer<unsigned long long> {
        static_assert(__is_integer_nonstrict<unsigned long long>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned long long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned long long>::__width - __is_signed;
        static const unsigned long long __max = __is_signed ? (((((unsigned long long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned long long)0;
        static const unsigned long long __min = __is_signed ? -__max - 1 : (unsigned long long)0;
    };
    template<> struct __numeric_traits_integer<unsigned long> {
        static_assert(__is_integer_nonstrict<unsigned long>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned long>::__width - __is_signed;
        static const unsigned long __max = __is_signed ? (((((unsigned long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned long)0;
        static const unsigned long __min = __is_signed ? -__max - 1 : (unsigned long)0;
    };
    template<> struct __numeric_traits_integer<unsigned int> {
        static_assert(__is_integer_nonstrict<unsigned int>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned int)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned int>::__width - __is_signed;
        static const unsigned int __max = __is_signed ? (((((unsigned int)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned int)0;
        static const unsigned int __min = __is_signed ? -__max - 1 : (unsigned int)0;
    };
    template<> struct __numeric_traits_integer<unsigned __int128> {
        static_assert(__is_integer_nonstrict<unsigned __int128>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned __int128)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned __int128>::__width - __is_signed;
        static const unsigned __int128 __max = __is_signed ? (((((unsigned __int128)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0;
        static const unsigned __int128 __min = __is_signed ? -__max - 1 : (unsigned __int128)0;
    };
    template<> struct __numeric_traits_integer<long> {
        static_assert(__is_integer_nonstrict<long>::__value, "invalid specialization");
        static const bool __is_signed = (long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<long>::__width - __is_signed;
        static const long __max = __is_signed ? (((((long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(long)0;
        static const long __min = __is_signed ? -__max - 1 : (long)0;
    };
    template<> struct __numeric_traits_integer<int> {
        static_assert(__is_integer_nonstrict<int>::__value, "invalid specialization");
        static const bool __is_signed = (int)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<int>::__width - __is_signed;
        static const int __max = __is_signed ? (((((int)1 << (__digits - 1)) - 1) << 1) + 1) : ~(int)0;
        static const int __min = __is_signed ? -__max - 1 : (int)0;
    };
    template<> struct __numeric_traits_integer<char> {
        static_assert(__is_integer_nonstrict<char>::__value, "invalid specialization");
        static const bool __is_signed = (char)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<char>::__width - __is_signed;
        static const char __max = __is_signed ? (((((char)1 << (__digits - 1)) - 1) << 1) + 1) : ~(char)0;
        static const char __min = __is_signed ? -__max - 1 : (char)0;
    };
    template<> struct __numeric_traits_integer<short> {
        static_assert(__is_integer_nonstrict<short>::__value, "invalid specialization");
        static const bool __is_signed = (short)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<short>::__width - __is_signed;
        static const short __max = __is_signed ? (((((short)1 << (__digits - 1)) - 1) << 1) + 1) : ~(short)0;
        static const short __min = __is_signed ? -__max - 1 : (short)0;
    };
    const _Value __min;
    const _Value __max;
    const bool __is_signed;
    const int __digits;
    template<> struct __is_integer_nonstrict<__int128> {
        enum {
            __value = 1
        };
        typedef std::__true_type __type;
        enum {
            __width = 128
        };
    };
    template<> struct __is_integer_nonstrict<unsigned __int128> {
        enum {
            __value = 1
        };
        typedef std::__true_type __type;
        enum {
            __width = 128
        };
    };
    template <typename _Tp> using __int_traits = __numeric_traits_integer<_Tp>;
    template <typename _Value> struct __numeric_traits_floating {
        static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
    template<> struct __numeric_traits_floating<float> {
        static const int __max_digits10 = (2 + (std::__are_same<float, float>::__value ? 24 : std::__are_same<float, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<float, float>::__value ? 6 : std::__are_same<float, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<float, float>::__value ? 38 : std::__are_same<float, double>::__value ? 308 : 4932);
    };
    template<> struct __numeric_traits_floating<double> {
        static const int __max_digits10 = (2 + (std::__are_same<double, float>::__value ? 24 : std::__are_same<double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<double, float>::__value ? 6 : std::__are_same<double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<double, float>::__value ? 38 : std::__are_same<double, double>::__value ? 308 : 4932);
    };
    template<> struct __numeric_traits_floating<long double> {
        static const int __max_digits10 = (2 + (std::__are_same<long double, float>::__value ? 24 : std::__are_same<long double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<long double, float>::__value ? 6 : std::__are_same<long double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<long double, float>::__value ? 38 : std::__are_same<long double, double>::__value ? 308 : 4932);
    };
    const int __max_digits10;
    const bool __is_signed;
    const int __digits10;
    const int __max_exponent10;
    template <typename _Value> struct __numeric_traits : public __numeric_traits_integer<_Value> {
    };
    template<> struct __numeric_traits<int> : public __numeric_traits_integer<int> {
    };
    template<> struct __numeric_traits<unsigned long> : public __numeric_traits_integer<unsigned long> {
    };
    template<> struct __numeric_traits<char> : public __numeric_traits_integer<char> {
    };
    template<> struct __numeric_traits<long> : public __numeric_traits_integer<long> {
    };
    template<> struct __numeric_traits<short> : public __numeric_traits_integer<short> {
    };
    template<> struct __numeric_traits<float> : public __numeric_traits_floating<float> {
    };
    template<> struct __numeric_traits<double> : public __numeric_traits_floating<double> {
    };
    template<> struct __numeric_traits<long double> : public __numeric_traits_floating<long double> {
    };
    const bool __is_signed;
    const int __digits;
    const unsigned long long __max;
    const bool __is_signed;
    const int __digits;
    const unsigned long __max;
    const bool __is_signed;
    const int __digits;
    const unsigned int __max;
    const bool __is_signed;
    const int __digits;
    const unsigned __int128 __max;
    const bool __is_signed;
    const int __digits;
    const long __max;
    const bool __is_signed;
    const int __digits;
    const int __max;
    const int __min;
    const int __max_exponent10;
    const int __max_exponent10;
    const int __max_exponent10;
    const bool __is_signed;
    const int __digits;
    const char __max;
    const bool __is_signed;
    const int __digits;
    const short __max;
    const short __min;
    const long __min;
}
namespace std {
    template <typename _Tp> struct tuple_size;
    template <typename _Tp, typename _Up = typename remove_cv<_Tp>::type, typename = typename enable_if<is_same<_Tp, _Up>::value>::type, size_t = tuple_size<_Tp>::value> using __enable_if_has_tuple_size = _Tp;
    template <typename _Tp> struct tuple_size<const __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> constexpr size_t tuple_size_v = tuple_size<_Tp>::value;
    template <size_t __i, typename _Tp> struct tuple_element;
    template <size_t __i, typename _Tp> using __tuple_element_t = typename tuple_element<__i, _Tp>::type;
    template <size_t __i, typename _Tp> struct tuple_element<__i, const _Tp> {
        using type = const __tuple_element_t<__i, _Tp>;
    };
    template <size_t __i, typename _Tp> struct tuple_element<__i, volatile _Tp> {
        using type = volatile __tuple_element_t<__i, _Tp>;
    };
    template <size_t __i, typename _Tp> struct tuple_element<__i, const volatile _Tp> {
        using type = const volatile __tuple_element_t<__i, _Tp>;
    };
    template <typename _Tp, typename ..._Types> constexpr size_t __find_uniq_type_in_pack() {
        constexpr size_t __sz = sizeof...(_Types);
        constexpr bool __found[__sz] = {__is_same(_Tp, _Types)...};
        size_t __n = __sz;
        for (size_t __i = 0; __i < __sz; ++__i) {
            if (__found[__i]) {
                if (__n < __sz)
                    return __sz;
                __n = __i;
            }
        }
        return __n;
    }
    template <size_t __i, typename _Tp> using tuple_element_t = typename tuple_element<__i, _Tp>::type;
    template <size_t ..._Indexes> struct _Index_tuple {
    };
    template <size_t _Num> struct _Build_index_tuple {
        template <typename, size_t ..._Indices> using _IdxTuple = _Index_tuple<_Indices...>;
        using __type = __make_integer_seq<_IdxTuple, size_t, _Num>;
    };
    template <typename _Tp, _Tp ..._Idx> struct integer_sequence {
        typedef _Tp value_type;
        static constexpr size_t size() noexcept {
            return sizeof...(_Idx);
        }
    };
    template<> struct integer_sequence<unsigned long, <>> {
        typedef unsigned long value_type;
        static constexpr size_t size() noexcept;
    };
    template <typename _Tp, _Tp _Num> using make_integer_sequence = __make_integer_seq<std::integer_sequence, _Tp, _Num>;
    template <size_t ..._Idx> using index_sequence = integer_sequence<size_t, _Idx...>;
    template <size_t _Num> using make_index_sequence = make_integer_sequence<size_t, _Num>;
    template <typename ..._Types> using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
    struct in_place_t {
        explicit in_place_t() noexcept = default
    };
    constexpr in_place_t in_place{};
    template <typename _Tp> struct in_place_type_t {
        explicit in_place_type_t<_Tp>() = default
    };
    template <typename _Tp> constexpr in_place_type_t<_Tp> in_place_type{};
    template <size_t _Idx> struct in_place_index_t {
        explicit in_place_index_t<_Idx>() = default
    };
    template <size_t _Idx> constexpr in_place_index_t<_Idx> in_place_index{};
    template <typename> constexpr bool __is_in_place_type_v = false;
    constexpr bool __is_in_place_type_v = true;
    template <typename _Tp> using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;
    template <size_t _Np, typename ..._Types> struct _Nth_type {
    };
    template <typename _Tp0, typename ..._Rest> struct _Nth_type<0, _Tp0, _Rest...> {
        using type = _Tp0;
    };
    template <typename _Tp0, typename _Tp1, typename ..._Rest> struct _Nth_type<1, _Tp0, _Tp1, _Rest...> {
        using type = _Tp1;
    };
    template <typename _Tp0, typename _Tp1, typename _Tp2, typename ..._Rest> struct _Nth_type<2, _Tp0, _Tp1, _Tp2, _Rest...> {
        using type = _Tp2;
    };
    template <size_t _Np, typename _Tp0, typename _Tp1, typename _Tp2, typename ..._Rest> struct _Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...> : _Nth_type<_Np - 3, _Rest...> {
    };
}
namespace std {
    struct piecewise_construct_t {
        explicit piecewise_construct_t() noexcept = default
    };
    constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
    template <typename ...> class tuple;
    template <size_t ...> struct _Index_tuple;
    template <typename _U1, typename _U2> class __pair_base {
    };
    template <typename _T1, typename _T2> struct pair : public __pair_base<_T1, _T2> {
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        pair<_T1, _T2>(const pair<_T1, _T2> &) = default
        pair<_T1, _T2>(pair<_T1, _T2> &&) = default
        template <typename ..._Args1, typename ..._Args2> constexpr pair<_T1, _T2>(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        constexpr void swap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::value) {
            using std::swap;
            swap(this->first, __p.first);
            swap(this->second, __p.second);
        }
    private:
        template <typename ..._Args1, size_t ..._Indexes1, typename ..._Args2, size_t ..._Indexes2> constexpr pair<_T1, _T2>(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:
        constexpr explicit(__not_<__and_<__is_implicitly_default_constructible<_T1>, __is_implicitly_default_constructible<_T2>>>()) pair<_T1, _T2>() : first(), second() requires is_default_constructible_v<_T1> && is_default_constructible_v<_T2> {
        }
    private:
        template <typename _U1, typename _U2> static constexpr bool _S_constructible() {
            if (is_constructible_v<_T1, _U1>)
                return is_constructible_v<_T2, _U2>;
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _S_nothrow_constructible() {
            if (is_nothrow_constructible_v<_T1, _U1>)
                return is_nothrow_constructible_v<_T2, _U2>;
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _S_convertible() {
            if (is_convertible_v<_U1, _T1>)
                return is_convertible_v<_U2, _T2>;
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _S_dangles() {
            return false;
        }
    public:
        constexpr explicit(!_S_convertible<const _T1 &, const _T2 &>()) pair<_T1, _T2>(const _T1 &__x, const _T2 &__y) noexcept(_S_nothrow_constructible<const _T1 &, const _T2 &>()) : first(__x), second(__y) requires (_S_constructible<const _T1 &, const _T2 &>()) {
        }
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<_U1, _U2>()) pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) noexcept(_S_nothrow_constructible<_U1, _U2>()) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) {
        }
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<_U1, _U2>()) pair<_T1, _T2>(_U1 &&, _U2 &&) = delete
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<const _U1 &, const _U2 &>()) pair<_T1, _T2>(const pair<_U1, _U2> &__p) noexcept(_S_nothrow_constructible<const _U1 &, const _U2 &>()) : first(__p.first), second(__p.second) {
        }
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<const _U1 &, const _U2 &>()) pair<_T1, _T2>(const pair<_U1, _U2> &) = delete
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<_U1, _U2>()) pair<_T1, _T2>(pair<_U1, _U2> &&__p) noexcept(_S_nothrow_constructible<_U1, _U2>()) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {
        }
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<_U1, _U2>()) pair<_T1, _T2>(pair<_U1, _U2> &&) = delete
    private:
        template <typename _U1, typename _U2> static constexpr bool _S_assignable() {
            if (is_assignable_v<_T1 &, _U1>)
                return is_assignable_v<_T2 &, _U2>;
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _S_nothrow_assignable() {
            if (is_nothrow_assignable_v<_T1 &, _U1>)
                return is_nothrow_assignable_v<_T2 &, _U2>;
            return false;
        }
    public:
        pair<_T1, _T2> &operator=(const pair<_T1, _T2> &) = delete
        constexpr pair<_T1, _T2> &operator=(const pair<_T1, _T2> &__p) noexcept(_S_nothrow_assignable<const _T1 &, const _T2 &>()) requires (_S_assignable<const _T1 &, const _T2 &>()) {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        constexpr pair<_T1, _T2> &operator=(pair<_T1, _T2> &&__p) noexcept(_S_nothrow_assignable<_T1, _T2>()) requires (_S_assignable<_T1, _T2>()) {
            this->first = std::forward<first_type>(__p.first);
            this->second = std::forward<second_type>(__p.second);
            return *this;
        }
        template <typename _U1, typename _U2> constexpr pair<_T1, _T2> &operator=(const pair<_U1, _U2> &__p) noexcept(_S_nothrow_assignable<const _U1 &, const _U2 &>()) requires (_S_assignable<const _U1 &, const _U2 &>()) {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        template <typename _U1, typename _U2> constexpr pair<_T1, _T2> &operator=(pair<_U1, _U2> &&__p) noexcept(_S_nothrow_assignable<_U1, _U2>()) requires (_S_assignable<_U1, _U2>()) {
            this->first = std::forward<_U1>(__p.first);
            this->second = std::forward<_U2>(__p.second);
            return *this;
        }
    };
    template <typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
    template <typename _T1, typename _T2> inline constexpr bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
        return __x.first == __y.first && __x.second == __y.second;
    }
    template <typename _T1, typename _T2> constexpr common_comparison_category_t<__detail::__synth3way_t<_T1>, __detail::__synth3way_t<_T2>> operator<=>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
        if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
            return __c;
        return __detail::__synth3way(__x.second, __y.second);
    }
    template <typename _T1, typename _T2> inline constexpr typename enable_if<__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y))) {
        __x.swap(__y);
    }
    template <typename _T1, typename _T2> typename enable_if<!__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete
    template <typename _T1, typename _T2> constexpr pair<typename __decay_and_strip<_T1>::__type, typename __decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y) {
        typedef typename __decay_and_strip<_T1>::__type __ds_type1;
        typedef typename __decay_and_strip<_T2>::__type __ds_type2;
        typedef pair<__ds_type1, __ds_type2> __pair_type;
        return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
    template <typename _T1, typename _T2> struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type {
    };
    template <class _Tp1, class _Tp2> struct tuple_size<pair<_Tp1, _Tp2>> : public integral_constant<size_t, 2> {
    };
    template <class _Tp1, class _Tp2> struct tuple_element<0, pair<_Tp1, _Tp2>> {
        typedef _Tp1 type;
    };
    template <class _Tp1, class _Tp2> struct tuple_element<1, pair<_Tp1, _Tp2>> {
        typedef _Tp2 type;
    };
    constexpr size_t tuple_size_v = 2;
    constexpr size_t tuple_size_v = 2;
    template <typename _Tp> constexpr bool __is_pair = false;
    constexpr bool __is_pair = true;
    template <size_t _Int> struct __pair_get;
    template<> struct __pair_get<0> {
        template <typename _Tp1, typename _Tp2> static constexpr _Tp1 &__get(pair<_Tp1, _Tp2> &__pair) noexcept {
            return __pair.first;
        }
        template <typename _Tp1, typename _Tp2> static constexpr _Tp1 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept {
            return std::forward<_Tp1>(__pair.first);
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp1 &__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept {
            return __pair.first;
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp1 &&__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept {
            return std::forward<const _Tp1>(__pair.first);
        }
    };
    template<> struct __pair_get<1> {
        template <typename _Tp1, typename _Tp2> static constexpr _Tp2 &__get(pair<_Tp1, _Tp2> &__pair) noexcept {
            return __pair.second;
        }
        template <typename _Tp1, typename _Tp2> static constexpr _Tp2 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept {
            return std::forward<_Tp2>(__pair.second);
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp2 &__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept {
            return __pair.second;
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp2 &&__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept {
            return std::forward<const _Tp2>(__pair.second);
        }
    };
    template <size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(pair<_Tp1, _Tp2> &__in) noexcept {
        return __pair_get<_Int>::__get(__in);
    }
    template <size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(pair<_Tp1, _Tp2> &&__in) noexcept {
        return __pair_get<_Int>::__move_get(std::move(__in));
    }
    template <size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(const pair<_Tp1, _Tp2> &__in) noexcept {
        return __pair_get<_Int>::__const_get(__in);
    }
    template <size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(const pair<_Tp1, _Tp2> &&__in) noexcept {
        return __pair_get<_Int>::__const_move_get(std::move(__in));
    }
    template <typename _Tp, typename _Up> constexpr _Tp &get(pair<_Tp, _Up> &__p) noexcept {
        return __p.first;
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &get(const pair<_Tp, _Up> &__p) noexcept {
        return __p.first;
    }
    template <typename _Tp, typename _Up> constexpr _Tp &&get(pair<_Tp, _Up> &&__p) noexcept {
        return std::move(__p.first);
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &&get(const pair<_Tp, _Up> &&__p) noexcept {
        return std::move(__p.first);
    }
    template <typename _Tp, typename _Up> constexpr _Tp &get(pair<_Up, _Tp> &__p) noexcept {
        return __p.second;
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &get(const pair<_Up, _Tp> &__p) noexcept {
        return __p.second;
    }
    template <typename _Tp, typename _Up> constexpr _Tp &&get(pair<_Up, _Tp> &&__p) noexcept {
        return std::move(__p.second);
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &&get(const pair<_Up, _Tp> &&__p) noexcept {
        return std::move(__p.second);
    }
}
namespace std {
    namespace __debug {
    }
}
namespace __gnu_debug {
    using namespace std::__debug;
    template <typename _Ite, typename _Seq, typename _Cat> struct _Safe_iterator;
}
namespace __gnu_cxx {
    namespace __ops {
        struct _Iter_less_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const {
                return *__it1 < *__it2;
            }
        };
        inline constexpr _Iter_less_iter __iter_less_iter() {
            return _Iter_less_iter();
        }
        struct _Iter_less_val {
            _Iter_less_val() noexcept = default
            constexpr explicit _Iter_less_val(_Iter_less_iter) {
            }
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val) const {
                return *__it < __val;
            }
        };
        inline constexpr _Iter_less_val __iter_less_val() {
            return _Iter_less_val();
        }
        inline constexpr _Iter_less_val __iter_comp_val(_Iter_less_iter) {
            return _Iter_less_val();
        }
        struct _Val_less_iter {
            _Val_less_iter() noexcept = default
            constexpr explicit _Val_less_iter(_Iter_less_iter) {
            }
            template <typename _Value, typename _Iterator> constexpr bool operator()(_Value &__val, _Iterator __it) const {
                return __val < *__it;
            }
        };
        inline constexpr _Val_less_iter __val_less_iter() {
            return _Val_less_iter();
        }
        inline constexpr _Val_less_iter __val_comp_iter(_Iter_less_iter) {
            return _Val_less_iter();
        }
        struct _Iter_equal_to_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const {
                return *__it1 == *__it2;
            }
        };
        inline constexpr _Iter_equal_to_iter __iter_equal_to_iter() {
            return _Iter_equal_to_iter();
        }
        struct _Iter_equal_to_val {
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val) const {
                return *__it == __val;
            }
        };
        inline constexpr _Iter_equal_to_val __iter_equal_to_val() {
            return _Iter_equal_to_val();
        }
        inline constexpr _Iter_equal_to_val __iter_comp_val(_Iter_equal_to_iter) {
            return _Iter_equal_to_val();
        }
        template <typename _Compare> struct _Iter_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp)) {
            }
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) {
                return bool(this->_M_comp(*__it1, *__it2));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp) {
            return _Iter_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Iter_comp_val {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_val<_Compare>(_Compare __comp) : _M_comp(std::move(__comp)) {
            }
            constexpr explicit _Iter_comp_val<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp) {
            }
            constexpr explicit _Iter_comp_val<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp)) {
            }
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val) {
                return bool(this->_M_comp(*__it, __val));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp) {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline constexpr _Iter_comp_val<_Compare> __iter_comp_val(_Iter_comp_iter<_Compare> __comp) {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Val_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Val_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp)) {
            }
            constexpr explicit _Val_comp_iter<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp) {
            }
            constexpr explicit _Val_comp_iter<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp)) {
            }
            template <typename _Value, typename _Iterator> constexpr bool operator()(_Value &__val, _Iterator __it) {
                return bool(this->_M_comp(__val, *__it));
            }
        };
        template <typename _Compare> inline constexpr _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp) {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline constexpr _Val_comp_iter<_Compare> __val_comp_iter(_Iter_comp_iter<_Compare> __comp) {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Value> struct _Iter_equals_val {
            _Value &_M_value;
            constexpr explicit _Iter_equals_val<_Value>(_Value &__value) : _M_value(__value) {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it) {
                return *__it == this->_M_value;
            }
        };
        template <typename _Value> inline constexpr _Iter_equals_val<_Value> __iter_equals_val(_Value &__val) {
            return _Iter_equals_val<_Value>(__val);
        }
        template <typename _Iterator1> struct _Iter_equals_iter {
            _Iterator1 _M_it1;
            constexpr explicit _Iter_equals_iter<_Iterator1>(_Iterator1 __it1) : _M_it1(__it1) {
            }
            template <typename _Iterator2> constexpr bool operator()(_Iterator2 __it2) {
                return *__it2 == *this->_M_it1;
            }
        };
        template <typename _Iterator> inline constexpr _Iter_equals_iter<_Iterator> __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it) {
            return _Iter_equals_iter<_Iterator>(__it);
        }
        template <typename _Predicate> struct _Iter_pred {
            _Predicate _M_pred;
            constexpr explicit _Iter_pred<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred)) {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it) {
                return bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline constexpr _Iter_pred<_Predicate> __pred_iter(_Predicate __pred) {
            return _Iter_pred<_Predicate>(std::move(__pred));
        }
        template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
            _Compare _M_comp;
            _Value &_M_value;
            constexpr _Iter_comp_to_val<_Compare, _Value>(_Compare __comp, _Value &__value) : _M_comp(std::move(__comp)), _M_value(__value) {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it) {
                return bool(this->_M_comp(*__it, this->_M_value));
            }
        };
        template <typename _Compare, typename _Value> constexpr _Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val) {
            return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
        }
        template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
            _Compare _M_comp;
            _Iterator1 _M_it1;
            constexpr _Iter_comp_to_iter<_Compare, _Iterator1>(_Compare __comp, _Iterator1 __it1) : _M_comp(std::move(__comp)), _M_it1(__it1) {
            }
            template <typename _Iterator2> constexpr bool operator()(_Iterator2 __it2) {
                return bool(this->_M_comp(*__it2, *this->_M_it1));
            }
        };
        template <typename _Compare, typename _Iterator> inline constexpr _Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it) {
            return _Iter_comp_to_iter<_Compare, _Iterator>(std::move(__comp._M_comp), __it);
        }
        template <typename _Predicate> struct _Iter_negate {
            _Predicate _M_pred;
            constexpr explicit _Iter_negate<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred)) {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it) {
                return !bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline constexpr _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred) {
            return _Iter_negate<_Predicate>(std::move(__pred._M_pred));
        }
    }
}
namespace std {
    template <typename _To, typename _From> constexpr _To bit_cast(const _From &__from) noexcept requires (sizeof(_To) == sizeof(_From)) && __is_trivially_copyable(_To) && __is_trivially_copyable(_From) [[nodiscard("")]] {
        return __builtin_bit_cast(_To, __from);
    }
    template <typename _Tp> constexpr _Tp __rotl(_Tp __x, int __s) noexcept {
        constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
        if ((_Nd & (_Nd - 1)) == 0) {
            constexpr unsigned int __uNd = _Nd;
            const unsigned int __r = __s;
            return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
        }
        const int __r = __s % _Nd;
        if (__r == 0)
            return __x;
        else if (__r > 0)
            return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
        else
            return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }
    template <typename _Tp> constexpr _Tp __rotr(_Tp __x, int __s) noexcept {
        constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
        if ((_Nd & (_Nd - 1)) == 0) {
            constexpr unsigned int __uNd = _Nd;
            const unsigned int __r = __s;
            return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
        }
        const int __r = __s % _Nd;
        if (__r == 0)
            return __x;
        else if (__r > 0)
            return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
        else
            return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }
    template <typename _Tp> constexpr int __countl_zero(_Tp __x) noexcept {
        using __gnu_cxx::__int_traits;
        constexpr auto _Nd = __int_traits<_Tp>::__digits;
        if (__x == 0)
            return _Nd;
        constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
        constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
        constexpr auto _Nd_u = __int_traits<unsigned int>::__digits;
        if (_Nd <= _Nd_u) {
            constexpr int __diff = _Nd_u - _Nd;
            return __builtin_clz(__x) - __diff;
        } else if (_Nd <= _Nd_ul) {
            constexpr int __diff = _Nd_ul - _Nd;
            return __builtin_clzl(__x) - __diff;
        } else if (_Nd <= _Nd_ull) {
            constexpr int __diff = _Nd_ull - _Nd;
            return __builtin_clzll(__x) - __diff;
        } else {
            static_assert(_Nd <= (2 * _Nd_ull), "Maximum supported integer size is 128-bit");
            unsigned long long __high = __x >> _Nd_ull;
            if (__high != 0) {
                constexpr int __diff = (2 * _Nd_ull) - _Nd;
                return __builtin_clzll(__high) - __diff;
            }
            constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
            unsigned long long __low = __x & __max_ull;
            return (_Nd - _Nd_ull) + __builtin_clzll(__low);
        }
    }
    template <typename _Tp> constexpr int __countl_one(_Tp __x) noexcept {
        return std::__countl_zero<_Tp>((_Tp)~__x);
    }
    template <typename _Tp> constexpr int __countr_zero(_Tp __x) noexcept {
        using __gnu_cxx::__int_traits;
        constexpr auto _Nd = __int_traits<_Tp>::__digits;
        if (__x == 0)
            return _Nd;
        constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
        constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
        constexpr auto _Nd_u = __int_traits<unsigned int>::__digits;
        if (_Nd <= _Nd_u)
            return __builtin_ctz(__x);
        else if (_Nd <= _Nd_ul)
            return __builtin_ctzl(__x);
        else if (_Nd <= _Nd_ull)
            return __builtin_ctzll(__x);
        else {
            static_assert(_Nd <= (2 * _Nd_ull), "Maximum supported integer size is 128-bit");
            constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
            unsigned long long __low = __x & __max_ull;
            if (__low != 0)
                return __builtin_ctzll(__low);
            unsigned long long __high = __x >> _Nd_ull;
            return __builtin_ctzll(__high) + _Nd_ull;
        }
    }
    template <typename _Tp> constexpr int __countr_one(_Tp __x) noexcept {
        return std::__countr_zero((_Tp)~__x);
    }
    template <typename _Tp> constexpr int __popcount(_Tp __x) noexcept {
        using __gnu_cxx::__int_traits;
        constexpr auto _Nd = __int_traits<_Tp>::__digits;
        constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
        constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
        constexpr auto _Nd_u = __int_traits<unsigned int>::__digits;
        if (_Nd <= _Nd_u)
            return __builtin_popcount(__x);
        else if (_Nd <= _Nd_ul)
            return __builtin_popcountl(__x);
        else if (_Nd <= _Nd_ull)
            return __builtin_popcountll(__x);
        else {
            static_assert(_Nd <= (2 * _Nd_ull), "Maximum supported integer size is 128-bit");
            constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
            unsigned long long __low = __x & __max_ull;
            unsigned long long __high = __x >> _Nd_ull;
            return __builtin_popcountll(__low) + __builtin_popcountll(__high);
        }
    }
    template <typename _Tp> constexpr bool __has_single_bit(_Tp __x) noexcept {
        return std::__popcount(__x) == 1;
    }
    template <typename _Tp> constexpr _Tp __bit_ceil(_Tp __x) noexcept {
        using __gnu_cxx::__int_traits;
        constexpr auto _Nd = __int_traits<_Tp>::__digits;
        if (__x == 0 || __x == 1)
            return 1;
        auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1U));
        if (!std::__is_constant_evaluated()) {
            do {
                if (std::__is_constant_evaluated() && !bool(__shift_exponent != __int_traits<_Tp>::__digits))
                    __builtin_unreachable();
            } while (false);
        }
        using __promoted_type = decltype(__x << 1);
        if (!is_same<__promoted_type, _Tp>::value) {
            const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
            __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
        }
        return (_Tp)1U << __shift_exponent;
    }
    template <typename _Tp> constexpr _Tp __bit_floor(_Tp __x) noexcept {
        constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
        if (__x == 0)
            return 0;
        return (_Tp)1U << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }
    template <typename _Tp> constexpr int __bit_width(_Tp __x) noexcept {
        constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
        return _Nd - std::__countl_zero(__x);
    }
    template <typename _Tp, typename _Up = _Tp> using _If_is_unsigned_integer = enable_if_t<__is_unsigned_integer<_Tp>::value, _Up>;
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp> rotl(_Tp __x, int __s) noexcept [[nodiscard("")]] {
        return std::__rotl(__x, __s);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp> rotr(_Tp __x, int __s) noexcept [[nodiscard("")]] {
        return std::__rotr(__x, __s);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp, int> countl_zero(_Tp __x) noexcept {
        return std::__countl_zero(__x);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp, int> countl_one(_Tp __x) noexcept {
        return std::__countl_one(__x);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp, int> countr_zero(_Tp __x) noexcept {
        return std::__countr_zero(__x);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp, int> countr_one(_Tp __x) noexcept {
        return std::__countr_one(__x);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp, int> popcount(_Tp __x) noexcept {
        return std::__popcount(__x);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp, bool> has_single_bit(_Tp __x) noexcept {
        return std::__has_single_bit(__x);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp> bit_ceil(_Tp __x) noexcept {
        return std::__bit_ceil(__x);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp> bit_floor(_Tp __x) noexcept {
        return std::__bit_floor(__x);
    }
    template <typename _Tp> constexpr _If_is_unsigned_integer<_Tp, int> bit_width(_Tp __x) noexcept {
        return std::__bit_width(__x);
    }
    enum class endian : int {
        little = 1234,
        big = 4321,
        native = 1234
    };
}
namespace std {
    template <typename _Tp, typename _Up> inline constexpr int __memcmp(const _Tp *__first1, const _Up *__first2, size_t __num) {
        static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
        if (std::is_constant_evaluated()) {
            for (; __num > 0; ++__first1 , ++__first2 , --__num)
                if (*__first1 != *__first2)
                    return *__first1 < *__first2 ? -1 : 1;
            return 0;
        } else
            return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline constexpr void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) {
        swap(*__a, *__b);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> constexpr _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            std::iter_swap(__first1, __first2);
        return __first2;
    }
    template <typename _Tp> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b) {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const unsigned long &min<unsigned long>(const unsigned long &__a, const unsigned long &__b) {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const long &min<long>(const long &__a, const long &__b) {
        if (__b < __a)
            return __b;
        return __a;
    }
    template <typename _Tp> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b) {
        if (__a < __b)
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp) {
        if (__comp(__b, __a))
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp) {
        if (__comp(__a, __b))
            return __b;
        return __a;
    }
    template <typename _Iterator> inline constexpr _Iterator __niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value) {
        return __it;
    }
    template<> inline constexpr unsigned long *__niter_base<unsigned long *>(unsigned long *__it) noexcept(std::is_nothrow_copy_constructible<unsigned long *>::value) {
        return __it;
    }
    template<> inline constexpr std::_Bit_const_iterator __niter_base<std::_Bit_const_iterator>(std::_Bit_const_iterator __it) noexcept(std::is_nothrow_copy_constructible<_Bit_const_iterator>::value) {
        return __it;
    }
    template<> inline constexpr std::_Bit_iterator __niter_base<std::_Bit_iterator>(std::_Bit_iterator __it) noexcept(std::is_nothrow_copy_constructible<_Bit_iterator>::value) {
        return __it;
    }
    template<> inline constexpr const int *__niter_base<const int *>(const int *__it) noexcept(std::is_nothrow_copy_constructible<const int *>::value) {
        return __it;
    }
    template<> inline constexpr int *__niter_base<int *>(int *__it) noexcept(std::is_nothrow_copy_constructible<int *>::value) {
        return __it;
    }
    template<> inline constexpr Base<ChildA, ChildB, ChildC> *const *__niter_base<Base<ChildA, ChildB, ChildC> *const *>(Base<ChildA, ChildB, ChildC> *const *__it) noexcept(std::is_nothrow_copy_constructible<Base<ChildA, ChildB, ChildC> *const *>::value) {
        return __it;
    }
    template<> inline constexpr Base<ChildA, ChildB, ChildC> **__niter_base<Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> **__it) noexcept(std::is_nothrow_copy_constructible<Base<ChildA, ChildB, ChildC> **>::value) {
        return __it;
    }
    template <typename _Ite, typename _Seq> _Ite __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, std::random_access_iterator_tag> &);
    template <typename _From, typename _To> inline constexpr _From __niter_wrap(_From __from, _To __res) {
        return __from + (__res - std::__niter_base(__from));
    }
    template<> inline constexpr unsigned long *__niter_wrap<unsigned long *, unsigned long *>(unsigned long *__from, unsigned long *__res)    template<> inline constexpr std::_Bit_iterator __niter_wrap<std::_Bit_iterator, std::_Bit_iterator>(std::_Bit_iterator __from, std::_Bit_iterator __res)    template<> inline constexpr int *__niter_wrap<int *, int *>(int *__from, int *__res)    template<> inline constexpr Base<ChildA, ChildB, ChildC> **__niter_wrap<Base<ChildA, ChildB, ChildC> **, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> **__from, Base<ChildA, ChildB, ChildC> **__res)    template <typename _Iterator> inline constexpr _Iterator __niter_wrap(const _Iterator &, _Iterator __res) {
        return __res;
    }
    template<> inline constexpr unsigned long *__niter_wrap<unsigned long *>(unsigned long *const &, unsigned long *__res) {
        return __res;
    }
    template<> inline constexpr std::_Bit_iterator __niter_wrap<std::_Bit_iterator>(const std::_Bit_iterator &, std::_Bit_iterator __res) {
        return __res;
    }
    template<> inline constexpr int *__niter_wrap<int *>(int *const &, int *__res) {
        return __res;
    }
    template<> inline constexpr Base<ChildA, ChildB, ChildC> **__niter_wrap<Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> **const &, Base<ChildA, ChildB, ChildC> **__res) {
        return __res;
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result) {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = *__first;
            return __result;
        }
    };
    template<> struct __copy_move<false, true, std::random_access_iterator_tag> {
        template <typename _Tp, typename _Up> static constexpr _Up *__copy_m(_Tp *__first, _Tp *__last, _Up *__result);
        template<> static constexpr unsigned long *__copy_m<unsigned long, unsigned long>(unsigned long *__first, unsigned long *__last, unsigned long *__result) {
            const ptrdiff_t _Num = __last - __first;
            if (__builtin_expect(_Num > 1, true))
                __builtin_memmove(__result, __first, sizeof(unsigned long) * _Num);
            else if (_Num == 1)
                std::__copy_move<false, false, random_access_iterator_tag>::__assign_one(__result, __first);
            return __result + _Num;
        }
;
        template<> static constexpr int *__copy_m<const int, int>(const int *__first, const int *__last, int *__result) {
            const ptrdiff_t _Num = __last - __first;
            if (__builtin_expect(_Num > 1, true))
                __builtin_memmove(__result, __first, sizeof(const int) * _Num);
            else if (_Num == 1)
                std::__copy_move<false, false, random_access_iterator_tag>::__assign_one(__result, __first);
            return __result + _Num;
        }
;
        template<> static constexpr Base<ChildA, ChildB, ChildC> **__copy_m<Base<ChildA, ChildB, ChildC> *const, Base<ChildA, ChildB, ChildC> *>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
            const ptrdiff_t _Num = __last - __first;
            if (__builtin_expect(_Num > 1, true))
                __builtin_memmove(__result, __first, sizeof(Base<ChildA, ChildB, ChildC> *const) * _Num);
            else if (_Num == 1)
                std::__copy_move<false, false, random_access_iterator_tag>::__assign_one(__result, __first);
            return __result + _Num;
        }
;
    };
    template <typename _Category> struct __copy_move<true, false, _Category> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result) {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = std::move(*__first);
            return __result;
        }
    };
    template<> struct __copy_move<false, false, random_access_iterator_tag> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result) {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template<> static constexpr unsigned long *__copy_m<unsigned long *, unsigned long *>(unsigned long *__first, unsigned long *__last, unsigned long *__result) {
            typedef typename iterator_traits<unsigned long *>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template<> static constexpr std::_Bit_iterator __copy_m<std::_Bit_const_iterator, std::_Bit_iterator>(std::_Bit_const_iterator __first, std::_Bit_const_iterator __last, std::_Bit_iterator __result) {
            typedef typename iterator_traits<_Bit_const_iterator>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                * __result = * __first;
                ++ __first;
                ++ __result;
            }
            return __result;
        }
        template<> static constexpr std::_Bit_iterator __copy_m<std::_Bit_iterator, std::_Bit_iterator>(std::_Bit_iterator __first, std::_Bit_iterator __last, std::_Bit_iterator __result) {
            typedef typename iterator_traits<_Bit_iterator>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                * __result = * __first;
                ++ __first;
                ++ __result;
            }
            return __result;
        }
        template<> static constexpr int *__copy_m<const int *, int *>(const int *__first, const int *__last, int *__result) {
            typedef typename iterator_traits<const int *>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template<> static constexpr Base<ChildA, ChildB, ChildC> **__copy_m<Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
            typedef typename iterator_traits<Base<ChildA, ChildB, ChildC> *const *>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template <typename _Tp, typename _Up> static void __assign_one(_Tp *__to, _Up *__from) {
            *__to = *__from;
        }
        template<> static void __assign_one<unsigned long, unsigned long>(unsigned long *__to, unsigned long *__from) {
            *__to = *__from;
        }
        template<> static void __assign_one<int, const int>(int *__to, const int *__from) {
            *__to = *__from;
        }
        template<> static void __assign_one<Base<ChildA, ChildB, ChildC> *, Base<ChildA, ChildB, ChildC> *const>(Base<ChildA, ChildB, ChildC> **__to, Base<ChildA, ChildB, ChildC> *const *__from) {
            *__to = *__from;
        }
    };
    template<> struct __copy_move<true, false, random_access_iterator_tag> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result) {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = std::move(*__first);
                ++__first;
                ++__result;
            }
            return __result;
        }
        template <typename _Tp, typename _Up> static void __assign_one(_Tp *__to, _Up *__from) {
            *__to = std::move(*__from);
        }
    };
    template <bool _IsMove> struct __copy_move<_IsMove, true, random_access_iterator_tag> {
        template <typename _Tp, typename _Up> static constexpr _Up *__copy_m(_Tp *__first, _Tp *__last, _Up *__result) {
            const ptrdiff_t _Num = __last - __first;
            if (__builtin_expect(_Num > 1, true))
                __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
            else if (_Num == 1)
                std::__copy_move<_IsMove, false, random_access_iterator_tag>::__assign_one(__result, __first);
            return __result + _Num;
        }
    };
    template <typename _Tp, typename _Ref, typename _Ptr> struct _Deque_iterator;
    struct _Bit_iterator;
    template <typename _CharT> struct char_traits;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>, istreambuf_iterator<_CharT, char_traits<_CharT>>, _CharT *);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>, istreambuf_iterator<_CharT, char_traits<_CharT>>, std::_Deque_iterator<_CharT, _CharT &, _CharT *>);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a2(_II __first, _II __last, _OI __result) {
        typedef typename iterator_traits<_II>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<_IsMove, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr unsigned long *__copy_move_a2<false, unsigned long *, unsigned long *>(unsigned long *__first, unsigned long *__last, unsigned long *__result) {
        typedef typename iterator_traits<unsigned long *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<unsigned long *, unsigned long *>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr std::_Bit_iterator __copy_move_a2<false, std::_Bit_const_iterator, std::_Bit_iterator>(std::_Bit_const_iterator __first, std::_Bit_const_iterator __last, std::_Bit_iterator __result) {
        typedef typename iterator_traits<_Bit_const_iterator>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<_Bit_iterator, _Bit_const_iterator>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr std::_Bit_iterator __copy_move_a2<false, std::_Bit_iterator, std::_Bit_iterator>(std::_Bit_iterator __first, std::_Bit_iterator __last, std::_Bit_iterator __result) {
        typedef typename iterator_traits<_Bit_iterator>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<_Bit_iterator, _Bit_iterator>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr int *__copy_move_a2<false, const int *, int *>(const int *__first, const int *__last, int *__result) {
        typedef typename iterator_traits<const int *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<int *, const int *>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr Base<ChildA, ChildB, ChildC> **__copy_move_a2<false, Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
        typedef typename iterator_traits<Base<ChildA, ChildB, ChildC> *const *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<Base<ChildA, ChildB, ChildC> **, Base<ChildA, ChildB, ChildC> *const *>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a1(_II __first, _II __last, _OI __result) {
        return std::__copy_move_a2<_IsMove>(__first, __last, __result);
    }
    template<> inline constexpr unsigned long *__copy_move_a1<false, unsigned long *, unsigned long *>(unsigned long *__first, unsigned long *__last, unsigned long *__result) {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr std::_Bit_iterator __copy_move_a1<false, std::_Bit_const_iterator, std::_Bit_iterator>(std::_Bit_const_iterator __first, std::_Bit_const_iterator __last, std::_Bit_iterator __result) {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr std::_Bit_iterator __copy_move_a1<false, std::_Bit_iterator, std::_Bit_iterator>(std::_Bit_iterator __first, std::_Bit_iterator __last, std::_Bit_iterator __result) {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr int *__copy_move_a1<false, const int *, int *>(const int *__first, const int *__last, int *__result) {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr Base<ChildA, ChildB, ChildC> **__copy_move_a1<false, Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a(_II __first, _II __last, _OI __result) {
        return std::__niter_wrap(__result, std::__copy_move_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr unsigned long *__copy_move_a<false, unsigned long *, unsigned long *>(unsigned long *__first, unsigned long *__last, unsigned long *__result) {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr std::_Bit_iterator __copy_move_a<false, std::_Bit_const_iterator, std::_Bit_iterator>(std::_Bit_const_iterator __first, std::_Bit_const_iterator __last, std::_Bit_iterator __result) {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr std::_Bit_iterator __copy_move_a<false, std::_Bit_iterator, std::_Bit_iterator>(std::_Bit_iterator __first, std::_Bit_iterator __last, std::_Bit_iterator __result) {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr int *__copy_move_a<false, const int *, int *>(const int *__first, const int *__last, int *__result) {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr Base<ChildA, ChildB, ChildC> **__copy_move_a<false, Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _InputIterator, typename _Size, typename _OutputIterator> constexpr _OutputIterator __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result, bool) {
        if (__n > 0) {
            while (true)
                {
                    *__result = *__first;
                    ++__result;
                    if (--__n > 0)
                        ++__first;
                    else
                        break;
                }
        }
        return __result;
    }
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size, _CharT *, bool);
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size, std::_Deque_iterator<_CharT, _CharT &, _CharT *>, bool);
    template <typename _II, typename _OI> inline constexpr _OI copy(_II __first, _II __last, _OI __result) {
        ;
        return std::__copy_move_a<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr unsigned long *copy<unsigned long *, unsigned long *>(unsigned long *__first, unsigned long *__last, unsigned long *__result) {
        ;
        return std::__copy_move_a<__is_move_iterator<unsigned long *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr std::_Bit_iterator copy<std::_Bit_const_iterator, std::_Bit_iterator>(std::_Bit_const_iterator __first, std::_Bit_const_iterator __last, std::_Bit_iterator __result) {
        ;
        return std::__copy_move_a<__is_move_iterator<_Bit_const_iterator>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr std::_Bit_iterator copy<std::_Bit_iterator, std::_Bit_iterator>(std::_Bit_iterator __first, std::_Bit_iterator __last, std::_Bit_iterator __result) {
        ;
        return std::__copy_move_a<__is_move_iterator<_Bit_iterator>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr int *copy<const int *, int *>(const int *__first, const int *__last, int *__result) {
        ;
        return std::__copy_move_a<__is_move_iterator<const int *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr Base<ChildA, ChildB, ChildC> **copy<Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
        ;
        return std::__copy_move_a<__is_move_iterator<Base<ChildA, ChildB, ChildC> *const *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _II, typename _OI> inline constexpr _OI move(_II __first, _II __last, _OI __result) {
        ;
        return std::__copy_move_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move_backward<true, false, _Category> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
            while (__first != __last)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template<> struct __copy_move_backward<false, false, random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
    };
    template<> struct __copy_move_backward<true, false, random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move_backward<_IsMove, true, random_access_iterator_tag> {
        template <typename _Tp, typename _Up> static constexpr _Up *__copy_move_b(_Tp *__first, _Tp *__last, _Up *__result) {
            const ptrdiff_t _Num = __last - __first;
            if (__builtin_expect(_Num > 1, true))
                __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
            else if (_Num == 1)
                std::__copy_move<_IsMove, false, random_access_iterator_tag>::__assign_one(__result - 1, __first);
            return __result - _Num;
        }
    };
    template <bool _IsMove, typename _BI1, typename _BI2> inline constexpr _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result) {
        typedef typename iterator_traits<_BI1>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move_backward<_IsMove, false, _Category>::__copy_move_b(__first, __last, __result);
        return std::__copy_move_backward<_IsMove, __memcpyable<_BI2, _BI1>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template <bool _IsMove, typename _BI1, typename _BI2> inline constexpr _BI2 __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result) {
        return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result);
    }
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_backward_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_backward_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_backward_a(_II __first, _II __last, _OI __result) {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_backward_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _BI1, typename _BI2> inline constexpr _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _BI1, typename _BI2> inline constexpr _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result) {
        ;
        return std::__copy_move_backward_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) {
        for (; __first != __last; ++__first)
            *__first = __value;
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) {
        const _Tp __tmp = __value;
        for (; __first != __last; ++__first)
            *__first = __tmp;
    }
    template<> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<bool>::__value, void>::__type __fill_a1<std::_Bit_iterator, bool>(std::_Bit_iterator __first, std::_Bit_iterator __last, const bool &__value)    template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a1(_Tp *__first, _Tp *__last, const _Tp &__c) {
        const _Tp __tmp = __c;
        if (std::is_constant_evaluated()) {
            for (; __first != __last; ++__first)
                *__first = __tmp;
            return;
        }
        if (const size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
    template <typename _Ite, typename _Cont, typename _Tp> inline constexpr void __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first, ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last, const _Tp &__value) {
        std::__fill_a1(__first.base(), __last.base(), __value);
    }
    template <typename _Tp, typename _VTp> void __fill_a1(const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const _VTp &);
    constexpr void __fill_a1(std::_Bit_iterator, std::_Bit_iterator, const bool &);
    template <typename _FIte, typename _Tp> inline constexpr void __fill_a(_FIte __first, _FIte __last, const _Tp &__value) {
        std::__fill_a1(__first, __last, __value);
    }
    template<> inline constexpr void __fill_a<std::_Bit_iterator, bool>(std::_Bit_iterator __first, std::_Bit_iterator __last, const bool &__value) {
        std::__fill_a1(__first, __last, __value);
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Tp> void __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const _Tp &);
    template <typename _ForwardIterator, typename _Tp> inline constexpr void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) {
        ;
        std::__fill_a(__first, __last, __value);
    }
    template<> inline constexpr void fill<std::_Bit_iterator, bool>(std::_Bit_iterator __first, std::_Bit_iterator __last, const bool &__value) {
        ;
        std::__fill_a(__first, __last, __value);
    }
    inline constexpr int __size_to_integer(int __n) {
        return __n;
    }
    inline constexpr unsigned int __size_to_integer(unsigned int __n) {
        return __n;
    }
    inline constexpr long __size_to_integer(long __n) {
        return __n;
    }
    inline constexpr unsigned long __size_to_integer(unsigned long __n) {
        return __n;
    }
    inline constexpr long long __size_to_integer(long long __n) {
        return __n;
    }
    inline constexpr unsigned long long __size_to_integer(unsigned long long __n) {
        return __n;
    }
    inline constexpr long long __size_to_integer(float __n) {
        return (long long)__n;
    }
    inline constexpr long long __size_to_integer(double __n) {
        return (long long)__n;
    }
    inline constexpr long long __size_to_integer(long double __n) {
        return (long long)__n;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value) {
        for (; __n > 0; --__n , (void)++__first)
            *__first = __value;
        return __first;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value) {
        const _Tp __tmp = __value;
        for (; __n > 0; --__n , (void)++__first)
            *__first = __tmp;
        return __first;
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Size, typename _Tp> ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &__first, _Size __n, const _Tp &__value, std::input_iterator_tag);
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::output_iterator_tag) {
        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::input_iterator_tag) {
        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::random_access_iterator_tag) {
        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
        if (__n <= 0)
            return __first;
        ;
        std::__fill_a(__first, __first + __n, __value);
        return __first + __n;
    }
    template <typename _OI, typename _Size, typename _Tp> inline constexpr _OI fill_n(_OI __first, _Size __n, const _Tp &__value) {
        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value, std::__iterator_category(__first));
    }
    template <bool _BoolType> struct __equal {
        template <typename _II1, typename _II2> static constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2) {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!(*__first1 == *__first2))
                    return false;
            return true;
        }
    };
    template<> struct __equal<true> {
        template <typename _Tp> static constexpr bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2) {
            if (const size_t __len = (__last1 - __first1))
                return !std::__memcmp(__first1, __first2, __len);
            return true;
        }
    };
    template <typename _Tp, typename _Ref, typename _Ptr, typename _II> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _II);
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _II, typename _Tp, typename _Ref, typename _Ptr> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(_II, _II, std::_Deque_iterator<_Tp, _Ref, _Ptr>);
    template <typename _II1, typename _II2> inline constexpr bool __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2) {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        const bool __simple = ((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __memcmpable<_II1, _II2>::__value);
        return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }
    template <typename _II1, typename _II2> inline constexpr bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2) {
        return std::__equal_aux1(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
    }
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, _II2);
    template <typename _II1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(_II1, _II1, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename, typename> struct __lc_rai {
        template <typename _II1, typename _II2> static constexpr _II1 __newlast1(_II1, _II1 __last1, _II2, _II2) {
            return __last1;
        }
        template <typename _II> static constexpr bool __cnd2(_II __first, _II __last) {
            return __first != __last;
        }
    };
    template<> struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag> {
        template <typename _RAI1, typename _RAI2> static constexpr _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2) {
            const typename iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
            const typename iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
            return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
        }
        template <typename _RAI> static constexpr bool __cnd2(_RAI, _RAI) {
            return true;
        }
    };
    template <typename _II1, typename _II2, typename _Compare> constexpr bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp) {
        typedef typename iterator_traits<_II1>::iterator_category _Category1;
        typedef typename iterator_traits<_II2>::iterator_category _Category2;
        typedef std::__lc_rai<_Category1, _Category2> __rai_type;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ++__first1 , (void)++__first2) {
            if (__comp(__first1, __first2))
                return true;
            if (__comp(__first2, __first1))
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }
    template <bool _BoolType> struct __lexicographical_compare {
        template <typename _II1, typename _II2> static constexpr bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
            using __gnu_cxx::__ops::__iter_less_iter;
            return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __iter_less_iter());
        }
        template <typename _II1, typename _II2> static constexpr int __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
            while (__first1 != __last1)
                {
                    if (__first2 == __last2)
                        return +1;
                    if (*__first1 < *__first2)
                        return -1;
                    if (*__first2 < *__first1)
                        return +1;
                    ++__first1;
                    ++__first2;
                }
            return int(__first2 == __last2) - 1;
        }
    };
    template<> struct __lexicographical_compare<true> {
        template <typename _Tp, typename _Up> static constexpr bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2) {
            return __3way(__first1, __last1, __first2, __last2) < 0;
        }
        template <typename _Tp, typename _Up> static constexpr ptrdiff_t __3way(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2) {
            const size_t __len1 = __last1 - __first1;
            const size_t __len2 = __last2 - __first2;
            if (const size_t __len = std::min(__len1, __len2))
                if (int __result = std::__memcmp(__first1, __first2, __len))
                    return __result;
            return ptrdiff_t(__len1 - __len2);
        }
    };
    template <typename _II1, typename _II2> inline constexpr bool __lexicographical_compare_aux1(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>> && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>);
        return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
    }
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2> bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, _Tp2 *, _Tp2 *);
    template <typename _Tp1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __lexicographical_compare_aux1(_Tp1 *, _Tp1 *, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _II1, typename _II2> inline constexpr bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        return std::__lexicographical_compare_aux1(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
    }
    template <typename _Iter1, typename _Seq1, typename _Cat1, typename _II2> bool __lexicographical_compare_aux(const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, _II2, _II2);
    template <typename _II1, typename _Iter2, typename _Seq2, typename _Cat2> bool __lexicographical_compare_aux(_II1, _II1, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);
    template <typename _Iter1, typename _Seq1, typename _Cat1, typename _Iter2, typename _Seq2, typename _Cat2> bool __lexicographical_compare_aux(const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);
    template <typename _ForwardIterator, typename _Tp, typename _Compare> constexpr _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp) {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp(__middle, __val)) {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                } else
                    __len = __half;
            }
        return __first;
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val) {
        ;
        return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
    }
    template <typename _Tp> inline constexpr _Tp __lg(_Tp __n) {
        return std::__bit_width(make_unsigned_t<_Tp>(__n)) - 1;
    }
    template <typename _II1, typename _II2> inline constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2) {
        ;
        return std::__equal_aux(__first1, __last1, __first2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline constexpr bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred) {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return true;
    }
    template <typename _II1, typename _II2> inline constexpr bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        using _RATag = random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!(*__first1 == *__first2))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2, typename _BinaryPredicate> inline constexpr bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _BinaryPredicate __binary_pred) {
        using _RATag = random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2, __binary_pred);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2> inline constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline constexpr bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred) {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred);
    }
    template <typename _II1, typename _II2> inline constexpr bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
        ;
        ;
        return std::__lexicographical_compare_aux(__first1, __last1, __first2, __last2);
    }
    template <typename _II1, typename _II2, typename _Compare> inline constexpr bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp) {
        ;
        ;
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
    template <typename _Iter> concept __is_byte_iter = contiguous_iterator<_Iter> && __is_memcmp_ordered<iter_value_t<_Iter>>::__value;
    template <typename _Tp> constexpr auto __min_cmp(_Tp __x, _Tp __y) {
        struct _Res {
            _Tp _M_min;
            decltype(__x <=> __y) _M_cmp;
        };
        auto __c = __x <=> __y;
        if (__c > 0)
            return _Res{__y, __c};
        return _Res{__x, __c};
    }
    template <typename _InputIter1, typename _InputIter2, typename _Comp> constexpr auto lexicographical_compare_three_way(_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _Comp __comp) -> decltype(__comp(*__first1, *__first2)) {
        ;
        ;
        using _Cat = decltype(__comp(*__first1, *__first2));
        static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);
        if (!std::__is_constant_evaluated())
            if (same_as<_Comp, __detail::_Synth3way> || same_as<_Comp, compare_three_way>)
                if (__is_byte_iter<_InputIter1>)
                    if (__is_byte_iter<_InputIter2>) {
                        const auto = std::__min_cmp(__last1 - __first1, __last2 - __first2);
                        if (__len) {
                            const auto __c = __builtin_memcmp(&*__first1, &*__first2, __len) <=> 0;
                            if (__c != 0)
                                return __c;
                        }
                        return __lencmp;
                    }
        while (__first1 != __last1)
            {
                if (__first2 == __last2)
                    return strong_ordering::greater;
                if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
                    return __cmp;
                ++__first1;
                ++__first2;
            }
        return (__first2 == __last2) <=> true;
    }
    template <typename _InputIter1, typename _InputIter2> constexpr auto lexicographical_compare_three_way(_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2) {
        return std::lexicographical_compare_three_way(__first1, __last1, __first2, __last2, compare_three_way{});
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> constexpr pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred) {
        while (__first1 != __last1 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred) {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> constexpr pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred) {
        while (__first1 != __last1 && __first2 != __last2 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred) {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator, typename _Predicate> inline constexpr _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, input_iterator_tag) {
        while (__first != __last && !__pred(__first))
            ++__first;
        return __first;
    }
    template <typename _RandomAccessIterator, typename _Predicate> constexpr _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, random_access_iterator_tag) {
        typename iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
        for (; __trip_count > 0; --__trip_count) {
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
        }
        switch (__last - __first) {
          case 3:
            if (__pred(__first))
                return __first;
            ++__first;
          case 2:
            if (__pred(__first))
                return __first;
            ++__first;
          case 1:
            if (__pred(__first))
                return __first;
            ++__first;
          case 0:
          default:
            return __last;
        }
    }
    template <typename _Iterator, typename _Predicate> inline constexpr _Iterator __find_if(_Iterator __first, _Iterator __last, _Predicate __pred) {
        return __find_if(__first, __last, __pred, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Predicate> constexpr typename iterator_traits<_InputIterator>::difference_type __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        for (; __first != __last; ++__first)
            if (__pred(__first))
                ++__n;
        return __n;
    }
    template <typename _ForwardIterator, typename _Predicate> constexpr _ForwardIterator __remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
        __first = std::__find_if(__first, __last, __pred);
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        ++__first;
        for (; __first != __last; ++__first)
            if (!__pred(__first)) {
                *__result = std::move(*__first);
                ++__result;
            }
        return __result;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> constexpr bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred) {
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!__pred(__first1, __first2))
                break;
        if (__first1 == __last1)
            return true;
        _ForwardIterator2 __last2 = __first2;
        std::advance(__last2, std::distance(__first1, __last1));
        for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
            if (__scan != std::__find_if(__first1, __scan, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                continue;
            auto __matches = std::__count_if(__first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
            if (0 == __matches || std::__count_if(__scan, __last1, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)) != __matches)
                return false;
        }
        return true;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline constexpr bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
        ;
        return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
}
namespace std {
    template <typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type> constexpr _Up &&__invfwd(typename remove_reference<_Tp>::type &__t) noexcept {
        return static_cast<_Up &&>(__t);
    }
    template <typename _Res, typename _Fn, typename ..._Args> constexpr _Res __invoke_impl(__invoke_other, _Fn &&__f, _Args &&...__args) {
        return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemFun, typename _Tp, typename ..._Args> constexpr _Res __invoke_impl(__invoke_memfun_ref, _MemFun &&__f, _Tp &&__t, _Args &&...__args) {
        return (__invfwd<_Tp>(__t) .* __f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemFun, typename _Tp, typename ..._Args> constexpr _Res __invoke_impl(__invoke_memfun_deref, _MemFun &&__f, _Tp &&__t, _Args &&...__args) {
        return ((*std::forward<_Tp>(__t)) .* __f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemPtr, typename _Tp> constexpr _Res __invoke_impl(__invoke_memobj_ref, _MemPtr &&__f, _Tp &&__t) {
        return __invfwd<_Tp>(__t) .* __f;
    }
    template <typename _Res, typename _MemPtr, typename _Tp> constexpr _Res __invoke_impl(__invoke_memobj_deref, _MemPtr &&__f, _Tp &&__t) {
        return (*std::forward<_Tp>(__t)) .* __f;
    }
    template <typename _Callable, typename ..._Args> constexpr typename __invoke_result<_Callable, _Args...>::type __invoke(_Callable &&__fn, _Args &&...__args) noexcept(__is_nothrow_invocable<_Callable, _Args...>::value) {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _Callable, typename ..._Args> constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res> __invoke_r(_Callable &&__fn, _Args &&...__args) noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>) {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        if (is_void_v<_Res>)
            std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
        else
            return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
}
namespace std {
    template <typename _Res, typename ..._ArgTypes> struct _Maybe_unary_or_binary_function {
    };
    template <typename _Res, typename _T1> struct _Maybe_unary_or_binary_function<_Res, _T1> : std::unary_function<_T1, _Res> {
    };
    template <typename _Res, typename _T1, typename _T2> struct _Maybe_unary_or_binary_function<_Res, _T1, _T2> : std::binary_function<_T1, _T2, _Res> {
    };
    template <typename _Signature> struct _Mem_fn_traits;
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits_base {
        using __result_type = _Res;
        using __maybe_type = _Maybe_unary_or_binary_function<_Res, _Class *, _ArgTypes...>;
        using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = true_type;
    };
    template <typename _Functor, typename = __void_t<>> struct _Maybe_get_result_type {
    };
    template <typename _Functor> struct _Maybe_get_result_type<_Functor, __void_t<typename _Functor::result_type>> {
        typedef typename _Functor::result_type result_type;
    };
    template <typename _Functor> struct _Weak_result_type_impl : _Maybe_get_result_type<_Functor> {
    };
    template <typename _Res, typename ..._ArgTypes, bool _NE> struct _Weak_result_type_impl<_Res (_ArgTypes...) noexcept(_NE)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes, bool _NE> struct _Weak_result_type_impl<_Res (_ArgTypes..., ...) noexcept(_NE)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes, bool _NE> struct _Weak_result_type_impl<_Res (*)(_ArgTypes...) noexcept(_NE)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes, bool _NE> struct _Weak_result_type_impl<_Res (*)(_ArgTypes..., ...) noexcept(_NE)> {
        typedef _Res result_type;
    };
    template <typename _Functor, bool = is_member_function_pointer<_Functor>::value> struct _Weak_result_type_memfun : _Weak_result_type_impl<_Functor> {
    };
    template <typename _MemFunPtr> struct _Weak_result_type_memfun<_MemFunPtr, true> {
        using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };
    template <typename _Func, typename _Class> struct _Weak_result_type_memfun<_Func _Class::*, false> {
    };
    template <typename _Functor> struct _Weak_result_type : _Weak_result_type_memfun<typename remove_cv<_Functor>::type> {
    };
    template <typename _Tp> class reference_wrapper {
        _Tp *_M_data;
        static constexpr _Tp *_S_fun(_Tp &__r) noexcept {
            return std::__addressof(__r);
        }
        static void _S_fun(_Tp &&) = delete
        template <typename _Up, typename _Up2 = __remove_cvref_t<_Up>> using __not_same = typename enable_if<!is_same<reference_wrapper<_Tp>, _Up2>::value>::type;
    public:
        typedef _Tp type;
        template <typename _Up, typename = __not_same<_Up>, typename = decltype(reference_wrapper<_Tp>::_S_fun(std::declval<_Up>()))> constexpr reference_wrapper<_Tp>(_Up &&__uref) noexcept(noexcept(reference_wrapper<_Tp>::_S_fun(std::declval<_Up>()))) : _M_data(reference_wrapper<_Tp>::_S_fun(std::forward<_Up>(__uref))) {
        }
        reference_wrapper<_Tp>(const reference_wrapper<_Tp> &) = default
        reference_wrapper<_Tp> &operator=(const reference_wrapper<_Tp> &) = default
        constexpr operator _Tp &() const noexcept {
            return this->get();
        }
        constexpr _Tp &get() const noexcept {
            return *this->_M_data;
        }
        template <typename ..._Args> constexpr typename __invoke_result<_Tp &, _Args...>::type operator()(_Args &&...__args) const noexcept(__is_nothrow_invocable<_Tp &, _Args...>::value) {
            if (is_object_v<type>)
                static_assert(sizeof(type), "type must be complete");
            return std::__invoke(this->get(), std::forward<_Args>(__args)...);
        }
    };
    template <typename _Tp> reference_wrapper(_Tp &) -> reference_wrapper<_Tp>;
    template <typename _Tp> inline constexpr reference_wrapper<_Tp> ref(_Tp &__t) noexcept {
        return reference_wrapper<_Tp>(__t);
    }
    template <typename _Tp> inline constexpr reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept {
        return reference_wrapper<const _Tp>(__t);
    }
    template <typename _Tp> void ref(const _Tp &&) = delete
    template <typename _Tp> void cref(const _Tp &&) = delete
    template <typename _Tp> inline constexpr reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) noexcept {
        return __t;
    }
    template <typename _Tp> inline constexpr reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t) noexcept {
        return {__t.get()};
    }
}
namespace std {
    template <class _E> class initializer_list {
    public:
        typedef _E value_type;
        typedef const _E &reference;
        typedef const _E &const_reference;
        typedef size_t size_type;
        typedef const _E *iterator;
        typedef const _E *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list<_E>(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l) {
        }
    public:
        constexpr initializer_list<_E>() noexcept : _M_array(0), _M_len(0) {
        }
        constexpr size_type size() const noexcept {
            return this->_M_len;
        }
        constexpr const_iterator begin() const noexcept {
            return this->_M_array;
        }
        constexpr const_iterator end() const noexcept {
            return this->begin() + this->size();
        }
    };
    template<> class initializer_list<char> {
    public:
        typedef char value_type;
        typedef const char &reference;
        typedef const char &const_reference;
        typedef size_t size_type;
        typedef const char *iterator;
        typedef const char *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list(const_iterator __a, size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr size_type size() const noexcept;
        constexpr const_iterator begin() const noexcept;
        constexpr const_iterator end() const noexcept;
    };
    template<> class initializer_list<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef const wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef size_t size_type;
        typedef const wchar_t *iterator;
        typedef const wchar_t *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list(const_iterator __a, size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr size_type size() const noexcept;
        constexpr const_iterator begin() const noexcept;
        constexpr const_iterator end() const noexcept;
    };
    template<> class initializer_list<char8_t> {
    public:
        typedef char8_t value_type;
        typedef const char8_t &reference;
        typedef const char8_t &const_reference;
        typedef size_t size_type;
        typedef const char8_t *iterator;
        typedef const char8_t *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list(const_iterator __a, size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr size_type size() const noexcept;
        constexpr const_iterator begin() const noexcept;
        constexpr const_iterator end() const noexcept;
    };
    template<> class initializer_list<char16_t> {
    public:
        typedef char16_t value_type;
        typedef const char16_t &reference;
        typedef const char16_t &const_reference;
        typedef size_t size_type;
        typedef const char16_t *iterator;
        typedef const char16_t *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list(const_iterator __a, size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr size_type size() const noexcept;
        constexpr const_iterator begin() const noexcept;
        constexpr const_iterator end() const noexcept;
    };
    template<> class initializer_list<char32_t> {
    public:
        typedef char32_t value_type;
        typedef const char32_t &reference;
        typedef const char32_t &const_reference;
        typedef size_t size_type;
        typedef const char32_t *iterator;
        typedef const char32_t *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list(const_iterator __a, size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr size_type size() const noexcept;
        constexpr const_iterator begin() const noexcept;
        constexpr const_iterator end() const noexcept;
    };
    template<> class initializer_list<bool> {
    public:
        typedef bool value_type;
        typedef const bool &reference;
        typedef const bool &const_reference;
        typedef size_t size_type;
        typedef const bool *iterator;
        typedef const bool *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list(const_iterator __a, size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr size_type size() const noexcept {
            return this->_M_len;
        }
        constexpr const_iterator begin() const noexcept {
            return this->_M_array;
        }
        constexpr const_iterator end() const noexcept {
            return this->begin() + this->size();
        }
    };
    template<> class initializer_list<int> {
    public:
        typedef int value_type;
        typedef const int &reference;
        typedef const int &const_reference;
        typedef size_t size_type;
        typedef const int *iterator;
        typedef const int *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list(const_iterator __a, size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr size_type size() const noexcept {
            return this->_M_len;
        }
        constexpr const_iterator begin() const noexcept {
            return this->_M_array;
        }
        constexpr const_iterator end() const noexcept {
            return this->begin() + this->size();
        }
    };
    template<> class initializer_list<Base<ChildA, ChildB, ChildC> *> {
    public:
        typedef Base<ChildA, ChildB, ChildC> *value_type;
        typedef Base<ChildA, ChildB, ChildC> *const &reference;
        typedef Base<ChildA, ChildB, ChildC> *const &const_reference;
        typedef size_t size_type;
        typedef Base<ChildA, ChildB, ChildC> *const *iterator;
        typedef Base<ChildA, ChildB, ChildC> *const *const_iterator;
    private:
        iterator _M_array;
        size_type _M_len;
        constexpr initializer_list(const_iterator __a, size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr size_type size() const noexcept {
            return this->_M_len;
        }
        constexpr const_iterator begin() const noexcept {
            return this->_M_array;
        }
        constexpr const_iterator end() const noexcept {
            return this->begin() + this->size();
        }
    };
    template <class _Tp> constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept {
        return __ils.begin();
    }
    template <class _Tp> constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept {
        return __ils.end();
    }
}
namespace std {
    template <typename _Container> inline constexpr auto begin(_Container &__cont) -> decltype(__cont.begin()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.begin();
    }
    template <typename _Container> inline constexpr auto begin(const _Container &__cont) -> decltype(__cont.begin()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.begin();
    }
    template <typename _Container> inline constexpr auto end(_Container &__cont) -> decltype(__cont.end()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.end();
    }
    template <typename _Container> inline constexpr auto end(const _Container &__cont) -> decltype(__cont.end()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.end();
    }
    template <typename _Tp, size_t _Nm> inline constexpr _Tp *begin(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
        return __arr;
    }
    template <typename _Tp, size_t _Nm> inline constexpr _Tp *end(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
        return __arr + _Nm;
    }
    template <typename _Tp> class valarray;
    template <typename _Tp> _Tp *begin(valarray<_Tp> &) noexcept;
    template <typename _Tp> const _Tp *begin(const valarray<_Tp> &) noexcept;
    template <typename _Tp> _Tp *end(valarray<_Tp> &) noexcept;
    template <typename _Tp> const _Tp *end(const valarray<_Tp> &) noexcept;
    template <typename _Container> constexpr auto cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))) -> decltype(std::begin(__cont)) [[nodiscard("")]] [[gnu::always_inline]] {
        return std::begin(__cont);
    }
    template <typename _Container> constexpr auto cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))) -> decltype(std::end(__cont)) [[nodiscard("")]] [[gnu::always_inline]] {
        return std::end(__cont);
    }
    template <typename _Container> inline constexpr auto rbegin(_Container &__cont) -> decltype(__cont.rbegin()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.rbegin();
    }
    template <typename _Container> inline constexpr auto rbegin(const _Container &__cont) -> decltype(__cont.rbegin()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.rbegin();
    }
    template <typename _Container> inline constexpr auto rend(_Container &__cont) -> decltype(__cont.rend()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.rend();
    }
    template <typename _Container> inline constexpr auto rend(const _Container &__cont) -> decltype(__cont.rend()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.rend();
    }
    template <typename _Tp, size_t _Nm> inline constexpr reverse_iterator<_Tp *> rbegin(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]] {
        return reverse_iterator<_Tp *>(__arr + _Nm);
    }
    template <typename _Tp, size_t _Nm> inline constexpr reverse_iterator<_Tp *> rend(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]] {
        return reverse_iterator<_Tp *>(__arr);
    }
    template <typename _Tp> inline constexpr reverse_iterator<const _Tp *> rbegin(initializer_list<_Tp> __il) noexcept [[nodiscard("")]] {
        return reverse_iterator<const _Tp *>(__il.end());
    }
    template <typename _Tp> inline constexpr reverse_iterator<const _Tp *> rend(initializer_list<_Tp> __il) noexcept [[nodiscard("")]] {
        return reverse_iterator<const _Tp *>(__il.begin());
    }
    template <typename _Container> inline constexpr auto crbegin(const _Container &__cont) -> decltype(std::rbegin(__cont)) [[nodiscard("")]] [[gnu::always_inline]] {
        return std::rbegin(__cont);
    }
    template <typename _Container> inline constexpr auto crend(const _Container &__cont) -> decltype(std::rend(__cont)) [[nodiscard("")]] [[gnu::always_inline]] {
        return std::rend(__cont);
    }
    template <typename _Container> constexpr auto size(const _Container &__cont) noexcept(noexcept(__cont.size())) -> decltype(__cont.size()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.size();
    }
    template <typename _Tp, size_t _Nm> constexpr size_t size(const _Tp (&)[_Nm]) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
        return _Nm;
    }
    template <typename _Container> constexpr auto empty(const _Container &__cont) noexcept(noexcept(__cont.empty())) -> decltype(__cont.empty()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.empty();
    }
    template <typename _Tp, size_t _Nm> constexpr bool empty(const _Tp (&)[_Nm]) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
        return false;
    }
    template <typename _Tp> constexpr bool empty(initializer_list<_Tp> __il) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
        return __il.size() == 0;
    }
    template <typename _Container> constexpr auto data(_Container &__cont) noexcept(noexcept(__cont.data())) -> decltype(__cont.data()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.data();
    }
    template <typename _Container> constexpr auto data(const _Container &__cont) noexcept(noexcept(__cont.data())) -> decltype(__cont.data()) [[nodiscard("")]] [[gnu::always_inline]] {
        return __cont.data();
    }
    template <typename _Tp, size_t _Nm> constexpr _Tp *data(_Tp (&__array)[_Nm]) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
        return __array;
    }
    template <typename _Tp> constexpr const _Tp *data(initializer_list<_Tp> __il) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
        return __il.begin();
    }
    template <typename _Container> constexpr auto ssize(const _Container &__cont) noexcept(noexcept(__cont.size())) -> common_type_t<ptrdiff_t, make_signed_t<decltype(__cont.size())>> [[nodiscard("")]] [[gnu::always_inline]] {
        using type = make_signed_t<decltype(__cont.size())>;
        return static_cast<common_type_t<ptrdiff_t, type>>(__cont.size());
    }
    template <typename _Tp, ptrdiff_t _Num> constexpr ptrdiff_t ssize(const _Tp (&)[_Num]) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
        return _Num;
    }
}
namespace std {
    struct __allocator_traits_base {
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
            static_assert(is_same<typename __replace_first_arg<_Tp, typename _Tp::value_type>::type, _Tp>::value, "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>::other>> {
            using type = typename _Tp::template rebind<_Up>::other;
            static_assert(is_same<typename _Tp::template rebind<typename _Tp::value_type>::other, _Tp>::value, "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
        };
    protected:
        template <typename _Tp> using __pointer = typename _Tp::pointer;
        template <typename _Tp> using __c_pointer = typename _Tp::const_pointer;
        template <typename _Tp> using __v_pointer = typename _Tp::void_pointer;
        template <typename _Tp> using __cv_pointer = typename _Tp::const_void_pointer;
        template <typename _Tp> using __pocca = typename _Tp::propagate_on_container_copy_assignment;
        template <typename _Tp> using __pocma = typename _Tp::propagate_on_container_move_assignment;
        template <typename _Tp> using __pocs = typename _Tp::propagate_on_container_swap;
        template <typename _Tp> using __equal = __type_identity<typename _Tp::is_always_equal>;
    };
    template <typename _Alloc, typename _Up> using __alloc_rebind = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
    template <typename _Alloc> struct allocator_traits : __allocator_traits_base {
        typedef _Alloc allocator_type;
        typedef typename _Alloc::value_type value_type;
        using pointer = __detected_or_t<value_type *, std::__allocator_traits_base::__pointer, _Alloc>;
    private:
        template <template <typename> class _Func, typename _Tp, typename = void> struct _Ptr {
            using type = typename pointer_traits<pointer>::template rebind<_Tp>;
        };
        template <template <typename> class _Func, typename _Tp> struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>> {
            using type = _Func<_Alloc>;
        };
        template <typename _A2, typename _PtrT, typename = void> struct _Diff {
            using type = typename pointer_traits<_PtrT>::difference_type;
        };
        template <typename _A2, typename _PtrT> struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>> {
            using type = typename _A2::difference_type;
        };
        template <typename _A2, typename _DiffT, typename = void> struct _Size : make_unsigned<_DiffT> {
        };
        template <typename _A2, typename _DiffT> struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>> {
            using type = typename _A2::size_type;
        };
    public:
        using const_pointer = typename _Ptr<std::__allocator_traits_base::__c_pointer, const value_type>::type;
        using void_pointer = typename _Ptr<std::__allocator_traits_base::__v_pointer, void>::type;
        using const_void_pointer = typename _Ptr<std::__allocator_traits_base::__cv_pointer, const void>::type;
        using difference_type = typename _Diff<_Alloc, pointer>::type;
        using size_type = typename _Size<_Alloc, difference_type>::type;
        using propagate_on_container_copy_assignment = __detected_or_t<false_type, std::__allocator_traits_base::__pocca, _Alloc>;
        using propagate_on_container_move_assignment = __detected_or_t<false_type, std::__allocator_traits_base::__pocma, _Alloc>;
        using propagate_on_container_swap = __detected_or_t<false_type, std::__allocator_traits_base::__pocs, _Alloc>;
        using is_always_equal = typename __detected_or_t<is_empty<_Alloc>, std::__allocator_traits_base::__equal, _Alloc>::type;
        template <typename _Tp> using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
        template <typename _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
    private:
        template <typename _Alloc2> static constexpr auto _S_allocate(_Alloc2 &__a, size_type __n, const_void_pointer __hint, int) -> decltype(__a.allocate(__n, __hint)) {
            return __a.allocate(__n, __hint);
        }
        template <typename _Alloc2> static constexpr pointer _S_allocate(_Alloc2 &__a, size_type __n, const_void_pointer, ...) {
            return __a.allocate(__n);
        }
        template <typename _Tp, typename ..._Args> struct __construct_helper {
            template <typename _Alloc2, typename = decltype(std::declval<_Alloc2 *>()->construct(std::declval<_Tp *>(), std::declval<_Args>()...))> static true_type __test(int);
            template <typename> static false_type __test(...);
            using type = decltype(__test<_Alloc>(0));
        };
        template <typename _Tp, typename ..._Args> using __has_construct = typename __construct_helper<_Tp, _Args...>::type;
        template <typename _Tp, typename ..._Args> static constexpr _Require<__has_construct<_Tp, _Args...>> _S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...))) {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp, typename ..._Args> static constexpr _Require<__and_<__not_<__has_construct<_Tp, _Args...>>, is_constructible<_Tp, _Args...>>> _S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value) {
            std::construct_at(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Alloc2, typename _Tp> static constexpr auto _S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p))) -> decltype(__a.destroy(__p)) {
            __a.destroy(__p);
        }
        template <typename _Alloc2, typename _Tp> static constexpr void _S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(std::is_nothrow_destructible<_Tp>::value) {
            std::_Destroy(__p);
        }
        template <typename _Alloc2> static constexpr auto _S_max_size(_Alloc2 &__a, int) -> decltype(__a.max_size()) {
            return __a.max_size();
        }
        template <typename _Alloc2> static constexpr size_type _S_max_size(_Alloc2 &, ...) {
            return __gnu_cxx::__numeric_traits<size_type>::__max / sizeof(value_type);
        }
        template <typename _Alloc2> static constexpr auto _S_select(_Alloc2 &__a, int) -> decltype(__a.select_on_container_copy_construction()) {
            return __a.select_on_container_copy_construction();
        }
        template <typename _Alloc2> static constexpr _Alloc2 _S_select(_Alloc2 &__a, ...) {
            return __a;
        }
    public:
        static constexpr pointer allocate(_Alloc &__a, size_type __n) [[nodiscard("")]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(_Alloc &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] {
            return _S_allocate(__a, __n, __hint, 0);
        }
        static constexpr void deallocate(_Alloc &__a, pointer __p, size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Tp, typename ..._Args> static constexpr auto construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...))) -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...)) {
            _S_construct(__a, __p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp> static constexpr void destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0))) {
            _S_destroy(__a, __p, 0);
        }
        static constexpr size_type max_size(const _Alloc &__a) noexcept {
            return _S_max_size(__a, 0);
        }
        static constexpr _Alloc select_on_container_copy_construction(const _Alloc &__rhs) {
            return _S_select(__rhs, 0);
        }
    };
    template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]] {
            return __rhs;
        }
    };
    template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    };
    template<> struct allocator_traits<std::allocator<char8_t>> {
        using allocator_type = allocator<char8_t>;
        using value_type = char8_t;
        using pointer = char8_t *;
        using const_pointer = const char8_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    };
    template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    };
    template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    };
    template<> struct allocator_traits<std::allocator<int>> {
        using allocator_type = allocator<int>;
        using value_type = int;
        using pointer = int *;
        using const_pointer = const int *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    };
    template<> struct allocator_traits<std::allocator<Base<ChildA, ChildB, ChildC> *>> {
        using allocator_type = allocator<Base<ChildA, ChildB, ChildC> *>;
        using value_type = Base<ChildA, ChildB, ChildC> *;
        using pointer = Base<ChildA, ChildB, ChildC> **;
        using const_pointer = Base<ChildA, ChildB, ChildC> *const *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    };
    template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
        using allocator_type = allocator<_Tp>;
        using value_type = _Tp;
        using pointer = _Tp *;
        using const_pointer = const _Tp *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value) [[gnu::always_inline]] {
            std::construct_at(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) noexcept(is_nothrow_destructible<_Up>::value) [[gnu::always_inline]] {
            std::destroy_at(__p);
        }
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]] {
            return __rhs;
        }
    };
    template<> struct allocator_traits<allocator<void>> {
        using allocator_type = allocator<void>;
        using value_type = void;
        using pointer = void *;
        using const_pointer = const void *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static void *allocate(allocator_type &, size_type, const void * = nullptr) = delete
        static void deallocate(allocator_type &, void *, size_type) = delete
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &, _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value) [[gnu::always_inline]] {
            std::_Construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static constexpr void destroy(allocator_type &, _Up *__p) noexcept(is_nothrow_destructible<_Up>::value) [[gnu::always_inline]] {
            std::_Destroy(__p);
        }
        static size_type max_size(const allocator_type &) = delete
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]] {
            return __rhs;
        }
    };
    template <typename _Alloc> inline constexpr void __alloc_on_copy(_Alloc &__one, const _Alloc &__two) [[gnu::always_inline]] {
        using __traits = allocator_traits<_Alloc>;
        using __pocca = typename __traits::propagate_on_container_copy_assignment::type;
        if (__pocca::value)
            __one = __two;
    }
    template <typename _Alloc> constexpr _Alloc __alloc_on_copy(const _Alloc &__a) [[gnu::always_inline]] {
        typedef allocator_traits<_Alloc> __traits;
        return __traits::select_on_container_copy_construction(__a);
    }
    template <typename _Alloc> inline constexpr void __alloc_on_move(_Alloc &__one, _Alloc &__two) [[gnu::always_inline]] {
        using __traits = allocator_traits<_Alloc>;
        using __pocma = typename __traits::propagate_on_container_move_assignment::type;
        if (__pocma::value)
            __one = std::move(__two);
    }
    template<> inline constexpr void __alloc_on_move<std::allocator<int>>(std::allocator<int> &__one, std::allocator<int> &__two) [[gnu::always_inline]] {
        using __traits = allocator_traits<allocator<int>>;
        using __pocma = typename __traits::propagate_on_container_move_assignment::type;
        if (__pocma::value)
            __one = std::move(__two);
    }
    template <typename _Alloc> inline constexpr void __alloc_on_swap(_Alloc &__one, _Alloc &__two) [[gnu::always_inline]] {
        using __traits = allocator_traits<_Alloc>;
        using __pocs = typename __traits::propagate_on_container_swap::type;
        if (__pocs::value) {
            using std::swap;
            swap(__one, __two);
        }
    }
    template <typename _Alloc, typename _Tp, typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>, typename = void> struct __is_alloc_insertable_impl : false_type {
    };
    template <typename _Alloc, typename _Tp, typename _ValueT> struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, __void_t<decltype(allocator_traits<_Alloc>::construct(std::declval<_Alloc &>(), std::declval<_ValueT *>(), std::declval<_Tp>()))>> : true_type {
    };
    template <typename _Alloc> struct __is_copy_insertable : __is_alloc_insertable_impl<_Alloc, const typename _Alloc::value_type &>::type {
    };
    template <typename _Tp> struct __is_copy_insertable<allocator<_Tp>> : is_copy_constructible<_Tp> {
    };
    template <typename _Alloc> struct __is_move_insertable : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type {
    };
    template <typename _Tp> struct __is_move_insertable<allocator<_Tp>> : is_move_constructible<_Tp> {
    };
    template <typename _Alloc, typename = void> struct __is_allocator : false_type {
    };
    template<> struct __is_allocator<std::allocator<char>, void> : true_type {
    };
    template<> struct __is_allocator<std::allocator<wchar_t>, void> : true_type {
    };
    template<> struct __is_allocator<std::allocator<char8_t>, void> : true_type {
    };
    template<> struct __is_allocator<std::allocator<char16_t>, void> : true_type {
    };
    template<> struct __is_allocator<std::allocator<char32_t>, void> : true_type {
    };
    template <typename _Alloc> struct __is_allocator<_Alloc, __void_t<typename _Alloc::value_type, decltype(std::declval<_Alloc &>().allocate(size_t{}))>> : true_type {
    };
    template <typename _Alloc> using _RequireAllocator = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _Alloc> using _RequireNotAllocator = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _Alloc> concept __allocator_like = requires (_Alloc &__a) { typename _Alloc::value_type; __a.deallocate(__a.allocate(1U), 1U); };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
        static void _S_do_it(_Alloc &, _Alloc &) noexcept {
        }
    };
    template <typename _Alloc> struct __alloc_swap<_Alloc, false> {
        static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept {
            if (__one != __two)
                swap(__one, __two);
        }
    };
    template <typename _Tp, bool = __or_<is_copy_constructible<typename _Tp::value_type>, is_nothrow_move_constructible<typename _Tp::value_type>>::value> struct __shrink_to_fit_aux {
        static bool _S_do_it(_Tp &) noexcept {
            return false;
        }
    };
    template <typename _Tp> struct __shrink_to_fit_aux<_Tp, true> {
        static constexpr bool _S_do_it(_Tp &__c) noexcept {
            try {
                _Tp(__make_move_if_noexcept_iterator(__c.begin()), __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator()).swap(__c);
                return true;
            } catch (...) {
                return false;
            }
        }
    };
    template <typename _ForwardIterator, typename _Allocator> constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc) {
        for (; __first != __last; ++__first)
            allocator_traits<_Allocator>::destroy(__alloc, std::__addressof(*__first));
    }
    template<> constexpr void _Destroy<Base<ChildA, ChildB, ChildC> **, std::allocator<Base<ChildA, ChildB, ChildC> *>>(Base<ChildA, ChildB, ChildC> **__first, Base<ChildA, ChildB, ChildC> **__last, std::allocator<Base<ChildA, ChildB, ChildC> *> &__alloc)    template<> constexpr void _Destroy<int *, std::allocator<int>>(int *__first, int *__last, std::allocator<int> &__alloc)    template <typename _ForwardIterator, typename _Tp> inline constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &) __attribute__((always_inline)) {
        std::_Destroy(__first, __last);
    }
    template<> inline constexpr void _Destroy<Base<ChildA, ChildB, ChildC> **, Base<ChildA, ChildB, ChildC> *>(Base<ChildA, ChildB, ChildC> **__first, Base<ChildA, ChildB, ChildC> **__last, allocator<Base<ChildA, ChildB, ChildC> *> &) __attribute__((always_inline)) {
        std::_Destroy(__first, __last);
    }
    template<> inline constexpr void _Destroy<int *, int>(int *__first, int *__last, allocator<int> &) __attribute__((always_inline)) {
        std::_Destroy(__first, __last);
    }
}
namespace __gnu_cxx {
    template <typename _Alloc, typename = typename _Alloc::value_type> struct __alloc_traits : std::allocator_traits<_Alloc> {
        typedef _Alloc allocator_type;
        typedef std::allocator_traits<_Alloc> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...))) [[gnu::always_inline]] {
            _Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...);
        }
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p)))) [[gnu::always_inline]] {
            _Base_type::destroy(__a, std::__to_address(__p));
        }
        static constexpr _Alloc _S_select_on_copy(const _Alloc &__a) [[gnu::always_inline]] {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static constexpr void _S_on_swap(_Alloc &__a, _Alloc &__b) [[gnu::always_inline]] {
            std::__alloc_on_swap(__a, __b);
        }
        static constexpr bool _S_propagate_on_copy_assign() [[gnu::always_inline]] {
            return _Base_type::propagate_on_container_copy_assignment::value;
        }
        static constexpr bool _S_propagate_on_move_assign() [[gnu::always_inline]] {
            return _Base_type::propagate_on_container_move_assignment::value;
        }
        static constexpr bool _S_propagate_on_swap() [[gnu::always_inline]] {
            return _Base_type::propagate_on_container_swap::value;
        }
        static constexpr bool _S_always_equal() [[gnu::always_inline]] {
            return _Base_type::is_always_equal::value;
        }
        static constexpr bool _S_nothrow_move() __attribute__((always_inline)) {
            return _S_propagate_on_move_assign() || _S_always_equal();
        }
        template <typename _Tp> struct rebind {
            typedef typename _Base_type::template rebind_alloc<_Tp> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<char>, char> : std::allocator_traits<allocator<char>> {
        typedef std::allocator<char> allocator_type;
        typedef std::allocator_traits<allocator<char>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char> &__a, _Ptr __p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char> &__a, _Ptr __p) [[gnu::always_inline]];
        static constexpr std::allocator<char> _S_select_on_copy(const std::allocator<char> &__a) [[gnu::always_inline]] {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static constexpr void _S_on_swap(std::allocator<char> &__a, std::allocator<char> &__b) [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_copy_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_move_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_swap() [[gnu::always_inline]];
        static constexpr bool _S_always_equal() [[gnu::always_inline]];
        static constexpr bool _S_nothrow_move() __attribute__((always_inline));
        template <typename _Tp> struct rebind
        template<> struct rebind<char> {
            typedef typename _Base_type::rebind_alloc<char> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<wchar_t>, wchar_t> : std::allocator_traits<allocator<wchar_t>> {
        typedef std::allocator<wchar_t> allocator_type;
        typedef std::allocator_traits<allocator<wchar_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<wchar_t> &__a, _Ptr __p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<wchar_t> &__a, _Ptr __p) [[gnu::always_inline]];
        static constexpr std::allocator<wchar_t> _S_select_on_copy(const std::allocator<wchar_t> &__a) [[gnu::always_inline]];
        static constexpr void _S_on_swap(std::allocator<wchar_t> &__a, std::allocator<wchar_t> &__b) [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_copy_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_move_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_swap() [[gnu::always_inline]];
        static constexpr bool _S_always_equal() [[gnu::always_inline]];
        static constexpr bool _S_nothrow_move() __attribute__((always_inline));
        template <typename _Tp> struct rebind
        template<> struct rebind<wchar_t> {
            typedef typename _Base_type::rebind_alloc<wchar_t> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<char8_t>, char8_t> : std::allocator_traits<allocator<char8_t>> {
        typedef std::allocator<char8_t> allocator_type;
        typedef std::allocator_traits<allocator<char8_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char8_t> &__a, _Ptr __p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char8_t> &__a, _Ptr __p) [[gnu::always_inline]];
        static constexpr std::allocator<char8_t> _S_select_on_copy(const std::allocator<char8_t> &__a) [[gnu::always_inline]];
        static constexpr void _S_on_swap(std::allocator<char8_t> &__a, std::allocator<char8_t> &__b) [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_copy_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_move_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_swap() [[gnu::always_inline]];
        static constexpr bool _S_always_equal() [[gnu::always_inline]];
        static constexpr bool _S_nothrow_move() __attribute__((always_inline));
        template <typename _Tp> struct rebind
        template<> struct rebind<char8_t> {
            typedef typename _Base_type::rebind_alloc<char8_t> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<char16_t>, char16_t> : std::allocator_traits<allocator<char16_t>> {
        typedef std::allocator<char16_t> allocator_type;
        typedef std::allocator_traits<allocator<char16_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char16_t> &__a, _Ptr __p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char16_t> &__a, _Ptr __p) [[gnu::always_inline]];
        static constexpr std::allocator<char16_t> _S_select_on_copy(const std::allocator<char16_t> &__a) [[gnu::always_inline]];
        static constexpr void _S_on_swap(std::allocator<char16_t> &__a, std::allocator<char16_t> &__b) [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_copy_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_move_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_swap() [[gnu::always_inline]];
        static constexpr bool _S_always_equal() [[gnu::always_inline]];
        static constexpr bool _S_nothrow_move() __attribute__((always_inline));
        template <typename _Tp> struct rebind
        template<> struct rebind<char16_t> {
            typedef typename _Base_type::rebind_alloc<char16_t> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<char32_t>, char32_t> : std::allocator_traits<allocator<char32_t>> {
        typedef std::allocator<char32_t> allocator_type;
        typedef std::allocator_traits<allocator<char32_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char32_t> &__a, _Ptr __p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char32_t> &__a, _Ptr __p) [[gnu::always_inline]];
        static constexpr std::allocator<char32_t> _S_select_on_copy(const std::allocator<char32_t> &__a) [[gnu::always_inline]];
        static constexpr void _S_on_swap(std::allocator<char32_t> &__a, std::allocator<char32_t> &__b) [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_copy_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_move_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_swap() [[gnu::always_inline]];
        static constexpr bool _S_always_equal() [[gnu::always_inline]];
        static constexpr bool _S_nothrow_move() __attribute__((always_inline));
        template <typename _Tp> struct rebind
        template<> struct rebind<char32_t> {
            typedef typename _Base_type::rebind_alloc<char32_t> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<int>, int> : std::allocator_traits<allocator<int>> {
        typedef std::allocator<int> allocator_type;
        typedef std::allocator_traits<allocator<int>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<int> &__a, _Ptr __p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<int> &__a, _Ptr __p) [[gnu::always_inline]];
        static constexpr std::allocator<int> _S_select_on_copy(const std::allocator<int> &__a) [[gnu::always_inline]];
        static constexpr void _S_on_swap(std::allocator<int> &__a, std::allocator<int> &__b) [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_copy_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_move_assign() [[gnu::always_inline]] {
            return _Base_type::propagate_on_container_move_assignment::value;
        }
        static constexpr bool _S_propagate_on_swap() [[gnu::always_inline]];
        static constexpr bool _S_always_equal() [[gnu::always_inline]] {
            return _Base_type::is_always_equal::value;
        }
        static constexpr bool _S_nothrow_move() __attribute__((always_inline)) {
            return _S_propagate_on_move_assign() || _S_always_equal();
        }
        template <typename _Tp> struct rebind
        template<> struct rebind<int> {
            typedef typename _Base_type::rebind_alloc<int> other;
        };
    };
    template<> struct __alloc_traits<std::allocator<Base<ChildA, ChildB, ChildC> *>, Base<ChildA, ChildB, ChildC> *> : std::allocator_traits<allocator<Base<ChildA, ChildB, ChildC> *>> {
        typedef std::allocator<Base<ChildA, ChildB, ChildC> *> allocator_type;
        typedef std::allocator_traits<allocator<Base<ChildA, ChildB, ChildC> *>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<Base<ChildA, ChildB, ChildC> *> &__a, _Ptr __p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<Base<ChildA, ChildB, ChildC> *> &__a, _Ptr __p) [[gnu::always_inline]];
        static constexpr std::allocator<Base<ChildA, ChildB, ChildC> *> _S_select_on_copy(const std::allocator<Base<ChildA, ChildB, ChildC> *> &__a) [[gnu::always_inline]];
        static constexpr void _S_on_swap(std::allocator<Base<ChildA, ChildB, ChildC> *> &__a, std::allocator<Base<ChildA, ChildB, ChildC> *> &__b) [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_copy_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_move_assign() [[gnu::always_inline]];
        static constexpr bool _S_propagate_on_swap() [[gnu::always_inline]];
        static constexpr bool _S_always_equal() [[gnu::always_inline]];
        static constexpr bool _S_nothrow_move() __attribute__((always_inline));
        template <typename _Tp> struct rebind
        template<> struct rebind<Base<ChildA, ChildB, ChildC> *> {
            typedef typename _Base_type::rebind_alloc<Base<ChildA, ChildB, ChildC> *> other;
        };
    };
}
namespace std {
    template <typename _Result, typename _Arg> struct __hash_base {
        typedef _Result result_type [[deprecated("")]];
        typedef _Arg argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, bool> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef bool argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, signed char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef signed char argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, unsigned char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned char argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, wchar_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef wchar_t argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, char8_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char8_t argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, char16_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char16_t argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, char32_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char32_t argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, short> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef short argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, int> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef int argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, long long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long long argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, unsigned short> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned short argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, unsigned int> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned int argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, unsigned long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned long argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, unsigned long long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned long long argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, float> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef float argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, double> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef double argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, long double> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long double argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, std::nullptr_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::nullptr_t argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, std::basic_string_view<char>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char> argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, std::basic_string_view<wchar_t>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<wchar_t> argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, std::basic_string_view<char8_t>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char8_t> argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, std::basic_string_view<char16_t>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char16_t> argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, std::basic_string_view<char32_t>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char32_t> argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, std::error_code> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::error_code argument_type [[deprecated("")]];
    };
    template<> struct __hash_base<unsigned long, std::error_condition> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::error_condition argument_type [[deprecated("")]];
    };
    template <typename _Tp> struct hash;
    template <typename _Tp, typename = void> struct __poison_hash {
        static constexpr bool __enable_hash_call = false;
    private:
        __poison_hash<_Tp, type-parameter-0-1>(__poison_hash<_Tp, type-parameter-0-1> &&);
        ~__poison_hash<_Tp, type-parameter-0-1>();
    };
    template <typename _Tp> struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>> {
        static constexpr bool __enable_hash_call = true;
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
    private:
        __hash_enum<_Tp, >(__hash_enum<_Tp, > &&);
        ~__hash_enum<_Tp, >();
    };
    template <typename _Tp> struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp> {
        size_t operator()(_Tp __val) const noexcept {
            using __type = typename underlying_type<_Tp>::type;
            return hash<__type>{}(static_cast<__type>(__val));
        }
    };
    template <typename _Tp> struct hash : __hash_enum<_Tp> {
    };
    template <typename _Tp> struct hash<_Tp *> : public __hash_base<size_t, _Tp *> {
        size_t operator()(_Tp *__p) const noexcept {
            return reinterpret_cast<size_t>(__p);
        }
    };
    template<> struct hash<bool> : public __hash_base<size_t, bool> {
        size_t operator()(bool __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<char> : public __hash_base<size_t, char> {
        size_t operator()(char __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<signed char> : public __hash_base<size_t, signed char> {
        size_t operator()(signed char __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> {
        size_t operator()(unsigned char __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> {
        size_t operator()(wchar_t __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<char8_t> : public __hash_base<size_t, char8_t> {
        size_t operator()(char8_t __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> {
        size_t operator()(char16_t __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> {
        size_t operator()(char32_t __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<short> : public __hash_base<size_t, short> {
        size_t operator()(short __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<int> : public __hash_base<size_t, int> {
        size_t operator()(int __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<long> : public __hash_base<size_t, long> {
        size_t operator()(long __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<long long> : public __hash_base<size_t, long long> {
        size_t operator()(long long __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> {
        size_t operator()(unsigned short __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> {
        size_t operator()(unsigned int __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> {
        size_t operator()(unsigned long __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> {
        size_t operator()(unsigned long long __val) const noexcept {
            return static_cast<size_t>(__val);
        }
    };
    struct _Hash_impl {
        static size_t hash(const void *__ptr, size_t __clength, size_t __seed = static_cast<size_t>(3339675911UL)) {
            return _Hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static size_t hash(const _Tp &__val) {
            return hash(&__val, sizeof (__val));
        }
        template<> static size_t hash<float>(const float &__val) {
            return hash(&__val, sizeof (__val));
        }
        template<> static size_t hash<double>(const double &__val) {
            return hash(&__val, sizeof (__val));
        }
        template<> static size_t hash<int>(const int &__val) {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static size_t __hash_combine(const _Tp &__val, size_t __hash) {
            return hash(&__val, sizeof (__val), __hash);
        }
        template<> static size_t __hash_combine<const std::error_category *>(const std::error_category *const &__val, size_t __hash) {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    struct _Fnv_hash_impl {
        static size_t hash(const void *__ptr, size_t __clength, size_t __seed = static_cast<size_t>(2166136261UL)) {
            return _Fnv_hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static size_t hash(const _Tp &__val) {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static size_t __hash_combine(const _Tp &__val, size_t __hash) {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    template<> struct hash<float> : public __hash_base<size_t, float> {
        size_t operator()(float __val) const noexcept {
            return __val != 0.F ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<double> : public __hash_base<size_t, double> {
        size_t operator()(double __val) const noexcept {
            return __val != 0. ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<long double> : public __hash_base<size_t, long double> {
        size_t operator()(long double __val) const noexcept __attribute__((pure));
    };
    template<> struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t> {
        size_t operator()(nullptr_t) const noexcept {
            return 0;
        }
    };
    template <typename _Hash> struct __is_fast_hash : public std::true_type {
    };
    template<> struct __is_fast_hash<hash<long double>> : public std::false_type {
    };
}
namespace std {
    namespace numbers {
        template <typename _Tp> using _Enable_if_floating = enable_if_t<is_floating_point_v<_Tp>, _Tp>;
        template <typename _Tp> constexpr _Tp e_v = _Enable_if_floating<_Tp>(2.71828182845904523543L);
        template <typename _Tp> constexpr _Tp log2e_v = _Enable_if_floating<_Tp>(1.44269504088896340739L);
        template <typename _Tp> constexpr _Tp log10e_v = _Enable_if_floating<_Tp>(0.434294481903251827645L);
        template <typename _Tp> constexpr _Tp pi_v = _Enable_if_floating<_Tp>(3.14159265358979323851L);
        template <typename _Tp> constexpr _Tp inv_pi_v = _Enable_if_floating<_Tp>(0.318309886183790671538L);
        template <typename _Tp> constexpr _Tp inv_sqrtpi_v = _Enable_if_floating<_Tp>(0.564189583547756286924L);
        template <typename _Tp> constexpr _Tp ln2_v = _Enable_if_floating<_Tp>(0.693147180559945309429L);
        template <typename _Tp> constexpr _Tp ln10_v = _Enable_if_floating<_Tp>(2.30258509299404568404L);
        template <typename _Tp> constexpr _Tp sqrt2_v = _Enable_if_floating<_Tp>(1.41421356237309504876L);
        template <typename _Tp> constexpr _Tp sqrt3_v = _Enable_if_floating<_Tp>(1.73205080756887729357L);
        template <typename _Tp> constexpr _Tp inv_sqrt3_v = _Enable_if_floating<_Tp>(0.577350269189625764507L);
        template <typename _Tp> constexpr _Tp egamma_v = _Enable_if_floating<_Tp>(0.577215664901532860616L);
        template <typename _Tp> constexpr _Tp phi_v = _Enable_if_floating<_Tp>(1.61803398874989484821L);
        constexpr double e = e_v<double>;
        constexpr double e_v = _Enable_if_floating<double>(2.71828182845904523543L);
        constexpr double log2e = log2e_v<double>;
        constexpr double log2e_v = _Enable_if_floating<double>(1.44269504088896340739L);
        constexpr double log10e = log10e_v<double>;
        constexpr double log10e_v = _Enable_if_floating<double>(0.434294481903251827645L);
        constexpr double pi = pi_v<double>;
        constexpr double pi_v = _Enable_if_floating<double>(3.14159265358979323851L);
        constexpr double inv_pi = inv_pi_v<double>;
        constexpr double inv_pi_v = _Enable_if_floating<double>(0.318309886183790671538L);
        constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
        constexpr double inv_sqrtpi_v = _Enable_if_floating<double>(0.564189583547756286924L);
        constexpr double ln2 = ln2_v<double>;
        constexpr double ln2_v = _Enable_if_floating<double>(0.693147180559945309429L);
        constexpr double ln10 = ln10_v<double>;
        constexpr double ln10_v = _Enable_if_floating<double>(2.30258509299404568404L);
        constexpr double sqrt2 = sqrt2_v<double>;
        constexpr double sqrt2_v = _Enable_if_floating<double>(1.41421356237309504876L);
        constexpr double sqrt3 = sqrt3_v<double>;
        constexpr double sqrt3_v = _Enable_if_floating<double>(1.73205080756887729357L);
        constexpr double inv_sqrt3 = inv_sqrt3_v<double>;
        constexpr double inv_sqrt3_v = _Enable_if_floating<double>(0.577350269189625764507L);
        constexpr double egamma = egamma_v<double>;
        constexpr double egamma_v = _Enable_if_floating<double>(0.577215664901532860616L);
        constexpr double phi = phi_v<double>;
        constexpr double phi_v = _Enable_if_floating<double>(1.61803398874989484821L);
    }
}
namespace std {
    template <typename _Tp> struct numeric_limits;
    namespace ranges {
        namespace __detail {
            class __max_size_type {
            public:
                __max_size_type() = default
                template <typename _Tp> constexpr __max_size_type(_Tp __i) noexcept : _M_val(__i), _M_msb(__i < 0) {
                }
                template<> constexpr __max_size_type<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type __i) noexcept                template<> constexpr __max_size_type<int>(int __i) noexcept : _M_val(__i), _M_msb(__i < 0) {
                }
                template<> constexpr __max_size_type<unsigned __int128>(unsigned __int128 __i) noexcept : _M_val(__i), _M_msb(__i < 0) {
                }
                template<> constexpr __max_size_type<unsigned long>(unsigned long __i) noexcept : _M_val(__i), _M_msb(__i < 0) {
                }
                template<> constexpr __max_size_type<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type __i) noexcept                constexpr explicit __max_size_type(const __max_diff_type &__d) noexcept;
                template <typename _Tp> constexpr explicit operator _Tp() const noexcept {
                    return this->_M_val;
                }
                template<> constexpr explicit operator __max_size_type<std::ranges::__detail::__max_size_type>() const noexcept                template<> constexpr explicit operator __max_diff_type<std::ranges::__detail::__max_diff_type>() const noexcept                constexpr explicit operator bool() const noexcept {
                    return this->_M_val != 0 || this->_M_msb != 0;
                }
                constexpr __max_size_type operator+() const noexcept {
                    return *this;
                }
                constexpr __max_size_type operator~() const noexcept {
                    return __max_size_type{~this->_M_val, !this->_M_msb};
                }
                constexpr __max_size_type operator-() const noexcept {
                    return this->operator~() + 1;
                }
                constexpr __max_size_type &operator++() noexcept {
                    return *this += 1;
                }
                constexpr __max_size_type operator++(int) noexcept {
                    auto __tmp = *this;
                    ++ *this;
                    return __tmp;
                }
                constexpr __max_size_type &operator--() noexcept {
                    return *this -= 1;
                }
                constexpr __max_size_type operator--(int) noexcept {
                    auto __tmp = *this;
                    -- *this;
                    return __tmp;
                }
                constexpr __max_size_type &operator+=(const __max_size_type &__r) noexcept {
                    const auto __sum = this->_M_val + __r._M_val;
                    const bool __overflow = (__sum < this->_M_val);
                    this->_M_msb = this->_M_msb ^ __r._M_msb ^ __overflow;
                    this->_M_val = __sum;
                    return *this;
                }
                constexpr __max_size_type &operator-=(const __max_size_type &__r) noexcept {
                    return *this += - __r;
                }
                constexpr __max_size_type &operator*=(__max_size_type __r) noexcept {
                    constexpr __max_size_type __threshold = __rep(1) << (_S_rep_bits / 2 - 1);
                    if (this->_M_val < __threshold && __r < __threshold)
                        this->_M_val = this->_M_val * __r._M_val;
                    else {
                        const bool __lsb = this->_M_val & 1;
                        const bool __rlsb = __r._M_val & 1;
                        *this >>= 1;
                        __r >>= 1;
                        this->_M_val = (2 * this->_M_val * __r._M_val + this->_M_val * __rlsb + __r._M_val * __lsb);
                        *this <<= 1;
                        *this += __rlsb * __lsb;
                    }
                    return *this;
                }
                constexpr __max_size_type &operator/=(const __max_size_type &__r) noexcept {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r != 0))
                            __builtin_unreachable();
                    } while (false);
                    if (!this->_M_msb && !__r._M_msb)
 [[likely]]                        this->_M_val /= __r._M_val;
                    else if (this->_M_msb && __r._M_msb) {
                        this->_M_val = (this->_M_val >= __r._M_val);
                        this->_M_msb = 0;
                    } else if (!this->_M_msb && __r._M_msb)
                        this->_M_val = 0;
                    else if (this->_M_msb && !__r._M_msb) {
                        const auto __orig = *this;
                        *this >>= 1;
                        this->_M_val /= __r._M_val;
                        *this <<= 1;
                        if (__orig - *this * __r >= __r)
                            ++this->_M_val;
                    }
                    return *this;
                }
                constexpr __max_size_type &operator%=(const __max_size_type &__r) noexcept {
                    if (!this->_M_msb && !__r._M_msb)
 [[likely]]                        this->_M_val %= __r._M_val;
                    else
                        *this -= (*this / __r) * __r;
                    return *this;
                }
                constexpr __max_size_type &operator<<=(const __max_size_type &__r) noexcept {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r <= _S_rep_bits))
                            __builtin_unreachable();
                    } while (false);
                    if (__r != 0) {
                        this->_M_msb = (this->_M_val >> (_S_rep_bits - __r._M_val)) & 1;
                        if (__r._M_val == _S_rep_bits)
 [[unlikely]]                            this->_M_val = 0;
                        else
                            this->_M_val <<= __r._M_val;
                    }
                    return *this;
                }
                constexpr __max_size_type &operator>>=(const __max_size_type &__r) noexcept {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r <= _S_rep_bits))
                            __builtin_unreachable();
                    } while (false);
                    if (__r != 0) {
                        if (__r._M_val == _S_rep_bits)
 [[unlikely]]                            this->_M_val = 0;
                        else
                            this->_M_val >>= __r._M_val;
                        if (this->_M_msb)
 [[unlikely]]                            {
                                this->_M_val |= __rep(1) << (_S_rep_bits - __r._M_val);
                                this->_M_msb = 0;
                            }
                    }
                    return *this;
                }
                constexpr __max_size_type &operator&=(const __max_size_type &__r) noexcept {
                    this->_M_val &= __r._M_val;
                    this->_M_msb &= __r._M_msb;
                    return *this;
                }
                constexpr __max_size_type &operator|=(const __max_size_type &__r) noexcept {
                    this->_M_val |= __r._M_val;
                    this->_M_msb |= __r._M_msb;
                    return *this;
                }
                constexpr __max_size_type &operator^=(const __max_size_type &__r) noexcept {
                    this->_M_val ^= __r._M_val;
                    this->_M_msb ^= __r._M_msb;
                    return *this;
                }
                friend template <typename _Tp> constexpr _Tp &operator+=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a + __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator+=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator-=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a - __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator-=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator*=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a * __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator*=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator/=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a / __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator/=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator%=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a % __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator%=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator&=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a & __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator&=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator|=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a | __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator|=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator^=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a ^ __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator^=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator<<=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a << __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator<<=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator>>=(_Tp &__a, const __max_size_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a >> __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator>>=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const __max_size_type &__b) noexcept;
                friend constexpr __max_size_type operator+(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l += __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator-(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l -= __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator*(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l *= __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator/(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l /= __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator%(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l %= __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator<<(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l <<= __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator>>(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l >>= __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator&(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l &= __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator|(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l |= __r;
                    return __l;
                }
;
                friend constexpr __max_size_type operator^(__max_size_type __l, const __max_size_type &__r) noexcept {
                    __l ^= __r;
                    return __l;
                }
;
                friend constexpr bool operator==(const __max_size_type &__l, const __max_size_type &__r) noexcept {
                    return __l._M_val == __r._M_val && __l._M_msb == __r._M_msb;
                }
;
                friend constexpr strong_ordering operator<=>(const __max_size_type &__l, const __max_size_type &__r) noexcept {
                    if (__l._M_msb ^ __r._M_msb)
                        return __l._M_msb ? strong_ordering::greater : strong_ordering::less;
                    else
                        return __l._M_val <=> __r._M_val;
                }
;
                using __rep = unsigned __int128;
                static constexpr size_t _S_rep_bits = sizeof(__rep) * 8;
            private:
                __rep _M_val = 0;
                unsigned int _M_msb : 1 = 0;
                constexpr explicit __max_size_type(__rep __val, int __msb) noexcept : _M_val(__val), _M_msb(__msb) {
                }
                friend  __max_diff_type;
                friend  std::numeric_limits<__max_size_type>;
                friend  std::numeric_limits<__max_diff_type>;
            };
            class __max_diff_type {
            public:
                __max_diff_type() = default
                template <typename _Tp> constexpr __max_diff_type(_Tp __i) noexcept : _M_rep(__i) {
                }
                template<> constexpr __max_diff_type<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type __i) noexcept                template<> constexpr __max_diff_type<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type __i) noexcept                template<> constexpr __max_diff_type<int>(int __i) noexcept : _M_rep(__i) {
                }
                constexpr explicit __max_diff_type(const __max_size_type &__d) noexcept : _M_rep(__d) {
                }
                template <typename _Tp> constexpr explicit operator _Tp() const noexcept {
                    return static_cast<_Tp>(this->_M_rep);
                }
                template<> constexpr explicit operator __max_size_type<std::ranges::__detail::__max_size_type>() const noexcept                constexpr explicit operator bool() const noexcept {
                    return this->_M_rep != 0;
                }
                constexpr __max_diff_type operator+() const noexcept {
                    return *this;
                }
                constexpr __max_diff_type operator-() const noexcept {
                    return __max_diff_type(- this->_M_rep);
                }
                constexpr __max_diff_type operator~() const noexcept {
                    return __max_diff_type(~ this->_M_rep);
                }
                constexpr __max_diff_type &operator++() noexcept {
                    return *this += 1;
                }
                constexpr __max_diff_type operator++(int) noexcept {
                    auto __tmp = *this;
                    ++ *this;
                    return __tmp;
                }
                constexpr __max_diff_type &operator--() noexcept {
                    return *this -= 1;
                }
                constexpr __max_diff_type operator--(int) noexcept {
                    auto __tmp = *this;
                    -- *this;
                    return __tmp;
                }
                constexpr __max_diff_type &operator+=(const __max_diff_type &__r) noexcept {
                    this->_M_rep += __r._M_rep;
                    return *this;
                }
                constexpr __max_diff_type &operator-=(const __max_diff_type &__r) noexcept {
                    this->_M_rep -= __r._M_rep;
                    return *this;
                }
                constexpr __max_diff_type &operator*=(const __max_diff_type &__r) noexcept {
                    this->_M_rep *= __r._M_rep;
                    return *this;
                }
                constexpr __max_diff_type &operator/=(const __max_diff_type &__r) noexcept {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r != 0))
                            __builtin_unreachable();
                    } while (false);
                    const bool __neg = *this < 0;
                    const bool __rneg = __r < 0;
                    if (!__neg && !__rneg)
                        this->_M_rep = this->_M_rep / __r._M_rep;
                    else if (__neg && __rneg)
                        this->_M_rep = - this->_M_rep / - __r._M_rep;
                    else if (__neg && !__rneg)
                        this->_M_rep = - (- this->_M_rep / __r._M_rep);
                    else
                        this->_M_rep = - (this->_M_rep / - __r._M_rep);
                    return *this;
                }
                constexpr __max_diff_type &operator%=(const __max_diff_type &__r) noexcept {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r != 0))
                            __builtin_unreachable();
                    } while (false);
                    if (*this >= 0 && __r > 0)
                        this->_M_rep %= __r._M_rep;
                    else
                        *this -= (*this / __r) * __r;
                    return *this;
                }
                constexpr __max_diff_type &operator<<=(const __max_diff_type &__r) noexcept {
                    this->_M_rep.operator<<=(__r._M_rep);
                    return *this;
                }
                constexpr __max_diff_type &operator>>=(const __max_diff_type &__r) noexcept {
                    const auto __msb = this->_M_rep._M_msb;
                    this->_M_rep >>= __r._M_rep;
                    if (__msb)
                        this->_M_rep |= ~ (__max_size_type(-1) >> __r._M_rep);
                    return *this;
                }
                constexpr __max_diff_type &operator&=(const __max_diff_type &__r) noexcept {
                    this->_M_rep &= __r._M_rep;
                    return *this;
                }
                constexpr __max_diff_type &operator|=(const __max_diff_type &__r) noexcept {
                    this->_M_rep |= __r._M_rep;
                    return *this;
                }
                constexpr __max_diff_type &operator^=(const __max_diff_type &__r) noexcept {
                    this->_M_rep ^= __r._M_rep;
                    return *this;
                }
                friend template <typename _Tp> constexpr _Tp &operator+=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a + __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator+=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator-=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a - __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator-=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator*=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a * __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator*=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator/=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a / __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator/=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator%=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a % __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator%=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator&=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a & __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator&=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator|=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a | __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator|=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator^=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a ^ __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator^=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator<<=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a << __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator<<=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator>>=(_Tp &__a, const __max_diff_type &__b) noexcept {
                    return (__a = static_cast<_Tp>(__a >> __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator>>=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const __max_diff_type &__b) noexcept;
                friend constexpr __max_diff_type operator+(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l += __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator-(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l -= __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator*(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l *= __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator/(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l /= __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator%(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l %= __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator<<(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l <<= __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator>>(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l >>= __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator&(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l &= __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator|(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l |= __r;
                    return __l;
                }
;
                friend constexpr __max_diff_type operator^(__max_diff_type __l, const __max_diff_type &__r) noexcept {
                    __l ^= __r;
                    return __l;
                }
;
                friend constexpr bool operator==(const __max_diff_type &__l, const __max_diff_type &__r) noexcept {
                    return __l._M_rep == __r._M_rep;
                }
;
                constexpr strong_ordering operator<=>(const __max_diff_type &__r) const noexcept {
                    const auto __lsign = this->_M_rep._M_msb;
                    const auto __rsign = __r._M_rep._M_msb;
                    if (__lsign ^ __rsign)
                        return __lsign ? strong_ordering::less : strong_ordering::greater;
                    else
                        return this->_M_rep <=> __r._M_rep;
                }
            private:
                __max_size_type _M_rep = 0;
                friend  class __max_size_type;
            };
            constexpr explicit __max_size_type::__max_size_type(const __max_diff_type &__d) noexcept : NULL TYPE(__d._M_rep) {
            }
        }
    }
    template<> struct numeric_limits<ranges::__detail::__max_size_type> {
        using _Sp = ranges::__detail::__max_size_type;
        static constexpr bool is_specialized = true;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int digits = __gnu_cxx::__int_traits<_Sp::__rep>::__digits + 1;
        static constexpr int digits10 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);
        static constexpr _Sp min() noexcept {
            return 0;
        }
        static constexpr _Sp max() noexcept {
            return _Sp(static_cast<_Sp::__rep>(-1), 1);
        }
        static constexpr _Sp lowest() noexcept {
            return min();
        }
    };
    template<> struct numeric_limits<ranges::__detail::__max_diff_type> {
        using _Dp = ranges::__detail::__max_diff_type;
        using _Sp = ranges::__detail::__max_size_type;
        static constexpr bool is_specialized = true;
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int digits = numeric_limits<_Sp>::digits - 1;
        static constexpr int digits10 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);
        static constexpr _Dp min() noexcept {
            return _Dp(_Sp(0, 1));
        }
        static constexpr _Dp max() noexcept {
            return _Dp(_Sp(static_cast<_Sp::__rep>(-1), 0));
        }
        static constexpr _Dp lowest() noexcept {
            return min();
        }
    };
}
namespace std {
    namespace ranges {
        template <typename> constexpr bool disable_sized_range = false;
        template <typename _Tp> constexpr bool enable_borrowed_range = false;
        namespace __detail {
            constexpr __max_size_type __to_unsigned_like(__max_size_type __t) noexcept {
                return __t;
            }
            constexpr __max_size_type __to_unsigned_like(__max_diff_type __t) noexcept {
                return __max_size_type(__t);
            }
            template <integral _Tp> constexpr auto __to_unsigned_like(_Tp __t) noexcept {
                return static_cast<make_unsigned_t<_Tp>>(__t);
            }
            constexpr unsigned __int128 __to_unsigned_like(__int128 __t) noexcept {
                return __t;
            }
            constexpr unsigned __int128 __to_unsigned_like(unsigned __int128 __t) noexcept {
                return __t;
            }
            template <typename _Tp> using __make_unsigned_like_t = decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));
            template <typename _Tp> concept __maybe_borrowed_range = is_lvalue_reference_v<_Tp> || enable_borrowed_range<remove_cvref_t<_Tp>>;
        }
        namespace __cust_access {
            using std::ranges::__detail::__maybe_borrowed_range;
            using std::__detail::__range_iter_t;
            struct _Begin {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept() {
                    if (is_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_begin<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().begin()));
                    else
                        return noexcept(__decay_copy(begin(std::declval<_Tp &>())));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]] {
                    if (is_array_v<remove_reference_t<_Tp>>) {
                        static_assert(is_lvalue_reference_v<_Tp>);
                        return __t + 0;
                    } else if (__member_begin<_Tp>)
                        return __t.begin();
                    else
                        return begin(__t);
                }
            };
            template <typename _Tp> concept __member_end = requires (_Tp &__t) { { __decay_copy(__t.end()) } -> sentinel_for<__range_iter_t<_Tp>>; };
            template <> void end(auto &) = delete
            template <> void end(const auto &) = delete
            template <typename _Tp> concept __adl_end = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(end(__t)) } -> sentinel_for<__range_iter_t<_Tp>>; };
            struct _End {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept() {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_end<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().end()));
                    else
                        return noexcept(__decay_copy(end(std::declval<_Tp &>())));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]] {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>) {
                        static_assert(is_lvalue_reference_v<_Tp>);
                        return __t + extent_v<remove_reference_t<_Tp>>;
                    } else if (__member_end<_Tp>)
                        return __t.end();
                    else
                        return end(__t);
                }
            };
            template <typename _Tp> concept __member_rbegin = requires (_Tp &__t) { { __decay_copy(__t.rbegin()) } -> input_or_output_iterator; };
            template <> void rbegin(auto &) = delete
            template <> void rbegin(const auto &) = delete
            template <typename _Tp> concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(rbegin(__t)) } -> input_or_output_iterator; };
            template <typename _Tp> concept __reversable = requires (_Tp &__t) { { _Begin{}(__t) } -> bidirectional_iterator; { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>; };
            struct _RBegin {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept() {
                    if (__member_rbegin<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().rbegin()));
                    else if (__adl_rbegin<_Tp>)
                        return noexcept(__decay_copy(rbegin(std::declval<_Tp &>())));
                    else {
                        if (noexcept(_End{}(std::declval<_Tp &>()))) {
                            using _It = decltype(_End{}(std::declval<_Tp &>()));
                            return is_nothrow_copy_constructible_v<_It>;
                        } else
                            return false;
                    }
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]] {
                    if (__member_rbegin<_Tp>)
                        return __t.rbegin();
                    else if (__adl_rbegin<_Tp>)
                        return rbegin(__t);
                    else
                        return std::make_reverse_iterator(_End{}(__t));
                }
            };
            template <typename _Tp> concept __member_rend = requires (_Tp &__t) { { __decay_copy(__t.rend()) } -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>; };
            template <> void rend(auto &) = delete
            template <> void rend(const auto &) = delete
            template <typename _Tp> concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(rend(__t)) } -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>; };
            struct _REnd {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept() {
                    if (__member_rend<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().rend()));
                    else if (__adl_rend<_Tp>)
                        return noexcept(__decay_copy(rend(std::declval<_Tp &>())));
                    else {
                        if (noexcept(_Begin{}(std::declval<_Tp &>()))) {
                            using _It = decltype(_Begin{}(std::declval<_Tp &>()));
                            return is_nothrow_copy_constructible_v<_It>;
                        } else
                            return false;
                    }
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]] {
                    if (__member_rend<_Tp>)
                        return __t.rend();
                    else if (__adl_rend<_Tp>)
                        return rend(__t);
                    else
                        return std::make_reverse_iterator(_Begin{}(__t));
                }
            };
            template <typename _Tp> concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(__t.size()) } -> __detail::__is_integer_like; };
            template <> void size(auto &) = delete
            template <> void size(const auto &) = delete
            template <typename _Tp> concept __adl_size = __class_or_enum<remove_reference_t<_Tp>> && !disable_sized_range<remove_cvref_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(size(__t)) } -> __detail::__is_integer_like; };
            template <typename _Tp> concept __sentinel_size = requires (_Tp &__t) { requires (!is_unbounded_array_v<remove_reference_t<_Tp>>); { _Begin{}(__t) } -> forward_iterator; { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>; __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t)); };
            struct _Size {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept() {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_size<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().size()));
                    else if (__adl_size<_Tp>)
                        return noexcept(__decay_copy(size(std::declval<_Tp &>())));
                    else if (__sentinel_size<_Tp>)
                        return noexcept(_End{}(std::declval<_Tp &>()) - _Begin{}(std::declval<_Tp &>()));
                }
            public:
                template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]] {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>)
                        return extent_v<remove_reference_t<_Tp>>;
                    else if (__member_size<_Tp>)
                        return __t.size();
                    else if (__adl_size<_Tp>)
                        return size(__t);
                    else if (__sentinel_size<_Tp>)
                        return __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));
                }
            };
            struct _SSize {
                template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(_Size{}(__t))) [[nodiscard("")]] {
                    auto __size = _Size{}(__t);
                    using __size_type = decltype(__size);
                    if (integral<__size_type>) {
                        using __gnu_cxx::__int_traits;
                        if (__int_traits<__size_type>::__digits < __int_traits<ptrdiff_t>::__digits)
                            return static_cast<ptrdiff_t>(__size);
                        else
                            return static_cast<make_signed_t<__size_type>>(__size);
                    } else if (__detail::__is_int128<__size_type>)
                        return static_cast<__int128>(__size);
                    else
                        return __detail::__max_diff_type(__size);
                }
            };
            template <typename _Tp> concept __member_empty = requires (_Tp &__t) { bool(__t.empty()); };
            template <typename _Tp> concept __size0_empty = requires (_Tp &__t) { _Size{}(__t) == 0; };
            template <typename _Tp> concept __eq_iter_empty = requires (_Tp &__t) { requires (!is_unbounded_array_v<remove_reference_t<_Tp>>); { _Begin{}(__t) } -> forward_iterator; bool(_Begin{}(__t) == _End{}(__t)); };
            struct _Empty {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept() {
                    if (__member_empty<_Tp>)
                        return noexcept(bool(std::declval<_Tp &>().empty()));
                    else if (__size0_empty<_Tp>)
                        return noexcept(_Size{}(std::declval<_Tp &>()) == 0);
                    else
                        return noexcept(bool(_Begin{}(std::declval<_Tp &>()) == _End{}(std::declval<_Tp &>())));
                }
            public:
                template <typename _Tp> constexpr bool operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]] {
                    if (__member_empty<_Tp>)
                        return bool(__t.empty());
                    else if (__size0_empty<_Tp>)
                        return _Size{}(__t) == 0;
                    else
                        return bool(_Begin{}(__t) == _End{}(__t));
                }
            };
            template <typename _Tp> concept __pointer_to_object = is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;
            template <typename _Tp> concept __member_data = requires (_Tp &__t) { { __decay_copy(__t.data()) } -> __pointer_to_object; };
            template <typename _Tp> concept __begin_data = contiguous_iterator<__range_iter_t<_Tp>>;
            struct _Data {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept() {
                    if (__member_data<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().data()));
                    else
                        return noexcept(_Begin{}(std::declval<_Tp &>()));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>()) [[nodiscard("")]] {
                    if (__member_data<_Tp>)
                        return __t.data();
                    else
                        return std::to_address(_Begin{}(__t));
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_access::_Begin begin{};
            constexpr __cust_access::_End end{};
            constexpr __cust_access::_RBegin rbegin{};
            constexpr __cust_access::_REnd rend{};
            constexpr __cust_access::_Size size{};
            constexpr __cust_access::_SSize ssize{};
            constexpr __cust_access::_Empty empty{};
            constexpr __cust_access::_Data data{};
        }
        template <typename _Tp> concept range = requires (_Tp &__t) { ranges::begin(__t); ranges::end(__t); };
        template <typename _Tp> concept borrowed_range = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;
        template <typename _Tp> using iterator_t = std::__detail::__range_iter_t<_Tp>;
        template <range _Range> using sentinel_t = decltype(ranges::end(std::declval<_Range &>()));
        template <range _Range> using range_difference_t = iter_difference_t<iterator_t<_Range>>;
        template <range _Range> using range_value_t = iter_value_t<iterator_t<_Range>>;
        template <range _Range> using range_reference_t = iter_reference_t<iterator_t<_Range>>;
        template <range _Range> using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Range>>;
        template <typename _Tp> concept sized_range = range<_Tp> && requires (_Tp &__t) { ranges::size(__t); };
        template <sized_range _Range> using range_size_t = decltype(ranges::size(std::declval<_Range &>()));
        template <typename _Derived> class view_interface;
        namespace __detail {
            template <typename _Tp, typename _Up> void __is_derived_from_view_interface_fn(const _Tp &, const view_interface<_Up> &);
            template <typename _Tp> concept __is_derived_from_view_interface = requires (_Tp __t) { __is_derived_from_view_interface_fn(__t, __t); };
        }
        struct view_base {
        };
        template <typename _Tp> constexpr bool enable_view = derived_from<_Tp, view_base> || __detail::__is_derived_from_view_interface<_Tp>;
        template <typename _Tp> concept view = range<_Tp> && movable<_Tp> && enable_view<_Tp>;
        template <typename _Range, typename _Tp> concept output_range = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;
        template <typename _Tp> concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
        template <typename _Tp> concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
        template <typename _Tp> concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
        template <typename _Tp> concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
        template <typename _Tp> concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires (_Tp &__t) { { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>; };
        template <typename _Tp> concept common_range = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;
        namespace __cust_access {
            template <typename _To, typename _Tp> constexpr decltype(auto) __as_const(_Tp &__t) noexcept {
                static_assert(std::is_same_v<_To &, _Tp &>);
                if (is_lvalue_reference_v<_To>)
                    return const_cast<const _Tp &>(__t);
                else
                    return static_cast<const _Tp &&>(__t);
            }
            struct _CBegin {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(_Begin{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { _Begin{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]] {
                    return _Begin{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
            struct final _CEnd final {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(_End{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { _End{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]] {
                    return _End{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
            struct _CRBegin {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(_RBegin{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { _RBegin{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]] {
                    return _RBegin{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
            struct _CREnd {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(_REnd{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { _REnd{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]] {
                    return _REnd{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
            struct _CData {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(_Data{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { _Data{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]] {
                    return _Data{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_access::_CBegin cbegin{};
            constexpr __cust_access::_CEnd cend{};
            constexpr __cust_access::_CRBegin crbegin{};
            constexpr __cust_access::_CREnd crend{};
            constexpr __cust_access::_CData cdata{};
        }
        namespace __detail {
            template <typename _Tp> constexpr bool __is_initializer_list = false;
            constexpr bool __is_initializer_list = true;
        }
        template <typename _Tp> concept viewable_range = range<_Tp> && ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>) || (!view<remove_cvref_t<_Tp>> && (is_lvalue_reference_v<_Tp> || (movable<remove_reference_t<_Tp>> && !__detail::__is_initializer_list<remove_cvref_t<_Tp>>))));
        struct final __advance_fn final {
            template <input_or_output_iterator _It> constexpr void operator()(_It &__it, iter_difference_t<_It> __n) const {
                if (random_access_iterator<_It>)
                    __it += __n;
                else if (bidirectional_iterator<_It>) {
                    if (__n > 0) {
                        do {
                            ++__it;
                        } while (--__n);
                    } else if (__n < 0) {
                        do {
                            --__it;
                        } while (++__n);
                    }
                } else {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__n >= 0))
                            __builtin_unreachable();
                    } while (false);
                    while (__n-- > 0)
                        ++__it;
                }
            }
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr void operator()(_It &__it, _Sent __bound) const {
                if (assignable_from<_It &, _Sent>)
                    __it = std::move(__bound);
                else if (sized_sentinel_for<_Sent, _It>)
                    (*this)(__it, __bound - __it);
                else {
                    while (__it != __bound)
                        ++__it;
                }
            }
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr iter_difference_t<_It> operator()(_It &__it, iter_difference_t<_It> __n, _Sent __bound) const {
                if (sized_sentinel_for<_Sent, _It>) {
                    const auto __diff = __bound - __it;
                    if (__diff == 0)
                        return __n;
                    else if (__diff > 0 ? __n >= __diff : __n <= __diff) {
                        (*this)(__it, __bound);
                        return __n - __diff;
                    } else if (__n != 0)
 [[likely]]                        {
                            do {
                                if (std::__is_constant_evaluated() && !bool((__n < 0) == (__diff < 0)))
                                    __builtin_unreachable();
                            } while (false);
                            (*this)(__it, __n);
                            return 0;
                        }
                    else
                        return 0;
                } else if (__it == __bound || __n == 0)
                    return __n;
                else if (__n > 0) {
                    iter_difference_t<_It> __m = 0;
                    do {
                        ++__it;
                        ++__m;
                    } while (__m != __n && __it != __bound);
                    return __n - __m;
                } else if (bidirectional_iterator<_It> && same_as<_It, _Sent>) {
                    iter_difference_t<_It> __m = 0;
                    do {
                        --__it;
                        --__m;
                    } while (__m != __n && __it != __bound);
                    return __n - __m;
                } else {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__n >= 0))
                            __builtin_unreachable();
                    } while (false);
                    return __n;
                }
            }
            void operator&() const = delete
        };
        constexpr __advance_fn advance{};
        struct final __distance_fn final {
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr iter_difference_t<_It> operator()(_It __first, _Sent __last) const [[nodiscard("")]] {
                iter_difference_t<_It> __n = 0;
                while (__first != __last)
                    {
                        ++__first;
                        ++__n;
                    }
                return __n;
            }
            template <input_or_output_iterator _It, sized_sentinel_for<_It> _Sent> constexpr iter_difference_t<_It> operator()(const _It &__first, const _Sent &__last) const [[nodiscard("")]] {
                return __last - __first;
            }
            template <range _Range> constexpr range_difference_t<_Range> operator()(_Range &&__r) const [[nodiscard("")]] {
                if (sized_range<_Range>)
                    return static_cast<range_difference_t<_Range>>(ranges::size(__r));
                else
                    return (*this)(ranges::begin(__r), ranges::end(__r));
            }
            void operator&() const = delete
        };
        constexpr __distance_fn distance{};
        struct final __next_fn final {
            template <input_or_output_iterator _It> constexpr _It operator()(_It __x) const [[nodiscard("")]] {
                ++__x;
                return __x;
            }
            template <input_or_output_iterator _It> constexpr _It operator()(_It __x, iter_difference_t<_It> __n) const [[nodiscard("")]] {
                ranges::advance(__x, __n);
                return __x;
            }
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr _It operator()(_It __x, _Sent __bound) const [[nodiscard("")]] {
                ranges::advance(__x, __bound);
                return __x;
            }
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr _It operator()(_It __x, iter_difference_t<_It> __n, _Sent __bound) const [[nodiscard("")]] {
                ranges::advance(__x, __n, __bound);
                return __x;
            }
            void operator&() const = delete
        };
        constexpr __next_fn next{};
        struct final __prev_fn final {
            template <bidirectional_iterator _It> constexpr _It operator()(_It __x) const [[nodiscard("")]] {
                --__x;
                return __x;
            }
            template <bidirectional_iterator _It> constexpr _It operator()(_It __x, iter_difference_t<_It> __n) const [[nodiscard("")]] {
                ranges::advance(__x, - __n);
                return __x;
            }
            template <bidirectional_iterator _It> constexpr _It operator()(_It __x, iter_difference_t<_It> __n, _It __bound) const [[nodiscard("")]] {
                ranges::advance(__x, - __n, __bound);
                return __x;
            }
            void operator&() const = delete
        };
        constexpr __prev_fn prev{};
        struct dangling {
            dangling() noexcept = default
            template <typename ..._Args> constexpr dangling(_Args &&...) noexcept {
            }
        };
        template <range _Range> using borrowed_iterator_t = __conditional_t<borrowed_range<_Range>, iterator_t<_Range>, dangling>;
    }
}
namespace std {
    constexpr size_t __sv_check(size_t __size, size_t __pos, const char *__s) {
        if (__pos > __size)
            __throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size (which is %zu)"), __s, __pos, __size);
        return __pos;
    }
    constexpr size_t __sv_limit(size_t __size, size_t __pos, size_t __off) noexcept {
        const bool __testoff = __off < __size - __pos;
        return __testoff ? __off : __size - __pos;
    }
    template <typename _CharT, typename _Traits = std::char_traits<_CharT>> class basic_string_view {
        static_assert(!is_array_v<_CharT>);
        static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
        static_assert(is_same_v<_CharT, typename _Traits::char_type>);
    public:
        using traits_type = _Traits;
        using value_type = _CharT;
        using pointer = value_type *;
        using const_pointer = const value_type *;
        using reference = value_type &;
        using const_reference = const value_type &;
        using const_iterator = const value_type *;
        using iterator = const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = const_reverse_iterator;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        static constexpr size_type npos = size_type(-1);
        constexpr basic_string_view<_CharT, _Traits>() noexcept : _M_len({0}), _M_str({nullptr}) {
        }
        basic_string_view<_CharT, _Traits>(const basic_string_view<_CharT, _Traits> &) noexcept = default
        constexpr basic_string_view<_CharT, _Traits>(const _CharT *__str) noexcept : _M_len({traits_type::length(__str)}), _M_str({__str}) [[gnu::nonnull]] {
        }
        constexpr basic_string_view<_CharT, _Traits>(const _CharT *__str, size_type __len) noexcept : _M_len({__len}), _M_str({__str}) {
        }
        template <contiguous_iterator _It, sized_sentinel_for<_It> _End> constexpr basic_string_view<_CharT, _Traits>(_It __first, _End __last) noexcept(noexcept(__last - __first)) : _M_len(__last - __first), _M_str(std::to_address(__first)) {
        }
        basic_string_view<_CharT, _Traits> &operator=(const basic_string_view<_CharT, _Traits> &) noexcept = default
        constexpr const_iterator begin() const noexcept [[nodiscard("")]] {
            return this->_M_str;
        }
        constexpr const_iterator end() const noexcept [[nodiscard("")]] {
            return this->_M_str + this->_M_len;
        }
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]] {
            return this->_M_str;
        }
        constexpr const_iterator cend() const noexcept [[nodiscard("")]] {
            return this->_M_str + this->_M_len;
        }
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(this->end());
        }
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(this->begin());
        }
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(this->end());
        }
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(this->begin());
        }
        constexpr size_type size() const noexcept [[nodiscard("")]] {
            return this->_M_len;
        }
        constexpr size_type length() const noexcept [[nodiscard("")]] {
            return this->_M_len;
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]] {
            return (npos - sizeof(size_type) - sizeof(void *)) / sizeof(value_type) / 4;
        }
        constexpr bool empty() const noexcept [[nodiscard("")]] {
            return this->_M_len == 0;
        }
        constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(__pos < this->_M_len))
                    __builtin_unreachable();
            } while (false);
            return *(this->_M_str + __pos);
        }
        constexpr const_reference at(size_type __pos) const [[nodiscard("")]] {
            if (__pos >= this->_M_len)
                __throw_out_of_range_fmt(("basic_string_view::at: __pos (which is %zu) >= this->size() (which is %zu)"), __pos, this->size());
            return *(this->_M_str + __pos);
        }
        constexpr const_reference front() const noexcept [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_len > 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_str;
        }
        constexpr const_reference back() const noexcept [[nodiscard("")]] {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_len > 0))
                    __builtin_unreachable();
            } while (false);
            return *(this->_M_str + this->_M_len - 1);
        }
        constexpr const_pointer data() const noexcept [[nodiscard("")]] {
            return this->_M_str;
        }
        constexpr void remove_prefix(size_type __n) noexcept {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_len >= __n))
                    __builtin_unreachable();
            } while (false);
            this->_M_str += __n;
            this->_M_len -= __n;
        }
        constexpr void remove_suffix(size_type __n) noexcept {
            this->_M_len -= __n;
        }
        constexpr void swap(basic_string_view<_CharT, _Traits> &__sv) noexcept {
            auto __tmp = *this;
            *this = __sv;
            __sv = __tmp;
        }
        constexpr size_type copy(_CharT *__str, size_type __n, size_type __pos = 0) const {
            ;
            __pos = std::__sv_check(this->size(), __pos, "basic_string_view::copy");
            const size_type __rlen = std::min<size_t>(__n, this->_M_len - __pos);
            traits_type::copy(__str, this->data() + __pos, __rlen);
            return __rlen;
        }
        constexpr basic_string_view<_CharT, _Traits> substr(size_type __pos = 0, size_type __n = npos) const noexcept(false) [[nodiscard("")]] {
            __pos = std::__sv_check(this->size(), __pos, "basic_string_view::substr");
            const size_type __rlen = std::min<size_t>(__n, this->_M_len - __pos);
            return basic_string_view<_CharT, _Traits>{this->_M_str + __pos, __rlen};
        }
        constexpr int compare(basic_string_view<_CharT, _Traits> __str) const noexcept [[nodiscard("")]] {
            const size_type __rlen = std::min(this->_M_len, __str._M_len);
            int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
            if (__ret == 0)
                __ret = _S_compare(this->_M_len, __str._M_len);
            return __ret;
        }
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<_CharT, _Traits> __str) const [[nodiscard("")]] {
            return this->substr(__pos1, __n1).compare(__str);
        }
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<_CharT, _Traits> __str, size_type __pos2, size_type __n2) const [[nodiscard("")]] {
            return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
        }
        constexpr int compare(const _CharT *__str) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->compare(basic_string_view<_CharT, _Traits>{__str});
        }
        constexpr int compare(size_type __pos1, size_type __n1, const _CharT *__str) const [[nodiscard("")]] [[gnu::nonnull]] {
            return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>{__str});
        }
        constexpr int compare(size_type __pos1, size_type __n1, const _CharT *__str, size_type __n2) const noexcept(false) [[nodiscard("")]] {
            return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>(__str, __n2));
        }
        constexpr bool starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept [[nodiscard("")]] {
            return this->substr(0, __x.size()) == __x;
        }
        constexpr bool starts_with(_CharT __x) const noexcept [[nodiscard("")]] {
            return !this->empty() && traits_type::eq(this->front(), __x);
        }
        constexpr bool starts_with(const _CharT *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->starts_with(basic_string_view<_CharT, _Traits>(__x));
        }
        constexpr bool ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept [[nodiscard("")]] {
            const auto __len = this->size();
            const auto __xlen = __x.size();
            return __len >= __xlen && traits_type::compare(this->end() - __xlen, __x.data(), __xlen) == 0;
        }
        constexpr bool ends_with(_CharT __x) const noexcept [[nodiscard("")]] {
            return !this->empty() && traits_type::eq(this->back(), __x);
        }
        constexpr bool ends_with(const _CharT *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->ends_with(basic_string_view<_CharT, _Traits>(__x));
        }
        constexpr size_type find(basic_string_view<_CharT, _Traits> __str, size_type __pos = 0) const noexcept [[nodiscard("")]] {
            return this->find(__str._M_str, __pos, __str._M_len);
        }
        constexpr size_type find(_CharT __c, size_type __pos = 0) const noexcept [[nodiscard("")]];
        constexpr size_type find(const _CharT *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find(const _CharT *__str, size_type __pos = 0) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->find(__str, __pos, traits_type::length(__str));
        }
        constexpr size_type rfind(basic_string_view<_CharT, _Traits> __str, size_type __pos = npos) const noexcept [[nodiscard("")]] {
            return this->rfind(__str._M_str, __pos, __str._M_len);
        }
        constexpr size_type rfind(_CharT __c, size_type __pos = npos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const _CharT *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const _CharT *__str, size_type __pos = npos) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->rfind(__str, __pos, traits_type::length(__str));
        }
        constexpr size_type find_first_of(basic_string_view<_CharT, _Traits> __str, size_type __pos = 0) const noexcept [[nodiscard("")]] {
            return this->find_first_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept [[nodiscard("")]] {
            return this->find(__c, __pos);
        }
        constexpr size_type find_first_of(const _CharT *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const _CharT *__str, size_type __pos = 0) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->find_first_of(__str, __pos, traits_type::length(__str));
        }
        constexpr size_type find_last_of(basic_string_view<_CharT, _Traits> __str, size_type __pos = npos) const noexcept [[nodiscard("")]] {
            return this->find_last_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept [[nodiscard("")]] {
            return this->rfind(__c, __pos);
        }
        constexpr size_type find_last_of(const _CharT *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const _CharT *__str, size_type __pos = npos) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->find_last_of(__str, __pos, traits_type::length(__str));
        }
        constexpr size_type find_first_not_of(basic_string_view<_CharT, _Traits> __str, size_type __pos = 0) const noexcept [[nodiscard("")]] {
            return this->find_first_not_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr size_type find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const _CharT *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const _CharT *__str, size_type __pos = 0) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->find_first_not_of(__str, __pos, traits_type::length(__str));
        }
        constexpr size_type find_last_not_of(basic_string_view<_CharT, _Traits> __str, size_type __pos = npos) const noexcept [[nodiscard("")]] {
            return this->find_last_not_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr size_type find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const _CharT *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const _CharT *__str, size_type __pos = npos) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
            return this->find_last_not_of(__str, __pos, traits_type::length(__str));
        }
    private:
        static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept {
            using __limits = __gnu_cxx::__int_traits<int>;
            const difference_type __diff = __n1 - __n2;
            if (__diff > __limits::__max)
                return __limits::__max;
            if (__diff < __limits::__min)
                return __limits::__min;
            return static_cast<int>(__diff);
        }
        size_t _M_len;
        const _CharT *_M_str;
    };
    template<> class basic_string_view<char, std::char_traits<char>> {
        static_assert(!is_array_v<char>);
        static_assert(is_trivial_v<char> && is_standard_layout_v<char>);
        static_assert(is_same_v<char, typename char_traits<char>::char_type>);
    public:
        using traits_type = std::char_traits<char>;
        using value_type = char;
        using pointer = value_type *;
        using const_pointer = const value_type *;
        using reference = value_type &;
        using const_reference = const value_type &;
        using const_iterator = const value_type *;
        using iterator = const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = const_reverse_iterator;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        static constexpr size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const basic_string_view<char> &) noexcept = default
        constexpr basic_string_view(const char *__str) noexcept [[gnu::nonnull]];
        constexpr basic_string_view(const char *__str, size_type __len) noexcept : _M_len({__len}), _M_str({__str}) {
        }
        template <contiguous_iterator _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char *, unsigned long>(const char *__first, unsigned long __last);
        basic_string_view<char> &operator=(const basic_string_view<char> &) noexcept = default
        constexpr const_iterator begin() const noexcept [[nodiscard("")]];
        constexpr const_iterator end() const noexcept [[nodiscard("")]];
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
        constexpr const_iterator cend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        constexpr size_type size() const noexcept [[nodiscard("")]];
        constexpr size_type length() const noexcept [[nodiscard("")]] {
            return this->_M_len;
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]];
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
        constexpr const_reference at(size_type __pos) const [[nodiscard("")]];
        constexpr const_reference front() const noexcept [[nodiscard("")]];
        constexpr const_reference back() const noexcept [[nodiscard("")]];
        constexpr const_pointer data() const noexcept [[nodiscard("")]] {
            return this->_M_str;
        }
        constexpr void remove_prefix(size_type __n) noexcept;
        constexpr void remove_suffix(size_type __n) noexcept;
        constexpr void swap(basic_string_view<char> &__sv) noexcept;
        constexpr size_type copy(char *__str, size_type __n, size_type __pos) const;
        constexpr basic_string_view<char> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
        constexpr int compare(basic_string_view<char> __str) const noexcept [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<char> __str) const [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<char> __str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
        constexpr int compare(const char *__str) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const char *__str) const [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const char *__str, size_type __n2) const [[nodiscard("")]];
        constexpr bool starts_with(basic_string_view<char> __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(char __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(const char *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr bool ends_with(basic_string_view<char> __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(char __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(const char *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find(basic_string_view<char> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(char __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(const char *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find(const char *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type rfind(basic_string_view<char> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(char __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const char *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const char *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_of(basic_string_view<char> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const char *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const char *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_of(basic_string_view<char> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const char *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const char *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_not_of(basic_string_view<char> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const char *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const char *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_not_of(basic_string_view<char> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const char *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const char *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
    private:
        static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
        size_t _M_len;
        const char *_M_str;
    };
    template<> class basic_string_view<wchar_t, std::char_traits<wchar_t>> {
        static_assert(!is_array_v<wchar_t>);
        static_assert(is_trivial_v<wchar_t> && is_standard_layout_v<wchar_t>);
        static_assert(is_same_v<wchar_t, typename char_traits<wchar_t>::char_type>);
    public:
        using traits_type = std::char_traits<wchar_t>;
        using value_type = wchar_t;
        using pointer = value_type *;
        using const_pointer = const value_type *;
        using reference = value_type &;
        using const_reference = const value_type &;
        using const_iterator = const value_type *;
        using iterator = const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = const_reverse_iterator;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        static constexpr size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const basic_string_view<wchar_t> &) noexcept = default
        constexpr basic_string_view(const wchar_t *__str) noexcept [[gnu::nonnull]];
        constexpr basic_string_view(const wchar_t *__str, size_type __len) noexcept : _M_len({__len}), _M_str({__str}) {
        }
        template <contiguous_iterator _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const wchar_t *, unsigned long>(const wchar_t *__first, unsigned long __last);
        basic_string_view<wchar_t> &operator=(const basic_string_view<wchar_t> &) noexcept = default
        constexpr const_iterator begin() const noexcept [[nodiscard("")]];
        constexpr const_iterator end() const noexcept [[nodiscard("")]];
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
        constexpr const_iterator cend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        constexpr size_type size() const noexcept [[nodiscard("")]];
        constexpr size_type length() const noexcept [[nodiscard("")]] {
            return this->_M_len;
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]];
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
        constexpr const_reference at(size_type __pos) const [[nodiscard("")]];
        constexpr const_reference front() const noexcept [[nodiscard("")]];
        constexpr const_reference back() const noexcept [[nodiscard("")]];
        constexpr const_pointer data() const noexcept [[nodiscard("")]] {
            return this->_M_str;
        }
        constexpr void remove_prefix(size_type __n) noexcept;
        constexpr void remove_suffix(size_type __n) noexcept;
        constexpr void swap(basic_string_view<wchar_t> &__sv) noexcept;
        constexpr size_type copy(wchar_t *__str, size_type __n, size_type __pos) const;
        constexpr basic_string_view<wchar_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
        constexpr int compare(basic_string_view<wchar_t> __str) const noexcept [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<wchar_t> __str) const [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<wchar_t> __str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
        constexpr int compare(const wchar_t *__str) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const wchar_t *__str) const [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const wchar_t *__str, size_type __n2) const [[nodiscard("")]];
        constexpr bool starts_with(basic_string_view<wchar_t> __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(wchar_t __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(const wchar_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr bool ends_with(basic_string_view<wchar_t> __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(wchar_t __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(const wchar_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find(basic_string_view<wchar_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(const wchar_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find(const wchar_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type rfind(basic_string_view<wchar_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const wchar_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const wchar_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_of(basic_string_view<wchar_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const wchar_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const wchar_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_of(basic_string_view<wchar_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const wchar_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const wchar_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_not_of(basic_string_view<wchar_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const wchar_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const wchar_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_not_of(basic_string_view<wchar_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const wchar_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const wchar_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
    private:
        static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
        size_t _M_len;
        const wchar_t *_M_str;
    };
    template<> class basic_string_view<char8_t, std::char_traits<char8_t>> {
        static_assert(!is_array_v<char8_t>);
        static_assert(is_trivial_v<char8_t> && is_standard_layout_v<char8_t>);
        static_assert(is_same_v<char8_t, typename char_traits<char8_t>::char_type>);
    public:
        using traits_type = std::char_traits<char8_t>;
        using value_type = char8_t;
        using pointer = value_type *;
        using const_pointer = const value_type *;
        using reference = value_type &;
        using const_reference = const value_type &;
        using const_iterator = const value_type *;
        using iterator = const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = const_reverse_iterator;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        static constexpr size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const basic_string_view<char8_t> &) noexcept = default
        constexpr basic_string_view(const char8_t *__str) noexcept [[gnu::nonnull]];
        constexpr basic_string_view(const char8_t *__str, size_type __len) noexcept : _M_len({__len}), _M_str({__str}) {
        }
        template <contiguous_iterator _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char8_t *, unsigned long>(const char8_t *__first, unsigned long __last);
        basic_string_view<char8_t> &operator=(const basic_string_view<char8_t> &) noexcept = default
        constexpr const_iterator begin() const noexcept [[nodiscard("")]];
        constexpr const_iterator end() const noexcept [[nodiscard("")]];
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
        constexpr const_iterator cend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        constexpr size_type size() const noexcept [[nodiscard("")]];
        constexpr size_type length() const noexcept [[nodiscard("")]] {
            return this->_M_len;
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]];
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
        constexpr const_reference at(size_type __pos) const [[nodiscard("")]];
        constexpr const_reference front() const noexcept [[nodiscard("")]];
        constexpr const_reference back() const noexcept [[nodiscard("")]];
        constexpr const_pointer data() const noexcept [[nodiscard("")]] {
            return this->_M_str;
        }
        constexpr void remove_prefix(size_type __n) noexcept;
        constexpr void remove_suffix(size_type __n) noexcept;
        constexpr void swap(basic_string_view<char8_t> &__sv) noexcept;
        constexpr size_type copy(char8_t *__str, size_type __n, size_type __pos) const;
        constexpr basic_string_view<char8_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
        constexpr int compare(basic_string_view<char8_t> __str) const noexcept [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<char8_t> __str) const [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<char8_t> __str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
        constexpr int compare(const char8_t *__str) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const char8_t *__str) const [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const char8_t *__str, size_type __n2) const [[nodiscard("")]];
        constexpr bool starts_with(basic_string_view<char8_t> __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(char8_t __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(const char8_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr bool ends_with(basic_string_view<char8_t> __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(char8_t __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(const char8_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find(basic_string_view<char8_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(const char8_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find(const char8_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type rfind(basic_string_view<char8_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const char8_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const char8_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_of(basic_string_view<char8_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const char8_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const char8_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_of(basic_string_view<char8_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const char8_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const char8_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_not_of(basic_string_view<char8_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const char8_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const char8_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_not_of(basic_string_view<char8_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const char8_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const char8_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
    private:
        static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
        size_t _M_len;
        const char8_t *_M_str;
    };
    template<> class basic_string_view<char16_t, std::char_traits<char16_t>> {
        static_assert(!is_array_v<char16_t>);
        static_assert(is_trivial_v<char16_t> && is_standard_layout_v<char16_t>);
        static_assert(is_same_v<char16_t, typename char_traits<char16_t>::char_type>);
    public:
        using traits_type = std::char_traits<char16_t>;
        using value_type = char16_t;
        using pointer = value_type *;
        using const_pointer = const value_type *;
        using reference = value_type &;
        using const_reference = const value_type &;
        using const_iterator = const value_type *;
        using iterator = const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = const_reverse_iterator;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        static constexpr size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const basic_string_view<char16_t> &) noexcept = default
        constexpr basic_string_view(const char16_t *__str) noexcept [[gnu::nonnull]];
        constexpr basic_string_view(const char16_t *__str, size_type __len) noexcept : _M_len({__len}), _M_str({__str}) {
        }
        template <contiguous_iterator _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char16_t *, unsigned long>(const char16_t *__first, unsigned long __last);
        basic_string_view<char16_t> &operator=(const basic_string_view<char16_t> &) noexcept = default
        constexpr const_iterator begin() const noexcept [[nodiscard("")]];
        constexpr const_iterator end() const noexcept [[nodiscard("")]];
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
        constexpr const_iterator cend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        constexpr size_type size() const noexcept [[nodiscard("")]];
        constexpr size_type length() const noexcept [[nodiscard("")]] {
            return this->_M_len;
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]];
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
        constexpr const_reference at(size_type __pos) const [[nodiscard("")]];
        constexpr const_reference front() const noexcept [[nodiscard("")]];
        constexpr const_reference back() const noexcept [[nodiscard("")]];
        constexpr const_pointer data() const noexcept [[nodiscard("")]] {
            return this->_M_str;
        }
        constexpr void remove_prefix(size_type __n) noexcept;
        constexpr void remove_suffix(size_type __n) noexcept;
        constexpr void swap(basic_string_view<char16_t> &__sv) noexcept;
        constexpr size_type copy(char16_t *__str, size_type __n, size_type __pos) const;
        constexpr basic_string_view<char16_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
        constexpr int compare(basic_string_view<char16_t> __str) const noexcept [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<char16_t> __str) const [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<char16_t> __str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
        constexpr int compare(const char16_t *__str) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const char16_t *__str) const [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const char16_t *__str, size_type __n2) const [[nodiscard("")]];
        constexpr bool starts_with(basic_string_view<char16_t> __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(char16_t __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(const char16_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr bool ends_with(basic_string_view<char16_t> __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(char16_t __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(const char16_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find(basic_string_view<char16_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(const char16_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find(const char16_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type rfind(basic_string_view<char16_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const char16_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const char16_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_of(basic_string_view<char16_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const char16_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const char16_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_of(basic_string_view<char16_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const char16_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const char16_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_not_of(basic_string_view<char16_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const char16_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const char16_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_not_of(basic_string_view<char16_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const char16_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const char16_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
    private:
        static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
        size_t _M_len;
        const char16_t *_M_str;
    };
    template<> class basic_string_view<char32_t, std::char_traits<char32_t>> {
        static_assert(!is_array_v<char32_t>);
        static_assert(is_trivial_v<char32_t> && is_standard_layout_v<char32_t>);
        static_assert(is_same_v<char32_t, typename char_traits<char32_t>::char_type>);
    public:
        using traits_type = std::char_traits<char32_t>;
        using value_type = char32_t;
        using pointer = value_type *;
        using const_pointer = const value_type *;
        using reference = value_type &;
        using const_reference = const value_type &;
        using const_iterator = const value_type *;
        using iterator = const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = const_reverse_iterator;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        static constexpr size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const basic_string_view<char32_t> &) noexcept = default
        constexpr basic_string_view(const char32_t *__str) noexcept [[gnu::nonnull]];
        constexpr basic_string_view(const char32_t *__str, size_type __len) noexcept : _M_len({__len}), _M_str({__str}) {
        }
        template <contiguous_iterator _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char32_t *, unsigned long>(const char32_t *__first, unsigned long __last);
        basic_string_view<char32_t> &operator=(const basic_string_view<char32_t> &) noexcept = default
        constexpr const_iterator begin() const noexcept [[nodiscard("")]];
        constexpr const_iterator end() const noexcept [[nodiscard("")]];
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
        constexpr const_iterator cend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        constexpr size_type size() const noexcept [[nodiscard("")]];
        constexpr size_type length() const noexcept [[nodiscard("")]] {
            return this->_M_len;
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]];
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
        constexpr const_reference at(size_type __pos) const [[nodiscard("")]];
        constexpr const_reference front() const noexcept [[nodiscard("")]];
        constexpr const_reference back() const noexcept [[nodiscard("")]];
        constexpr const_pointer data() const noexcept [[nodiscard("")]] {
            return this->_M_str;
        }
        constexpr void remove_prefix(size_type __n) noexcept;
        constexpr void remove_suffix(size_type __n) noexcept;
        constexpr void swap(basic_string_view<char32_t> &__sv) noexcept;
        constexpr size_type copy(char32_t *__str, size_type __n, size_type __pos) const;
        constexpr basic_string_view<char32_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
        constexpr int compare(basic_string_view<char32_t> __str) const noexcept [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<char32_t> __str) const [[nodiscard("")]];
        constexpr int compare(size_type __pos1, size_type __n1, basic_string_view<char32_t> __str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
        constexpr int compare(const char32_t *__str) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const char32_t *__str) const [[nodiscard("")]] [[gnu::nonnull]];
        constexpr int compare(size_type __pos1, size_type __n1, const char32_t *__str, size_type __n2) const [[nodiscard("")]];
        constexpr bool starts_with(basic_string_view<char32_t> __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(char32_t __x) const noexcept [[nodiscard("")]];
        constexpr bool starts_with(const char32_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr bool ends_with(basic_string_view<char32_t> __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(char32_t __x) const noexcept [[nodiscard("")]];
        constexpr bool ends_with(const char32_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find(basic_string_view<char32_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find(const char32_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find(const char32_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type rfind(basic_string_view<char32_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const char32_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type rfind(const char32_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_of(basic_string_view<char32_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const char32_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_of(const char32_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_of(basic_string_view<char32_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const char32_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_of(const char32_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_first_not_of(basic_string_view<char32_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const char32_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_first_not_of(const char32_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
        constexpr size_type find_last_not_of(basic_string_view<char32_t> __str, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const char32_t *__str, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
        constexpr size_type find_last_not_of(const char32_t *__str, size_type __pos) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
    private:
        static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
        size_t _M_len;
        const char32_t *_M_str;
    };
    template <contiguous_iterator _It, sized_sentinel_for<_It> _End> basic_string_view(_It, _End) -> basic_string_view<iter_value_t<_It>>;
    template <typename _CharT, typename _Traits> constexpr bool operator==(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept [[nodiscard("")]] {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator==(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept [[nodiscard("")]] {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr auto operator<=>(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0)) [[nodiscard("")]] {
        return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y));
    }
    template <typename _CharT, typename _Traits> constexpr auto operator<=>(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0)) [[nodiscard("")]] {
        return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, basic_string_view<_CharT, _Traits> __str) {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    template<> inline basic_ostream<char, char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, char_traits<char>> &__os, basic_string_view<char, char_traits<char>> __str)    using string_view = basic_string_view<char>;
    using wstring_view = basic_string_view<wchar_t>;
    using u8string_view = basic_string_view<char8_t>;
    using u16string_view = basic_string_view<char16_t>;
    using u32string_view = basic_string_view<char32_t>;
    template <typename _Tp> struct hash;
    template<> struct hash<string_view> : public __hash_base<size_t, string_view> {
        size_t operator()(const string_view &__str) const noexcept [[nodiscard("")]] {
            return std::_Hash_impl::hash(__str.data(), __str.length());
        }
    };
    template<> struct __is_fast_hash<hash<string_view>> : std::false_type {
    };
    template<> struct hash<wstring_view> : public __hash_base<size_t, wstring_view> {
        size_t operator()(const wstring_view &__s) const noexcept [[nodiscard("")]] {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
        }
    };
    template<> struct __is_fast_hash<hash<wstring_view>> : std::false_type {
    };
    template<> struct hash<u8string_view> : public __hash_base<size_t, u8string_view> {
        size_t operator()(const u8string_view &__str) const noexcept [[nodiscard("")]] {
            return std::_Hash_impl::hash(__str.data(), __str.length());
        }
    };
    template<> struct __is_fast_hash<hash<u8string_view>> : std::false_type {
    };
    template<> struct hash<u16string_view> : public __hash_base<size_t, u16string_view> {
        size_t operator()(const u16string_view &__s) const noexcept [[nodiscard("")]] {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
        }
    };
    template<> struct __is_fast_hash<hash<u16string_view>> : std::false_type {
    };
    template<> struct hash<u32string_view> : public __hash_base<size_t, u32string_view> {
        size_t operator()(const u32string_view &__s) const noexcept [[nodiscard("")]] {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
        }
    };
    template<> struct __is_fast_hash<hash<u32string_view>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_view_literals {
            inline constexpr basic_string_view<char> operator""sv(const char *__str, size_t __len) noexcept {
                return basic_string_view<char>{__str, __len};
            }
            inline constexpr basic_string_view<wchar_t> operator""sv(const wchar_t *__str, size_t __len) noexcept {
                return basic_string_view<wchar_t>{__str, __len};
            }
            inline constexpr basic_string_view<char8_t> operator""sv(const char8_t *__str, size_t __len) noexcept {
                return basic_string_view<char8_t>{__str, __len};
            }
            inline constexpr basic_string_view<char16_t> operator""sv(const char16_t *__str, size_t __len) noexcept {
                return basic_string_view<char16_t>{__str, __len};
            }
            inline constexpr basic_string_view<char32_t> operator""sv(const char32_t *__str, size_t __len) noexcept {
                return basic_string_view<char32_t>{__str, __len};
            }
        }
    }
    namespace ranges {
        constexpr bool enable_borrowed_range = true;
        constexpr bool enable_view = true;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find(const _CharT *__str, size_type __pos, size_type __n) const noexcept {
        ;
        if (__n == 0)
            return __pos <= this->_M_len ? __pos : npos;
        if (__pos >= this->_M_len)
            return npos;
        const _CharT __elem0 = __str[0];
        const _CharT *__first = this->_M_str + __pos;
        const _CharT *const __last = this->_M_str + this->_M_len;
        size_type __len = this->_M_len - __pos;
        while (__len >= __n)
            {
                __first = traits_type::find(__first, __len - __n + 1, __elem0);
                if (!__first)
                    return npos;
                if (traits_type::compare(__first, __str, __n) == 0)
                    return __first - this->_M_str;
                __len = __last - ++__first;
            }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find(_CharT __c, size_type __pos = 0) const noexcept {
        size_type __ret = npos;
        if (__pos < this->_M_len) {
            const size_type __n = this->_M_len - __pos;
            const _CharT *__p = traits_type::find(this->_M_str + __pos, __n, __c);
            if (__p)
                __ret = __p - this->_M_str;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::rfind(const _CharT *__str, size_type __pos, size_type __n) const noexcept {
        ;
        if (__n <= this->_M_len) {
            __pos = std::min(size_type(this->_M_len - __n), __pos);
            do {
                if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::rfind(_CharT __c, size_type __pos = npos) const noexcept {
        size_type __size = this->_M_len;
        if (__size > 0) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(this->_M_str[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_of(const _CharT *__str, size_type __pos, size_type __n) const noexcept {
        ;
        for (; __n && __pos < this->_M_len; ++__pos) {
            const _CharT *__p = traits_type::find(__str, __n, this->_M_str[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_of(const _CharT *__str, size_type __pos, size_type __n) const noexcept {
        ;
        size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__str, __n, this->_M_str[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_not_of(const _CharT *__str, size_type __pos, size_type __n) const noexcept {
        ;
        for (; __pos < this->_M_len; ++__pos)
            if (!traits_type::find(__str, __n, this->_M_str[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept {
        for (; __pos < this->_M_len; ++__pos)
            if (!traits_type::eq(this->_M_str[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_not_of(const _CharT *__str, size_type __pos, size_type __n) const noexcept {
        ;
        size_type __size = this->_M_len;
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__str, __n, this->_M_str[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept {
        size_type __size = this->_M_len;
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(this->_M_str[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
}
namespace std {
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef _Traits traits_type;
            typedef typename _Traits::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<_Traits, char_traits<_CharT>>)
                    if (std::__is_constant_evaluated())
                        for (size_type __i = 0; __i < __n; ++__i)
                            std::construct_at(__builtin_addressof(__p[__i]));
                return __p;
            }
            typedef basic_string_view<_CharT, _Traits> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<_CharT, _Traits, _Alloc> *>>, __not_<is_convertible<const _Tp &, const _CharT *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept {
                return __svt;
            }
            struct __sv_wrapper {
                constexpr explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) {
                }
                __sv_type _M_sv;
            };
            constexpr explicit basic_string<_CharT, _Traits, _Alloc>(__sv_wrapper __svw, const _Alloc &__a) : basic_string<_CharT, _Traits, _Alloc>(__svw._M_sv.data(), __svw._M_sv.size(), __a) {
            }
            struct _Alloc_hider : allocator_type {
                constexpr _Alloc_hider(pointer __dat, const _Alloc &__a) : allocator_type(__a), _M_p(__dat) {
                }
                constexpr _Alloc_hider(pointer __dat, _Alloc &&__a = _Alloc()) : allocator_type(std::move(__a)), _M_p(__dat) {
                }
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(_CharT)
            };
            union {
                _CharT _M_local_buf[_S_local_capacity + 1];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(_M_data()[__n], _CharT());
            }
            constexpr bool _M_is_local() const {
                if (_M_data() == _M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer _M_create(size_type &, size_type);
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            constexpr void _M_construct(size_type __req, _CharT __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = _CharT();
                return _M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const _CharT *__s) const noexcept {
                return (less<const _CharT *>()(__s, _M_data()) || less<const _CharT *>()(_M_data() + this->size(), __s));
            }
            static constexpr void _S_copy(_CharT *__d, const _CharT *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(_CharT *__d, const _CharT *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static constexpr void _S_assign(_CharT *__d, size_type __n, _CharT __c) {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }
            template <class _Iterator> static constexpr void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2) {
                for (; __k1 != __k2; ++__k1 , (void)++__p)
                    traits_type::assign(*__p, *__k1);
            }
            static constexpr void _S_copy_chars(_CharT *__p, iterator __k1, iterator __k2) noexcept {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static constexpr void _S_copy_chars(_CharT *__p, const_iterator __k1, const_iterator __k2) noexcept {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static constexpr void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept {
                const difference_type __d = difference_type(__n1 - __n2);
                if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                    return __gnu_cxx::__numeric_traits<int>::__max;
                else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                    return __gnu_cxx::__numeric_traits<int>::__min;
                else
                    return int(__d);
            }
            constexpr void _M_assign(const basic_string<_CharT, _Traits, _Alloc> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const _CharT *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string<_CharT, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible<_Alloc>::value) : _M_dataplus(_M_local_data()) {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr explicit basic_string<_CharT, _Traits, _Alloc>(const _Alloc &__a) noexcept : _M_dataplus(_M_local_data(), __a) {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str) : _M_dataplus(_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator())) {
                _M_construct(__str._M_data(), __str._M_data() + __str.length(), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, npos), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, size_type __n) : _M_dataplus(_M_local_data()) {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, size_type __n, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a) {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, size_type __n, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                _M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<_Alloc>> constexpr basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                if (__s == 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                const _CharT *__end = __s + traits_type::length(__s);
                _M_construct(__s, __end, forward_iterator_tag());
            }
            template <typename = _RequireAllocator<_Alloc>> constexpr basic_string<_CharT, _Traits, _Alloc>(size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                _M_construct(__n, __c);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator())) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    _M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(initializer_list<_CharT> __l, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) {
                _M_construct(__l.begin(), __l.end(), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a) {
                _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()) : _M_dataplus(_M_local_data(), __a) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                    this->_M_length(__str.length());
                    __str._M_set_length(0);
                } else if (_Alloc_traits::_S_always_equal() || __str.get_allocator() == __a) {
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    __str._M_data(__str._M_local_buf);
                    __str._M_set_length(0);
                } else
                    _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
            }
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<_CharT, _Traits, _Alloc>(_InputIterator __beg, _InputIterator __end, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a), _M_string_length(0) {
                _M_construct(__beg, __end, std::__iterator_category(__beg));
            }
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string<_CharT, _Traits, _Alloc>(const _Tp &__t, size_type __pos, size_type __n, const _Alloc &__a = _Alloc()) : basic_string<_CharT, _Traits, _Alloc>(_S_to_string_view(__t).substr(__pos, __n), __a) {
            }
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string<_CharT, _Traits, _Alloc>(const _Tp &__t, const _Alloc &__a = _Alloc()) : basic_string<_CharT, _Traits, _Alloc>(__sv_wrapper(_S_to_string_view(__t)), __a) {
            }
            constexpr ~basic_string<_CharT, _Traits, _Alloc>() {
                this->_M_dispose();
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->assign(__str);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(const _CharT *__s) {
                return this->assign(__s);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(_CharT __c) {
                this->assign(1, __c);
                return *this;
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) {
                const bool __equal_allocs = _Alloc_traits::_S_always_equal() || _M_get_allocator() == __str._M_get_allocator();
                if (!this->_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign() && !__equal_allocs) {
                    this->_M_destroy(this->_M_allocated_capacity);
                    _M_data(_M_local_data());
                    this->_M_set_length(0);
                }
                std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
                if (__str._M_is_local()) {
                    if (__builtin_expect(std::__addressof(__str) != this, true)) {
                        if (__str.size())
                            this->_S_copy(_M_data(), __str._M_data(), __str.size());
                        this->_M_set_length(__str.size());
                    }
                } else if (_Alloc_traits::_S_propagate_on_move_assign() || __equal_allocs) {
                    pointer __data = nullptr;
                    size_type __capacity;
                    if (!this->_M_is_local()) {
                        if (__equal_allocs) {
                            __data = _M_data();
                            __capacity = this->_M_allocated_capacity;
                        } else
                            this->_M_destroy(this->_M_allocated_capacity);
                    }
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    if (__data) {
                        __str._M_data(__data);
                        __str._M_capacity(__capacity);
                    } else
                        __str._M_data(__str._M_local_buf);
                } else
                    assign(__str);
                __str.clear();
                return *this;
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(initializer_list<_CharT> __l) {
                this->assign(__l.begin(), __l.size());
                return *this;
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> operator=(const _Tp &__svt) {
                return this->assign(__svt);
            }
            constexpr operator __sv_type() const noexcept {
                return __sv_type(data(), this->size());
            }
            constexpr iterator begin() noexcept [[nodiscard("")]] {
                return iterator(_M_data());
            }
            constexpr const_iterator begin() const noexcept [[nodiscard("")]] {
                return const_iterator(_M_data());
            }
            constexpr iterator end() noexcept [[nodiscard("")]] {
                return iterator(_M_data() + this->size());
            }
            constexpr const_iterator end() const noexcept [[nodiscard("")]] {
                return const_iterator(_M_data() + this->size());
            }
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]] {
                return reverse_iterator(this->end());
            }
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]] {
                return const_reverse_iterator(this->end());
            }
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]] {
                return reverse_iterator(this->begin());
            }
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]] {
                return const_reverse_iterator(this->begin());
            }
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]] {
                return const_iterator(this->_M_data());
            }
            constexpr const_iterator cend() const noexcept [[nodiscard("")]] {
                return const_iterator(this->_M_data() + this->size());
            }
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]] {
                return const_reverse_iterator(this->end());
            }
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]] {
                return const_reverse_iterator(this->begin());
            }
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]] {
                return this->_M_string_length;
            }
            constexpr size_type length() const noexcept [[nodiscard("")]] {
                return this->_M_string_length;
            }
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, _CharT __c);
            constexpr void resize(size_type __n) {
                this->resize(__n, _CharT());
            }
            constexpr void shrink_to_fit() noexcept {
                reserve();
            }
            constexpr size_type capacity() const noexcept [[nodiscard("")]] {
                return this->_M_is_local() ? size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept {
                this->_M_set_length(0);
            }
            constexpr bool empty() const noexcept [[nodiscard("")]] {
                return this->size() == 0;
            }
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]] {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                return _M_data()[__pos];
            }
            constexpr reference operator[](size_type __pos) [[nodiscard("")]] {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                ;
                return _M_data()[__pos];
            }
            constexpr const_reference at(size_type __n) const [[nodiscard("")]] {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            constexpr reference at(size_type __n) [[nodiscard("")]] {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            constexpr reference front() noexcept [[nodiscard("")]] {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](0);
            }
            constexpr const_reference front() const noexcept [[nodiscard("")]] {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](0);
            }
            constexpr reference back() noexcept [[nodiscard("")]] {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](this->size() - 1);
            }
            constexpr const_reference back() const noexcept [[nodiscard("")]] {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](this->size() - 1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator+=(const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->append(__str);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator+=(const _CharT *__s) {
                return this->append(__s);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator+=(_CharT __c) {
                this->push_back(__c);
                return *this;
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator+=(initializer_list<_CharT> __l) {
                return this->append(__l.begin(), __l.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> operator+=(const _Tp &__svt) {
                return this->append(__svt);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->append(__str._M_data(), __str.size());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, size_type __n = npos) {
                return this->append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, size_type __n) {
                ;
                this->_M_check_length(size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s) {
                ;
                const size_type __n = traits_type::length(__s);
                this->_M_check_length(size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(size_type __n, _CharT __c) {
                return this->_M_replace_aux(this->size(), size_type(0), __n, __c);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(initializer_list<_CharT> __l) {
                return this->append(__l.begin(), __l.size());
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last) {
                return this->replace(end(), end(), __first, __last);
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> append(const _Tp &__svt) {
                __sv_type __sv = __svt;
                return this->append(__sv.data(), __sv.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> append(const _Tp &__svt, size_type __pos, size_type __n = npos) {
                __sv_type __sv = __svt;
                return this->_M_append(__sv.data() + std::__sv_check(__sv.size(), __pos, "basic_string::append"), std::__sv_limit(__sv.size(), __pos, __n));
            }
            constexpr void push_back(_CharT __c) {
                const size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, size_type(0), 0, size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str) {
                if (_Alloc_traits::_S_propagate_on_copy_assign()) {
                    if (!_Alloc_traits::_S_always_equal() && !this->_M_is_local() && _M_get_allocator() != __str._M_get_allocator()) {
                        if (__str.size() <= _S_local_capacity) {
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(this->_M_use_local_data());
                            this->_M_set_length(0);
                        } else {
                            const auto __len = __str.size();
                            auto __alloc = __str._M_get_allocator();
                            auto __ptr = _S_allocate(__alloc, __len + 1);
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(__ptr);
                            this->_M_capacity(__len);
                            this->_M_set_length(__len);
                        }
                    }
                    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
                }
                this->_M_assign(__str);
                return *this;
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) {
                return *this = std::move(__str);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos, size_type __n = npos) {
                return this->_M_replace(size_type(0), this->size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, size_type __n) {
                ;
                return this->_M_replace(size_type(0), this->size(), __s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s) {
                ;
                return this->_M_replace(size_type(0), this->size(), __s, traits_type::length(__s));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(size_type __n, _CharT __c) {
                return this->_M_replace_aux(size_type(0), this->size(), __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last) {
                return this->replace(begin(), end(), __first, __last);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(initializer_list<_CharT> __l) {
                return this->assign(__l.begin(), __l.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> assign(const _Tp &__svt) {
                __sv_type __sv = __svt;
                return this->assign(__sv.data(), __sv.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> assign(const _Tp &__svt, size_type __pos, size_type __n = npos) {
                __sv_type __sv = __svt;
                return this->_M_replace(size_type(0), this->size(), __sv.data() + std::__sv_check(__sv.size(), __pos, "basic_string::assign"), std::__sv_limit(__sv.size(), __pos, __n));
            }
            constexpr iterator insert(const_iterator __p, size_type __n, _CharT __c) {
                ;
                const size_type __pos = __p - begin();
                this->replace(__p, __p, __n, __c);
                return iterator(this->_M_data() + __pos);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end) {
                ;
                const size_type __pos = __p - begin();
                this->replace(__p, __p, __beg, __end);
                return iterator(this->_M_data() + __pos);
            }
            constexpr iterator insert(const_iterator __p, initializer_list<_CharT> __l) {
                return this->insert(__p, __l.begin(), __l.end());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->replace(__pos1, size_type(0), __str._M_data(), __str.size());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos2, size_type __n = npos) {
                return this->replace(__pos1, size_type(0), __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos, const _CharT *__s, size_type __n) {
                return this->replace(__pos, size_type(0), __s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos, const _CharT *__s) {
                ;
                return this->replace(__pos, size_type(0), __s, traits_type::length(__s));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(size_type __pos, size_type __n, _CharT __c) {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::insert"), size_type(0), __n, __c);
            }
            constexpr iterator insert(__const_iterator __p, _CharT __c) {
                ;
                const size_type __pos = __p - begin();
                this->_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                return iterator(_M_data() + __pos);
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> insert(size_type __pos, const _Tp &__svt) {
                __sv_type __sv = __svt;
                return this->insert(__pos, __sv.data(), __sv.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n = npos) {
                __sv_type __sv = __svt;
                return this->replace(__pos1, size_type(0), __sv.data() + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"), std::__sv_limit(__sv.size(), __pos2, __n));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &erase(size_type __pos = 0, size_type __n = npos) {
                this->_M_check(__pos, "basic_string::erase");
                if (__n == npos)
                    this->_M_set_length(__pos);
                else if (__n != 0)
                    this->_M_erase(__pos, this->_M_limit(__pos, __n));
                return *this;
            }
            constexpr iterator erase(__const_iterator __position) {
                ;
                const size_type __pos = __position - begin();
                this->_M_erase(__pos, size_type(1));
                return iterator(_M_data() + __pos);
            }
            constexpr iterator erase(__const_iterator __first, __const_iterator __last) {
                ;
                const size_type __pos = __first - begin();
                if (__last == end())
                    this->_M_set_length(__pos);
                else
                    this->_M_erase(__pos, __last - __first);
                return iterator(this->_M_data() + __pos);
            }
            constexpr void pop_back() noexcept {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                this->_M_erase(this->size() - 1, 1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos, size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->replace(__pos, __n, __str._M_data(), __str.size());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos2, size_type __n2 = npos) {
                return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos, size_type __n1, const _CharT *__s, size_type __n2) {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos, size_type __n1, const _CharT *__s) {
                ;
                return this->replace(__pos, __n1, __s, traits_type::length(__s));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c) {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __n2, __c);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<_CharT, _Traits, _Alloc> &__str) {
                return this->replace(__i1, __i2, __str._M_data(), __str.size());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__s, size_type __n) {
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__s) {
                ;
                return this->replace(__i1, __i2, __s, traits_type::length(__s));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, _CharT __c) {
                ;
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<_CharT, _Traits, _Alloc> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2) {
                ;
                ;
                return this->_M_replace_dispatch(__i1, __i2, __k1, __k2, std::__false_type());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, _CharT *__k1, _CharT *__k2) {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__k1, const _CharT *__k2) {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2) {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2) {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(const_iterator __i1, const_iterator __i2, initializer_list<_CharT> __l) {
                return this->replace(__i1, __i2, __l.begin(), __l.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(size_type __pos, size_type __n, const _Tp &__svt) {
                __sv_type __sv = __svt;
                return this->replace(__pos, __n, __sv.data(), __sv.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2 = npos) {
                __sv_type __sv = __svt;
                return this->replace(__pos1, __n1, __sv.data() + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"), std::__sv_limit(__sv.size(), __pos2, __n2));
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt) {
                __sv_type __sv = __svt;
                return this->replace(__i1 - begin(), __i2 - __i1, __sv);
            }
        private:
            template <class _Integer> constexpr basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type) {
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);
            }
            template <class _InputIterator> constexpr basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c);
            void _M_replace_cold(pointer __p, size_type __len1, const _CharT *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<_CharT, _Traits, _Alloc> &_M_replace(size_type __pos, size_type __len1, const _CharT *__s, const size_type __len2);
            constexpr basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, size_type __n);
        public:
            constexpr size_type copy(_CharT *__s, size_type __n, size_type __pos = 0) const;
            constexpr void swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept;
            constexpr const _CharT *c_str() const noexcept [[nodiscard("")]] {
                return _M_data();
            }
            constexpr const _CharT *data() const noexcept [[nodiscard("")]] {
                return _M_data();
            }
            constexpr _CharT *data() noexcept [[nodiscard("")]] {
                return _M_data();
            }
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]] {
                return _M_get_allocator();
            }
            constexpr size_type find(const _CharT *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = 0) const noexcept [[nodiscard("")]] {
                return this->find(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                return this->find(__sv.data(), __pos, __sv.size());
            }
            constexpr size_type find(const _CharT *__s, size_type __pos = 0) const noexcept [[nodiscard("")]] {
                ;
                return this->find(__s, __pos, traits_type::length(__s));
            }
            constexpr size_type find(_CharT __c, size_type __pos = 0) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = npos) const noexcept [[nodiscard("")]] {
                return this->rfind(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                return this->rfind(__sv.data(), __pos, __sv.size());
            }
            constexpr size_type rfind(const _CharT *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const _CharT *__s, size_type __pos = npos) const [[nodiscard("")]] {
                ;
                return this->rfind(__s, __pos, traits_type::length(__s));
            }
            constexpr size_type rfind(_CharT __c, size_type __pos = npos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = 0) const noexcept [[nodiscard("")]] {
                return this->find_first_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                return this->find_first_of(__sv.data(), __pos, __sv.size());
            }
            constexpr size_type find_first_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const _CharT *__s, size_type __pos = 0) const noexcept [[nodiscard("")]] {
                ;
                return this->find_first_of(__s, __pos, traits_type::length(__s));
            }
            constexpr size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept [[nodiscard("")]] {
                return this->find(__c, __pos);
            }
            constexpr size_type find_last_of(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = npos) const noexcept [[nodiscard("")]] {
                return this->find_last_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                return this->find_last_of(__sv.data(), __pos, __sv.size());
            }
            constexpr size_type find_last_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const _CharT *__s, size_type __pos = npos) const noexcept [[nodiscard("")]] {
                ;
                return this->find_last_of(__s, __pos, traits_type::length(__s));
            }
            constexpr size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept [[nodiscard("")]] {
                return this->rfind(__c, __pos);
            }
            constexpr size_type find_first_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = 0) const noexcept [[nodiscard("")]] {
                return this->find_first_not_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                return this->find_first_not_of(__sv.data(), __pos, __sv.size());
            }
            constexpr size_type find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const _CharT *__s, size_type __pos = 0) const noexcept [[nodiscard("")]] {
                ;
                return this->find_first_not_of(__s, __pos, traits_type::length(__s));
            }
            constexpr size_type find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos = npos) const noexcept [[nodiscard("")]] {
                return this->find_last_not_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                return this->find_last_not_of(__sv.data(), __pos, __sv.size());
            }
            constexpr size_type find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const _CharT *__s, size_type __pos = npos) const noexcept [[nodiscard("")]] {
                ;
                return this->find_last_not_of(__s, __pos, traits_type::length(__s));
            }
            constexpr size_type find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept [[nodiscard("")]];
            constexpr basic_string<_CharT, _Traits, _Alloc> substr(size_type __pos = 0, size_type __n = npos) const [[nodiscard("")]] {
                return basic_string<_CharT, _Traits, _Alloc>(*this, this->_M_check(__pos, "basic_string::substr"), __n);
            }
            constexpr int compare(const basic_string<_CharT, _Traits, _Alloc> &__str) const [[nodiscard("")]] {
                const size_type __size = this->size();
                const size_type __osize = __str.size();
                const size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __str.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                const size_type __size = this->size();
                const size_type __osize = __sv.size();
                const size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __sv.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                return __sv_type(*this).substr(__pos, __n).compare(__sv);
            }
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2 = npos) const noexcept(is_same<_Tp, __sv_type>::value) [[nodiscard("")]] {
                __sv_type __sv = __svt;
                return __sv_type(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
            }
            constexpr int compare(size_type __pos, size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const [[nodiscard("")]] {
                this->_M_check(__pos, "basic_string::compare");
                __n = this->_M_limit(__pos, __n);
                const size_type __osize = __str.size();
                const size_type __len = std::min(__n, __osize);
                int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
                if (!__r)
                    __r = _S_compare(__n, __osize);
                return __r;
            }
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, size_type __pos2, size_type __n2 = npos) const [[nodiscard("")]] {
                this->_M_check(__pos1, "basic_string::compare");
                __str._M_check(__pos2, "basic_string::compare");
                __n1 = this->_M_limit(__pos1, __n1);
                __n2 = __str._M_limit(__pos2, __n2);
                const size_type __len = std::min(__n1, __n2);
                int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len);
                if (!__r)
                    __r = _S_compare(__n1, __n2);
                return __r;
            }
            constexpr int compare(const _CharT *__s) const noexcept [[nodiscard("")]] {
                ;
                const size_type __size = this->size();
                const size_type __osize = traits_type::length(__s);
                const size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __s, __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            constexpr int compare(size_type __pos, size_type __n1, const _CharT *__s) const [[nodiscard("")]] {
                ;
                this->_M_check(__pos, "basic_string::compare");
                __n1 = this->_M_limit(__pos, __n1);
                const size_type __osize = traits_type::length(__s);
                const size_type __len = std::min(__n1, __osize);
                int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                if (!__r)
                    __r = _S_compare(__n1, __osize);
                return __r;
            }
            constexpr int compare(size_type __pos, size_type __n1, const _CharT *__s, size_type __n2) const [[nodiscard("")]] {
                ;
                this->_M_check(__pos, "basic_string::compare");
                __n1 = this->_M_limit(__pos, __n1);
                const size_type __len = std::min(__n1, __n2);
                int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                if (!__r)
                    __r = _S_compare(__n1, __n2);
                return __r;
            }
            constexpr bool starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept [[nodiscard("")]] {
                return __sv_type(this->data(), this->size()).starts_with(__x);
            }
            constexpr bool starts_with(_CharT __x) const noexcept [[nodiscard("")]] {
                return __sv_type(this->data(), this->size()).starts_with(__x);
            }
            constexpr bool starts_with(const _CharT *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
                return __sv_type(this->data(), this->size()).starts_with(__x);
            }
            constexpr bool ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept [[nodiscard("")]] {
                return __sv_type(this->data(), this->size()).ends_with(__x);
            }
            constexpr bool ends_with(_CharT __x) const noexcept [[nodiscard("")]] {
                return __sv_type(this->data(), this->size()).ends_with(__x);
            }
            constexpr bool ends_with(const _CharT *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]] {
                return __sv_type(this->data(), this->size()).ends_with(__x);
            }
            friend template <typename, typename, typename> class basic_stringbuf;
        };
        template<> class basic_string<char, std::char_traits<char>, std::allocator<char>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char>>::rebind<char>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char> traits_type;
            typedef typename char_traits<char>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char, char_traits<char>, allocator<char>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char, char_traits<char>, allocator<char>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<char>, char_traits<char>>)
                    ;
                return __p;
            }
            typedef basic_string_view<char, char_traits<char>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const _Tp &, const char *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<char> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char)
            };
            union {
                char _M_local_buf[16];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<char, char_traits<char>, allocator<char>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char *>(const char *__beg, const char *__end, std::input_iterator_tag);
            template<> constexpr void _M_construct<char *>(char *__beg, char *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<const char *>(const char *__beg, const char *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            template<> constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<char *>(char *__beg, char *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_construct(size_type __n, char __c) {
                if (__n > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__n, size_type(0)));
                    this->_M_capacity(__n);
                } else
                    this->_M_use_local_data();
                if (__n)
                    this->_S_assign(this->_M_data(), __n, __c);
                this->_M_set_length(__n);
            }
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = char();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const char *__s) const noexcept {
                return (less<const char *>()(__s, this->_M_data()) || less<const char *>()(this->_M_data() + this->size(), __s));
            }
            static constexpr void _S_copy(char *__d, const char *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char *__d, const char *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static constexpr void _S_assign(char *__d, size_type __n, char __c) {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }
            template <class _Iterator> static constexpr void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<const char *>(char *__p, const char *__k1, const char *__k2);
            template<> static constexpr void _S_copy_chars<char *>(char *__p, char *__k1, char *__k2);
            static constexpr void _S_copy_chars(char *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char *__p, char *__k1, char *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(char *__p, const char *__k1, const char *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<char> &);
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_mutate(size_type __pos, size_type __len1, const char *__s, size_type __len2) {
                const size_type __how_much = this->length() - __pos - __len1;
                size_type __new_capacity = this->length() + __len2 - __len1;
                pointer __r = this->_M_create(__new_capacity, this->capacity());
                if (__pos)
                    this->_S_copy(__r, this->_M_data(), __pos);
                if (__s && __len2)
                    this->_S_copy(__r + __pos, __s, __len2);
                if (__how_much)
                    this->_S_copy(__r + __pos + __len2, this->_M_data() + __pos + __len1, __how_much);
                this->_M_dispose();
                this->_M_data(__r);
                this->_M_capacity(__new_capacity);
            }
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::value) : _M_dataplus(this->_M_local_data()) {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr explicit basic_string(const std::allocator<char> &__a) noexcept : _M_dataplus(this->_M_local_data(), __a) {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr basic_string(const basic_string<char> &__str);
            constexpr basic_string(const basic_string<char> &__str, size_type __pos, const std::allocator<char> &__a);
            constexpr basic_string(const basic_string<char> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<char> &__str, size_type __pos, size_type __n, const std::allocator<char> &__a);
            constexpr basic_string(const char *__s, size_type __n, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<char>>> constexpr basic_string(const char *__s, const std::allocator<char> &__a);
            template<> constexpr basic_string<std::allocator<char>>(const char *__s, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                const char *__end = __s + traits_type::length(__s);
                this->_M_construct(__s, __end, forward_iterator_tag());
            }
;
            template <typename = _RequireAllocator<allocator<char>>> constexpr basic_string(size_type __n, char __c, const std::allocator<char> &__a);
            template<> constexpr basic_string<std::allocator<char>>(size_type __n, char __c, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a) {
                this->_M_construct(__n, __c);
            }
;
            constexpr basic_string(basic_string<char> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator())) {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            constexpr basic_string(initializer_list<char> __l, const std::allocator<char> &__a);
            constexpr basic_string(const basic_string<char> &__str, const std::allocator<char> &__a);
            constexpr basic_string(basic_string<char> &&__str, const std::allocator<char> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
            template<> constexpr basic_string<char *, void>(char *__beg, char *__end, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a), _M_string_length(0) {
                this->_M_construct(__beg, __end, std::__iterator_category(__beg));
            }
;
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<char> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char> &__a);
            constexpr ~basic_string<char>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<char> &operator=(const basic_string<char> &__str);
            constexpr basic_string<char> &operator=(const char *__s);
            constexpr basic_string<char> &operator=(char __c);
            constexpr basic_string<char> &operator=(basic_string<char> &&__str);
            constexpr basic_string<char> &operator=(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]] {
                return this->_M_string_length;
            }
            constexpr size_type length() const noexcept [[nodiscard("")]] {
                return this->_M_string_length;
            }
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, char __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]] {
                return this->_M_is_local() ? size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::reserve(size_type __res) {
                const size_type __capacity = this->capacity();
                if (__res <= __capacity)
                    return;
                pointer __tmp = this->_M_create(__res, __capacity);
                this->_S_copy(__tmp, this->_M_data(), this->length() + 1);
                this->_M_dispose();
                this->_M_data(__tmp);
                this->_M_capacity(__res);
            }
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept {
                this->_M_set_length(0);
            }
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]] {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                ;
                return this->_M_data()[__pos];
            }
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<char> &operator+=(const basic_string<char> &__str);
            constexpr basic_string<char> &operator+=(const char *__s);
            constexpr basic_string<char> &operator+=(char __c) {
                this->push_back(__c);
                return *this;
            }
            constexpr basic_string<char> &operator+=(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<char> &append(const basic_string<char> &__str) {
                return this->append(__str._M_data(), __str.size());
            }
            constexpr basic_string<char> &append(const basic_string<char> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char> &append(const char *__s, size_type __n) {
                ;
                this->_M_check_length(size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr basic_string<char> &append(const char *__s) {
                ;
                const size_type __n = traits_type::length(__s);
                this->_M_check_length(size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr basic_string<char> &append(size_type __n, char __c);
            constexpr basic_string<char> &append(initializer_list<char> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(char __c) {
                const size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, size_type(0), 0, size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            constexpr basic_string<char> &assign(const basic_string<char> &__str);
            constexpr basic_string<char> &assign(basic_string<char> &&__str);
            constexpr basic_string<char> &assign(const basic_string<char> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char> &assign(const char *__s, size_type __n);
            constexpr basic_string<char> &assign(const char *__s);
            constexpr basic_string<char> &assign(size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<char> &assign(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<char> __l);
            constexpr basic_string<char> &insert(size_type __pos1, const basic_string<char> &__str) {
                return this->replace(__pos1, size_type(0), __str._M_data(), __str.size());
            }
            constexpr basic_string<char> &insert(size_type __pos1, const basic_string<char> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<char> &insert(size_type __pos, const char *__s, size_type __n);
            constexpr basic_string<char> &insert(size_type __pos, const char *__s) {
                ;
                return this->replace(__pos, size_type(0), __s, traits_type::length(__s));
            }
            constexpr basic_string<char> &insert(size_type __pos, size_type __n, char __c);
            constexpr iterator insert(__const_iterator __p, char __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<char> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<char> &replace(size_type __pos, size_type __n, const basic_string<char> &__str);
            constexpr basic_string<char> &replace(size_type __pos1, size_type __n1, const basic_string<char> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s, size_type __n2) {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            constexpr basic_string<char> &replace(size_type __pos, size_type __n1, const char *__s);
            constexpr basic_string<char> &replace(size_type __pos, size_type __n1, size_type __n2, char __c);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<char> &__str);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s, size_type __n);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__s);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, char *__k1, char *__k2);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const char *__k1, const char *__k2);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<char> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<char> &replace(const_iterator __i1, const_iterator __i2, initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char, char_traits<char>, allocator<char>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<char> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<char> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char __c);
            void _M_replace_cold(pointer __p, size_type __len1, const char *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<char> &basic_string<char, char_traits<char>, allocator<char>>::_M_replace(size_type __pos, size_type __len1, const char *__s, const size_type __len2) {
                this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
                const size_type __old_size = this->size();
                const size_type __new_size = __old_size + __len2 - __len1;
                if (__new_size <= this->capacity()) {
                    pointer __p = this->_M_data() + __pos;
                    const size_type __how_much = __old_size - __pos - __len1;
                    if (std::is_constant_evaluated()) {
                        auto __newp = _S_allocate(this->_M_get_allocator(), __new_size);
                        _S_copy(__newp, this->_M_data(), __pos);
                        _S_copy(__newp + __pos, __s, __len2);
                        _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
                        _S_copy(this->_M_data(), __newp, __new_size);
                        this->_M_get_allocator().deallocate(__newp, __new_size);
                    } else if (__builtin_expect(this->_M_disjunct(__s), true)) {
                        if (__how_much && __len1 != __len2)
                            this->_S_move(__p + __len2, __p + __len1, __how_much);
                        if (__len2)
                            this->_S_copy(__p, __s, __len2);
                    } else
                        this->_M_replace_cold(__p, __len1, __s, __len2, __how_much);
                } else
                    this->_M_mutate(__pos, __len1, __s, __len2);
                this->_M_set_length(__new_size);
                return *this;
            }
            constexpr basic_string<char> &basic_string<char, char_traits<char>, allocator<char>>::_M_append(const char *__s, size_type __n) {
                const size_type __len = __n + this->size();
                if (__len <= this->capacity()) {
                    if (__n)
                        this->_S_copy(this->_M_data() + this->size(), __s, __n);
                } else
                    this->_M_mutate(this->size(), size_type(0), __s, __n);
                this->_M_set_length(__len);
                return *this;
            }
        public:
            constexpr size_type basic_string<char, char_traits<char>, allocator<char>>::copy(char *__s, size_type __n, size_type __pos = 0) const {
                this->_M_check(__pos, "basic_string::copy");
                __n = this->_M_limit(__pos, __n);
                ;
                if (__n)
                    _S_copy(__s, this->_M_data() + __pos, __n);
                return __n;
            }
            constexpr void swap(basic_string<char> &__s) noexcept;
            constexpr const char *c_str() const noexcept [[nodiscard("")]] {
                return this->_M_data();
            }
            constexpr const char *data() const noexcept [[nodiscard("")]];
            constexpr char *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]] {
                return this->_M_get_allocator();
            }
            constexpr size_type find(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const char *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<char> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(char __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<char> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<char> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<char> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<char> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const char *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<char, char_traits<char>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(char __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const char *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<char, char_traits<char>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(char __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const char *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
        template<> class basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t>>::rebind<wchar_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef typename char_traits<wchar_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<wchar_t>, char_traits<wchar_t>>)
                    ;
                return __p;
            }
            typedef basic_string_view<wchar_t, char_traits<wchar_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>>, __not_<is_convertible<const _Tp &, const wchar_t *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<wchar_t> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(wchar_t)
            };
            union {
                wchar_t _M_local_buf[4];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], wchar_t());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::input_iterator_tag);
            template<> constexpr void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<wchar_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            template<> constexpr void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<wchar_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(size_type __req, wchar_t __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = wchar_t();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const;
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept;
            bool _M_disjunct(const wchar_t *__s) const noexcept;
            static constexpr void _S_copy(wchar_t *__d, const wchar_t *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(wchar_t *__d, const wchar_t *__s, size_type __n);
            static constexpr void _S_assign(wchar_t *__d, size_type __n, wchar_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<wchar_t *>(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
            template<> static constexpr void _S_copy_chars<const wchar_t *>(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2);
            static constexpr void _S_copy_chars(wchar_t *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(wchar_t *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<wchar_t> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const wchar_t *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<wchar_t> &__a) noexcept;
            constexpr basic_string(const basic_string<wchar_t> &__str);
            constexpr basic_string(const basic_string<wchar_t> &__str, size_type __pos, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<wchar_t> &__str, size_type __pos, size_type __n, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const wchar_t *__s, size_type __n, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<wchar_t>>> constexpr basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            template<> constexpr basic_string<std::allocator<wchar_t>>(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            template <typename = _RequireAllocator<allocator<wchar_t>>> constexpr basic_string(size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
            constexpr basic_string(basic_string<wchar_t> &&__str) noexcept;
            constexpr basic_string(initializer_list<wchar_t> __l, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const basic_string<wchar_t> &__str, const std::allocator<wchar_t> &__a);
            constexpr basic_string(basic_string<wchar_t> &&__str, const std::allocator<wchar_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
            template<> constexpr basic_string<wchar_t *, void>(wchar_t *__beg, wchar_t *__end, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a), _M_string_length(0) {
                this->_M_construct(__beg, __end, std::__iterator_category(__beg));
            }
;
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<wchar_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<wchar_t> &__a);
            constexpr ~basic_string<wchar_t>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<wchar_t> &operator=(const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &operator=(const wchar_t *__s);
            constexpr basic_string<wchar_t> &operator=(wchar_t __c);
            constexpr basic_string<wchar_t> &operator=(basic_string<wchar_t> &&__str);
            constexpr basic_string<wchar_t> &operator=(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]];
            constexpr size_type length() const noexcept [[nodiscard("")]];
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, wchar_t __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]];
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]];
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<wchar_t> &operator+=(const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &operator+=(const wchar_t *__s);
            constexpr basic_string<wchar_t> &operator+=(wchar_t __c);
            constexpr basic_string<wchar_t> &operator+=(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<wchar_t> &append(const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &append(const basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<wchar_t> &append(const wchar_t *__s, size_type __n);
            constexpr basic_string<wchar_t> &append(const wchar_t *__s);
            constexpr basic_string<wchar_t> &append(size_type __n, wchar_t __c);
            constexpr basic_string<wchar_t> &append(initializer_list<wchar_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<wchar_t> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(wchar_t __c);
            constexpr basic_string<wchar_t> &assign(const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &assign(basic_string<wchar_t> &&__str);
            constexpr basic_string<wchar_t> &assign(const basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<wchar_t> &assign(const wchar_t *__s, size_type __n);
            constexpr basic_string<wchar_t> &assign(const wchar_t *__s);
            constexpr basic_string<wchar_t> &assign(size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<wchar_t> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<wchar_t> &assign(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<wchar_t> __l);
            constexpr basic_string<wchar_t> &insert(size_type __pos1, const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &insert(size_type __pos1, const basic_string<wchar_t> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s, size_type __n);
            constexpr basic_string<wchar_t> &insert(size_type __pos, const wchar_t *__s);
            constexpr basic_string<wchar_t> &insert(size_type __pos, size_type __n, wchar_t __c);
            constexpr iterator insert(__const_iterator __p, wchar_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<wchar_t> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<wchar_t> &replace(size_type __pos, size_type __n, const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const basic_string<wchar_t> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2);
            constexpr basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const wchar_t *__s);
            constexpr basic_string<wchar_t> &replace(size_type __pos, size_type __n1, size_type __n2, wchar_t __c);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<wchar_t> &__str);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s, size_type __n);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__s);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<wchar_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<wchar_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<wchar_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, wchar_t __c);
            void _M_replace_cold(pointer __p, size_type __len1, const wchar_t *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<wchar_t> &_M_replace(size_type __pos, size_type __len1, const wchar_t *__s, const size_type __len2);
            constexpr basic_string<wchar_t> &_M_append(const wchar_t *__s, size_type __n);
        public:
            constexpr size_type copy(wchar_t *__s, size_type __n, size_type __pos) const;
            constexpr void swap(basic_string<wchar_t> &__s) noexcept;
            constexpr const wchar_t *c_str() const noexcept [[nodiscard("")]] {
                return this->_M_data();
            }
            constexpr const wchar_t *data() const noexcept [[nodiscard("")]];
            constexpr wchar_t *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]];
            constexpr size_type find(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const wchar_t *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<wchar_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const wchar_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const wchar_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(wchar_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<wchar_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<wchar_t> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<wchar_t> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<wchar_t> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const wchar_t *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const wchar_t *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const wchar_t *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<wchar_t, char_traits<wchar_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(wchar_t __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const wchar_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<wchar_t, char_traits<wchar_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(wchar_t __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const wchar_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
        template<> class basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char8_t>>::rebind<char8_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char8_t> traits_type;
            typedef typename char_traits<char8_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<char8_t>, char_traits<char8_t>>)
                    ;
                return __p;
            }
            typedef basic_string_view<char8_t, char_traits<char8_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>>, __not_<is_convertible<const _Tp &, const char8_t *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<char8_t> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char8_t)
            };
            union {
                char8_t _M_local_buf[16];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char8_t());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char8_t *>(const char8_t *__beg, const char8_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>::_M_construct<const char8_t *>(const char8_t *__beg, const char8_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char8_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(size_type __req, char8_t __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = char8_t();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const;
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept;
            bool _M_disjunct(const char8_t *__s) const noexcept;
            static constexpr void _S_copy(char8_t *__d, const char8_t *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char8_t *__d, const char8_t *__s, size_type __n);
            static constexpr void _S_assign(char8_t *__d, size_type __n, char8_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char8_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<const char8_t *>(char8_t *__p, const char8_t *__k1, const char8_t *__k2);
            static constexpr void _S_copy_chars(char8_t *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, char8_t *__k1, char8_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, const char8_t *__k1, const char8_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<char8_t> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const char8_t *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char8_t> &__a) noexcept;
            constexpr basic_string(const basic_string<char8_t> &__str);
            constexpr basic_string(const basic_string<char8_t> &__str, size_type __pos, const std::allocator<char8_t> &__a);
            constexpr basic_string(const basic_string<char8_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<char8_t> &__str, size_type __pos, size_type __n, const std::allocator<char8_t> &__a);
            constexpr basic_string(const char8_t *__s, size_type __n, const std::allocator<char8_t> &__a = std::allocator<char8_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<char8_t>>> constexpr basic_string(const char8_t *__s, const std::allocator<char8_t> &__a);
            template<> constexpr basic_string<std::allocator<char8_t>>(const char8_t *__s, const std::allocator<char8_t> &__a);
            template <typename = _RequireAllocator<allocator<char8_t>>> constexpr basic_string(size_type __n, char8_t __c, const std::allocator<char8_t> &__a);
            constexpr basic_string(basic_string<char8_t> &&__str) noexcept;
            constexpr basic_string(initializer_list<char8_t> __l, const std::allocator<char8_t> &__a);
            constexpr basic_string(const basic_string<char8_t> &__str, const std::allocator<char8_t> &__a);
            constexpr basic_string(basic_string<char8_t> &&__str, const std::allocator<char8_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char8_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<char8_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char8_t> &__a);
            constexpr ~basic_string<char8_t>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<char8_t> &operator=(const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &operator=(const char8_t *__s);
            constexpr basic_string<char8_t> &operator=(char8_t __c);
            constexpr basic_string<char8_t> &operator=(basic_string<char8_t> &&__str);
            constexpr basic_string<char8_t> &operator=(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]];
            constexpr size_type length() const noexcept [[nodiscard("")]];
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, char8_t __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]];
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]];
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<char8_t> &operator+=(const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &operator+=(const char8_t *__s);
            constexpr basic_string<char8_t> &operator+=(char8_t __c);
            constexpr basic_string<char8_t> &operator+=(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<char8_t> &append(const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &append(const basic_string<char8_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char8_t> &append(const char8_t *__s, size_type __n);
            constexpr basic_string<char8_t> &append(const char8_t *__s);
            constexpr basic_string<char8_t> &append(size_type __n, char8_t __c);
            constexpr basic_string<char8_t> &append(initializer_list<char8_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char8_t> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(char8_t __c);
            constexpr basic_string<char8_t> &assign(const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &assign(basic_string<char8_t> &&__str);
            constexpr basic_string<char8_t> &assign(const basic_string<char8_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char8_t> &assign(const char8_t *__s, size_type __n);
            constexpr basic_string<char8_t> &assign(const char8_t *__s);
            constexpr basic_string<char8_t> &assign(size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char8_t> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<char8_t> &assign(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<char8_t> __l);
            constexpr basic_string<char8_t> &insert(size_type __pos1, const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &insert(size_type __pos1, const basic_string<char8_t> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<char8_t> &insert(size_type __pos, const char8_t *__s, size_type __n);
            constexpr basic_string<char8_t> &insert(size_type __pos, const char8_t *__s);
            constexpr basic_string<char8_t> &insert(size_type __pos, size_type __n, char8_t __c);
            constexpr iterator insert(__const_iterator __p, char8_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<char8_t> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<char8_t> &replace(size_type __pos, size_type __n, const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &replace(size_type __pos1, size_type __n1, const basic_string<char8_t> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<char8_t> &replace(size_type __pos, size_type __n1, const char8_t *__s, size_type __n2);
            constexpr basic_string<char8_t> &replace(size_type __pos, size_type __n1, const char8_t *__s);
            constexpr basic_string<char8_t> &replace(size_type __pos, size_type __n1, size_type __n2, char8_t __c);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<char8_t> &__str);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const char8_t *__s, size_type __n);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const char8_t *__s);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char8_t> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, char8_t *__k1, char8_t *__k2);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const char8_t *__k1, const char8_t *__k2);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<char8_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<char8_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<char8_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<char8_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<char8_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char8_t __c);
            void _M_replace_cold(pointer __p, size_type __len1, const char8_t *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<char8_t> &_M_replace(size_type __pos, size_type __len1, const char8_t *__s, const size_type __len2);
            constexpr basic_string<char8_t> &_M_append(const char8_t *__s, size_type __n);
        public:
            constexpr size_type copy(char8_t *__s, size_type __n, size_type __pos) const;
            constexpr void swap(basic_string<char8_t> &__s) noexcept;
            constexpr const char8_t *c_str() const noexcept [[nodiscard("")]];
            constexpr const char8_t *data() const noexcept [[nodiscard("")]];
            constexpr char8_t *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]];
            constexpr size_type find(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const char8_t *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<char8_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char8_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char8_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(char8_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<char8_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<char8_t> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<char8_t> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<char8_t> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const char8_t *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char8_t *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char8_t *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<char8_t, char_traits<char8_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(char8_t __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const char8_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<char8_t, char_traits<char8_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(char8_t __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const char8_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
        template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t>>::rebind<char16_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<char16_t>, char_traits<char16_t>>)
                    ;
                return __p;
            }
            typedef basic_string_view<char16_t, char_traits<char16_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>, __not_<is_convertible<const _Tp &, const char16_t *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<char16_t> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char16_t());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char16_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(size_type __req, char16_t __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = char16_t();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const;
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static constexpr void _S_copy(char16_t *__d, const char16_t *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char16_t *__d, const char16_t *__s, size_type __n);
            static constexpr void _S_assign(char16_t *__d, size_type __n, char16_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<const char16_t *>(char16_t *__p, const char16_t *__k1, const char16_t *__k2);
            static constexpr void _S_copy_chars(char16_t *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<char16_t> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const char16_t *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            constexpr basic_string(const basic_string<char16_t> &__str);
            constexpr basic_string(const basic_string<char16_t> &__str, size_type __pos, const std::allocator<char16_t> &__a);
            constexpr basic_string(const basic_string<char16_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<char16_t> &__str, size_type __pos, size_type __n, const std::allocator<char16_t> &__a);
            constexpr basic_string(const char16_t *__s, size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<char16_t>>> constexpr basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            template<> constexpr basic_string<std::allocator<char16_t>>(const char16_t *__s, const std::allocator<char16_t> &__a);
            template <typename = _RequireAllocator<allocator<char16_t>>> constexpr basic_string(size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            constexpr basic_string(basic_string<char16_t> &&__str) noexcept;
            constexpr basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            constexpr basic_string(const basic_string<char16_t> &__str, const std::allocator<char16_t> &__a);
            constexpr basic_string(basic_string<char16_t> &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char16_t> &__a);
            constexpr ~basic_string<char16_t>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<char16_t> &operator=(const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &operator=(const char16_t *__s);
            constexpr basic_string<char16_t> &operator=(char16_t __c);
            constexpr basic_string<char16_t> &operator=(basic_string<char16_t> &&__str);
            constexpr basic_string<char16_t> &operator=(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]];
            constexpr size_type length() const noexcept [[nodiscard("")]];
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, char16_t __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]];
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]];
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<char16_t> &operator+=(const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &operator+=(const char16_t *__s);
            constexpr basic_string<char16_t> &operator+=(char16_t __c);
            constexpr basic_string<char16_t> &operator+=(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<char16_t> &append(const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &append(const basic_string<char16_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char16_t> &append(const char16_t *__s, size_type __n);
            constexpr basic_string<char16_t> &append(const char16_t *__s);
            constexpr basic_string<char16_t> &append(size_type __n, char16_t __c);
            constexpr basic_string<char16_t> &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char16_t> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(char16_t __c);
            constexpr basic_string<char16_t> &assign(const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &assign(basic_string<char16_t> &&__str);
            constexpr basic_string<char16_t> &assign(const basic_string<char16_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char16_t> &assign(const char16_t *__s, size_type __n);
            constexpr basic_string<char16_t> &assign(const char16_t *__s);
            constexpr basic_string<char16_t> &assign(size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char16_t> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<char16_t> &assign(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<char16_t> __l);
            constexpr basic_string<char16_t> &insert(size_type __pos1, const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &insert(size_type __pos1, const basic_string<char16_t> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<char16_t> &insert(size_type __pos, const char16_t *__s, size_type __n);
            constexpr basic_string<char16_t> &insert(size_type __pos, const char16_t *__s);
            constexpr basic_string<char16_t> &insert(size_type __pos, size_type __n, char16_t __c);
            constexpr iterator insert(__const_iterator __p, char16_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<char16_t> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<char16_t> &replace(size_type __pos, size_type __n, const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &replace(size_type __pos1, size_type __n1, const basic_string<char16_t> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<char16_t> &replace(size_type __pos, size_type __n1, const char16_t *__s, size_type __n2);
            constexpr basic_string<char16_t> &replace(size_type __pos, size_type __n1, const char16_t *__s);
            constexpr basic_string<char16_t> &replace(size_type __pos, size_type __n1, size_type __n2, char16_t __c);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<char16_t> &__str);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const char16_t *__s, size_type __n);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const char16_t *__s);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char16_t> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, char16_t *__k1, char16_t *__k2);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<char16_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<char16_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<char16_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<char16_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<char16_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char16_t __c);
            void _M_replace_cold(pointer __p, size_type __len1, const char16_t *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<char16_t> &_M_replace(size_type __pos, size_type __len1, const char16_t *__s, const size_type __len2);
            constexpr basic_string<char16_t> &_M_append(const char16_t *__s, size_type __n);
        public:
            constexpr size_type copy(char16_t *__s, size_type __n, size_type __pos) const;
            constexpr void swap(basic_string<char16_t> &__s) noexcept;
            constexpr const char16_t *c_str() const noexcept [[nodiscard("")]];
            constexpr const char16_t *data() const noexcept [[nodiscard("")]];
            constexpr char16_t *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]];
            constexpr size_type find(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const char16_t *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<char16_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char16_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char16_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(char16_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<char16_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<char16_t> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<char16_t> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<char16_t> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const char16_t *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char16_t *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char16_t *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<char16_t, char_traits<char16_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(char16_t __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const char16_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<char16_t, char_traits<char16_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(char16_t __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const char16_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
        template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t>>::rebind<char32_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef _Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const size_type npos = static_cast<size_type>(-1);
        protected:
            typedef const_iterator __const_iterator;
        private:
            static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
                pointer __p = _Alloc_traits::allocate(__a, __n);
                if (!is_same_v<std::char_traits<char32_t>, char_traits<char32_t>>)
                    ;
                return __p;
            }
            typedef basic_string_view<char32_t, char_traits<char32_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>, __not_<is_convertible<const _Tp &, const char32_t *>>>::value, _Res>;
            static constexpr __sv_type _S_to_string_view(__sv_type __svt) noexcept;
            struct __sv_wrapper {
                __sv_type _M_sv;
            };
            constexpr explicit basic_string(__sv_wrapper __svw, const std::allocator<char32_t> &__a);
            struct _Alloc_hider : allocator_type {
                pointer _M_p;
            };
            _Alloc_hider _M_dataplus;
            size_type _M_string_length;
            enum {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                size_type _M_allocated_capacity;
            };
            constexpr void _M_data(pointer __p) {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(size_type __length) {
                this->_M_string_length = __length;
            }
            constexpr pointer _M_data() const {
                return this->_M_dataplus._M_p;
            }
            constexpr pointer _M_local_data() {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr const_pointer _M_local_data() const {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(size_type __capacity) {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(size_type __n) {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char32_t());
            }
            constexpr bool _M_is_local() const {
                if (this->_M_data() == this->_M_local_data()) {
                    if (this->_M_string_length > _S_local_capacity)
                        __builtin_unreachable();
                    return true;
                }
                return false;
            }
            constexpr pointer basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_create(size_type &__capacity, size_type __old_capacity) {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _S_allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose() {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(size_type __size) throw() {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag) {
                size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                if (__dnew > size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char32_t> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(size_type __req, char32_t __c);
            constexpr allocator_type &_M_get_allocator() {
                return this->_M_dataplus;
            }
            constexpr const allocator_type &_M_get_allocator() const {
                return this->_M_dataplus;
            }
            constexpr pointer _M_use_local_data() noexcept __attribute__((always_inline)) {
                if (std::is_constant_evaluated())
                    for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
                        this->_M_local_buf[__i] = char32_t();
                return this->_M_local_data();
            }
        private:
            constexpr size_type _M_check(size_type __pos, const char *__s) const;
            constexpr void _M_check_length(size_type __n1, size_type __n2, const char *__s) const;
            constexpr size_type _M_limit(size_type __pos, size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static constexpr void _S_copy(char32_t *__d, const char32_t *__s, size_type __n) {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char32_t *__d, const char32_t *__s, size_type __n);
            static constexpr void _S_assign(char32_t *__d, size_type __n, char32_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<const char32_t *>(char32_t *__p, const char32_t *__k1, const char32_t *__k2);
            static constexpr void _S_copy_chars(char32_t *__p, iterator __k1, iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, const_iterator __k1, const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept;
            constexpr void _M_assign(const basic_string<char32_t> &);
            constexpr void _M_mutate(size_type __pos, size_type __len1, const char32_t *__s, size_type __len2);
            constexpr void _M_erase(size_type __pos, size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            constexpr basic_string(const basic_string<char32_t> &__str);
            constexpr basic_string(const basic_string<char32_t> &__str, size_type __pos, const std::allocator<char32_t> &__a);
            constexpr basic_string(const basic_string<char32_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string(const basic_string<char32_t> &__str, size_type __pos, size_type __n, const std::allocator<char32_t> &__a);
            constexpr basic_string(const char32_t *__s, size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a) {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<allocator<char32_t>>> constexpr basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            template<> constexpr basic_string<std::allocator<char32_t>>(const char32_t *__s, const std::allocator<char32_t> &__a);
            template <typename = _RequireAllocator<allocator<char32_t>>> constexpr basic_string(size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            constexpr basic_string(basic_string<char32_t> &&__str) noexcept;
            constexpr basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            constexpr basic_string(const basic_string<char32_t> &__str, const std::allocator<char32_t> &__a);
            constexpr basic_string(basic_string<char32_t> &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>> constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char32_t> &__a);
            constexpr ~basic_string<char32_t>() noexcept {
                this->_M_dispose();
            }
            constexpr basic_string<char32_t> &operator=(const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &operator=(const char32_t *__s);
            constexpr basic_string<char32_t> &operator=(char32_t __c);
            constexpr basic_string<char32_t> &operator=(basic_string<char32_t> &&__str);
            constexpr basic_string<char32_t> &operator=(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr iterator begin() noexcept [[nodiscard("")]];
            constexpr const_iterator begin() const noexcept [[nodiscard("")]];
            constexpr iterator end() noexcept [[nodiscard("")]];
            constexpr const_iterator end() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
            constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
            constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
            constexpr const_iterator cend() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
            constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        public:
            constexpr size_type size() const noexcept [[nodiscard("")]];
            constexpr size_type length() const noexcept [[nodiscard("")]];
            constexpr size_type max_size() const noexcept [[nodiscard("")]] {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(size_type __n, char32_t __c);
            constexpr void resize(size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr size_type capacity() const noexcept [[nodiscard("")]];
            constexpr void reserve(size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr const_reference operator[](size_type __pos) const noexcept [[nodiscard("")]];
            constexpr reference operator[](size_type __pos) [[nodiscard("")]];
            constexpr const_reference at(size_type __n) const [[nodiscard("")]];
            constexpr reference at(size_type __n) [[nodiscard("")]];
            constexpr reference front() noexcept [[nodiscard("")]];
            constexpr const_reference front() const noexcept [[nodiscard("")]];
            constexpr reference back() noexcept [[nodiscard("")]];
            constexpr const_reference back() const noexcept [[nodiscard("")]];
            constexpr basic_string<char32_t> &operator+=(const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &operator+=(const char32_t *__s);
            constexpr basic_string<char32_t> &operator+=(char32_t __c);
            constexpr basic_string<char32_t> &operator+=(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> operator+=(const _Tp &__svt);
            constexpr basic_string<char32_t> &append(const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &append(const basic_string<char32_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char32_t> &append(const char32_t *__s, size_type __n);
            constexpr basic_string<char32_t> &append(const char32_t *__s);
            constexpr basic_string<char32_t> &append(size_type __n, char32_t __c);
            constexpr basic_string<char32_t> &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char32_t> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> append(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr void push_back(char32_t __c);
            constexpr basic_string<char32_t> &assign(const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &assign(basic_string<char32_t> &&__str);
            constexpr basic_string<char32_t> &assign(const basic_string<char32_t> &__str, size_type __pos, size_type __n);
            constexpr basic_string<char32_t> &assign(const char32_t *__s, size_type __n);
            constexpr basic_string<char32_t> &assign(const char32_t *__s);
            constexpr basic_string<char32_t> &assign(size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char32_t> &assign(_InputIterator __first, _InputIterator __last);
            constexpr basic_string<char32_t> &assign(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> assign(const _Tp &__svt, size_type __pos, size_type __n);
            constexpr iterator insert(const_iterator __p, size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr iterator insert(const_iterator __p, initializer_list<char32_t> __l);
            constexpr basic_string<char32_t> &insert(size_type __pos1, const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &insert(size_type __pos1, const basic_string<char32_t> &__str, size_type __pos2, size_type __n);
            constexpr basic_string<char32_t> &insert(size_type __pos, const char32_t *__s, size_type __n);
            constexpr basic_string<char32_t> &insert(size_type __pos, const char32_t *__s);
            constexpr basic_string<char32_t> &insert(size_type __pos, size_type __n, char32_t __c);
            constexpr iterator insert(__const_iterator __p, char32_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> insert(size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> insert(size_type __pos1, const _Tp &__svt, size_type __pos2, size_type __n);
            constexpr basic_string<char32_t> &erase(size_type __pos, size_type __n);
            constexpr iterator erase(__const_iterator __position);
            constexpr iterator erase(__const_iterator __first, __const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr basic_string<char32_t> &replace(size_type __pos, size_type __n, const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &replace(size_type __pos1, size_type __n1, const basic_string<char32_t> &__str, size_type __pos2, size_type __n2);
            constexpr basic_string<char32_t> &replace(size_type __pos, size_type __n1, const char32_t *__s, size_type __n2);
            constexpr basic_string<char32_t> &replace(size_type __pos, size_type __n1, const char32_t *__s);
            constexpr basic_string<char32_t> &replace(size_type __pos, size_type __n1, size_type __n2, char32_t __c);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const basic_string<char32_t> &__str);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const char32_t *__s, size_type __n);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const char32_t *__s);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<char32_t> &replace(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, char32_t *__k1, char32_t *__k2);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, iterator __k1, iterator __k2);
            constexpr basic_string<char32_t> &replace(__const_iterator __i1, __const_iterator __i2, const_iterator __k1, const_iterator __k2);
            constexpr basic_string<char32_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> replace(size_type __pos, size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> replace(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &> replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr basic_string<char32_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n, _Integer __val, __true_type);
            template <class _InputIterator> constexpr basic_string<char32_t> &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            constexpr basic_string<char32_t> &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, char32_t __c);
            void _M_replace_cold(pointer __p, size_type __len1, const char32_t *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold));
            constexpr basic_string<char32_t> &_M_replace(size_type __pos, size_type __len1, const char32_t *__s, const size_type __len2);
            constexpr basic_string<char32_t> &_M_append(const char32_t *__s, size_type __n);
        public:
            constexpr size_type copy(char32_t *__s, size_type __n, size_type __pos) const;
            constexpr void swap(basic_string<char32_t> &__s) noexcept;
            constexpr const char32_t *c_str() const noexcept [[nodiscard("")]];
            constexpr const char32_t *data() const noexcept [[nodiscard("")]];
            constexpr char32_t *data() noexcept [[nodiscard("")]];
            constexpr allocator_type get_allocator() const noexcept [[nodiscard("")]];
            constexpr size_type find(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type rfind(const char32_t *__s, size_type __pos) const [[nodiscard("")]];
            constexpr size_type rfind(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_of(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_of(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_first_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_first_not_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const basic_string<char32_t> &__str, size_type __pos) const noexcept [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt, size_type __pos) const [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char32_t *__s, size_type __pos, size_type __n) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(const char32_t *__s, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr size_type find_last_not_of(char32_t __c, size_type __pos) const noexcept [[nodiscard("")]];
            constexpr basic_string<char32_t> substr(size_type __pos, size_type __n) const [[nodiscard("")]];
            constexpr int compare(const basic_string<char32_t> &__str) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos, size_type __n, const _Tp &__svt) const [[nodiscard("")]];
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n, const basic_string<char32_t> &__str) const [[nodiscard("")]];
            constexpr int compare(size_type __pos1, size_type __n1, const basic_string<char32_t> &__str, size_type __pos2, size_type __n2) const [[nodiscard("")]];
            constexpr int compare(const char32_t *__s) const noexcept [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char32_t *__s) const [[nodiscard("")]];
            constexpr int compare(size_type __pos, size_type __n1, const char32_t *__s, size_type __n2) const [[nodiscard("")]];
            constexpr bool starts_with(basic_string_view<char32_t, char_traits<char32_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(char32_t __x) const noexcept [[nodiscard("")]];
            constexpr bool starts_with(const char32_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            constexpr bool ends_with(basic_string_view<char32_t, char_traits<char32_t>> __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(char32_t __x) const noexcept [[nodiscard("")]];
            constexpr bool ends_with(const char32_t *__x) const noexcept [[nodiscard("")]] [[gnu::nonnull]];
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
}
namespace std {
    inline namespace __cxx11 {
        template <typename _InputIterator, typename _CharT = typename iterator_traits<_InputIterator>::value_type, typename _Allocator = allocator<_CharT>, typename = _RequireInputIter<_InputIterator>, typename = _RequireAllocator<_Allocator>> basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator()) -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;
        template <typename _CharT, typename _Traits, typename _Allocator = allocator<_CharT>, typename = _RequireAllocator<_Allocator>> basic_string(basic_string_view<_CharT, _Traits>, const _Allocator & = _Allocator()) -> basic_string<_CharT, _Traits, _Allocator>;
        template <typename _CharT, typename _Traits, typename _Allocator = allocator<_CharT>, typename = _RequireAllocator<_Allocator>> basic_string(basic_string_view<_CharT, _Traits>, typename basic_string<_CharT, _Traits, _Allocator>::size_type, typename basic_string<_CharT, _Traits, _Allocator>::size_type, const _Allocator & = _Allocator()) -> basic_string<_CharT, _Traits, _Allocator>;
    }
    template <typename _Str> inline constexpr _Str __str_concat(const typename _Str::value_type *__lhs, typename _Str::size_type __lhs_len, const typename _Str::value_type *__rhs, typename _Str::size_type __rhs_len, const typename _Str::allocator_type &__a) {
        typedef typename _Str::allocator_type allocator_type;
        typedef __gnu_cxx::__alloc_traits<allocator_type> _Alloc_traits;
        _Str __str(_Alloc_traits::_S_select_on_copy(__a));
        __str.reserve(__lhs_len + __rhs_len);
        __str.append(__lhs, __lhs_len);
        __str.append(__rhs, __rhs_len);
        return __str;
    }
    template<> inline constexpr std::basic_string<char> __str_concat<std::basic_string<char>>(const typename basic_string<char>::value_type *__lhs, typename basic_string<char>::size_type __lhs_len, const typename basic_string<char>::value_type *__rhs, typename basic_string<char>::size_type __rhs_len, const typename basic_string<char>::allocator_type &__a) {
        typedef typename basic_string<char>::allocator_type allocator_type;
        typedef __gnu_cxx::__alloc_traits<allocator_type> _Alloc_traits;
        std::basic_string<char> __str(_Alloc_traits::_S_select_on_copy(__a));
        __str.reserve(__lhs_len + __rhs_len);
        __str.append(__lhs, __lhs_len);
        __str.append(__rhs, __rhs_len);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) [[nodiscard("")]] {
        typedef basic_string<_CharT, _Traits, _Alloc> _Str;
        return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(), __rhs.c_str(), __rhs.size(), __lhs.get_allocator());
    }
    template<> inline constexpr basic_string<char, char_traits<char>, allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, char_traits<char>, allocator<char>> &__lhs, const basic_string<char, char_traits<char>, allocator<char>> &__rhs) [[nodiscard("")]]    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) [[nodiscard("")]] {
        ;
        typedef basic_string<_CharT, _Traits, _Alloc> _Str;
        return std::__str_concat<_Str>(__lhs, _Traits::length(__lhs), __rhs.c_str(), __rhs.size(), __rhs.get_allocator());
    }
    template<> inline constexpr basic_string<char, char_traits<char>, allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, const basic_string<char, char_traits<char>, allocator<char>> &__rhs) [[nodiscard("")]]    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) [[nodiscard("")]] {
        typedef basic_string<_CharT, _Traits, _Alloc> _Str;
        return std::__str_concat<_Str>(__builtin_addressof(__lhs), 1, __rhs.c_str(), __rhs.size(), __rhs.get_allocator());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) [[nodiscard("")]] {
        ;
        typedef basic_string<_CharT, _Traits, _Alloc> _Str;
        return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(), __rhs, _Traits::length(__rhs), __lhs.get_allocator());
    }
    template<> inline constexpr basic_string<char, char_traits<char>, allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, char_traits<char>, allocator<char>> &__lhs, const char *__rhs) [[nodiscard("")]] {
        ;
        typedef basic_string<char, char_traits<char>, allocator<char>> _Str;
        return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(), __rhs, char_traits<char>::length(__rhs), __lhs.get_allocator());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs) [[nodiscard("")]] {
        typedef basic_string<_CharT, _Traits, _Alloc> _Str;
        return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(), __builtin_addressof(__rhs), 1, __lhs.get_allocator());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) [[nodiscard("")]] {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline constexpr basic_string<char, char_traits<char>, allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, char_traits<char>, allocator<char>> &&__lhs, const basic_string<char, char_traits<char>, allocator<char>> &__rhs) [[nodiscard("")]]    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline constexpr basic_string<char, char_traits<char>, allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, char_traits<char>, allocator<char>> &__lhs, basic_string<char, char_traits<char>, allocator<char>> &&__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) [[nodiscard("")]] {
        using _Alloc_traits = allocator_traits<_Alloc>;
        bool __use_rhs = false;
        if (typename _Alloc_traits::is_always_equal{})
            __use_rhs = true;
        else if (__lhs.get_allocator() == __rhs.get_allocator())
            __use_rhs = true;
        if (__use_rhs) {
            const auto __size = __lhs.size() + __rhs.size();
            if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                return std::move(__rhs.insert(0, __lhs));
        }
        return std::move(__lhs.append(__rhs));
    }
    template<> inline constexpr basic_string<char, char_traits<char>, allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, char_traits<char>, allocator<char>> &&__lhs, basic_string<char, char_traits<char>, allocator<char>> &&__rhs) [[nodiscard("")]] {
        using _Alloc_traits = allocator_traits<allocator<char>>;
        bool __use_rhs = false;
        if (typename _Alloc_traits::is_always_equal{})
            __use_rhs = true;
        if (__use_rhs) {
            const auto __size = __lhs.size() + __rhs.size();
            if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                return std::move(__rhs.insert(0, __lhs));
        }
        return std::move(__lhs.append(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) [[nodiscard("")]] [[nodiscard("")]] {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline constexpr basic_string<char, char_traits<char>, allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, basic_string<char, char_traits<char>, allocator<char>> &&__rhs) [[nodiscard("")]] [[nodiscard("")]] {
        return std::move(__rhs.insert(0, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) [[nodiscard("")]] {
        return std::move(__rhs.insert(0, 1, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs) [[nodiscard("")]] {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline constexpr basic_string<char, char_traits<char>, allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, char_traits<char>, allocator<char>> &&__lhs, const char *__rhs) [[nodiscard("")]] {
        return std::move(__lhs.append(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs) [[nodiscard("")]] {
        return std::move(__lhs.append(1, __rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept [[nodiscard("")]] {
        return __lhs.size() == __rhs.size() && !_Traits::compare(__lhs.data(), __rhs.data(), __lhs.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) [[nodiscard("")]] {
        return __lhs.size() == _Traits::length(__rhs) && !_Traits::compare(__lhs.data(), __rhs, __lhs.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr auto operator<=>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0)) [[nodiscard("")]] {
        return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr auto operator<=>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0)) [[nodiscard("")]] {
        return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr void swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept(noexcept(__lhs.swap(__rhs))) {
        __lhs.swap(__rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str);
    template<> basic_istream<char> &operator>><char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__is, basic_string<char> &__str);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Alloc> &__str) {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str) {
        return std::getline(__is, __str, __is.widen('\n'));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim) {
        return std::getline(__is, __str, __delim);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str) {
        return std::getline(__is, __str);
    }
    template<> basic_istream<char> &getline<char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__in, basic_string<char> &__str, char __delim);
    template<> basic_istream<wchar_t> &getline<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim);
}
typedef unsigned long size_t;
extern "C" {
    typedef struct {
        int quot;
        int rem;
    } div_t;
    typedef struct {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct {
        long long quot;
        long long rem;
    } lldiv_t;
    extern size_t __ctype_get_mb_cur_max() noexcept(true);
    extern double atof(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern int atoi(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern long atol(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern long long atoll(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float32 strtof32(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float64 strtof64(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float32x strtof32x(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float64x strtof64x(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern long strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern long long strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long long strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern long long strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long long strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern long strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_strtol") __attribute__((nonnull(1)));
    extern unsigned long strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_strtoul") __attribute__((nonnull(1)));
    extern long long strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_strtoll") __attribute__((nonnull(1)));
    extern unsigned long long strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_strtoull") __attribute__((nonnull(1)));
    extern long long strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_strtoll") __attribute__((nonnull(1)));
    extern unsigned long long strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) asm("__isoc23_strtoull") __attribute__((nonnull(1)));
    extern int strfromd(char *__dest, size_t __size, const char *__format, double __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf(char *__dest, size_t __size, const char *__format, float __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfroml(char *__dest, size_t __size, const char *__format, long double __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf32(char *__dest, size_t __size, const char *__format, _Float32 __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf64(char *__dest, size_t __size, const char *__format, _Float64 __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf32x(char *__dest, size_t __size, const char *__format, _Float32x __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf64x(char *__dest, size_t __size, const char *__format, _Float64x __f) noexcept(true) __attribute__((nonnull(3)));
    extern long strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern unsigned long strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern long long strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern unsigned long long strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern long strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) asm("__isoc23_strtol_l") __attribute__((nonnull(1, 4)));
    extern unsigned long strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) asm("__isoc23_strtoul_l") __attribute__((nonnull(1, 4)));
    extern long long strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) asm("__isoc23_strtoll_l") __attribute__((nonnull(1, 4)));
    extern unsigned long long strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) asm("__isoc23_strtoull_l") __attribute__((nonnull(1, 4)));
    extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float32 strtof32_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float64 strtof64_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float32x strtof32x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float64x strtof64x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern char *l64a(long __n) noexcept(true);
    extern long a64l(const char *__s) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern "C" {
        typedef __u_char u_char;
        typedef __u_short u_short;
        typedef __u_int u_int;
        typedef __u_long u_long;
        typedef __quad_t quad_t;
        typedef __u_quad_t u_quad_t;
        typedef __fsid_t fsid_t;
        typedef __loff_t loff_t;
        typedef __ino_t ino_t;
        typedef __ino64_t ino64_t;
        typedef __dev_t dev_t;
        typedef __gid_t gid_t;
        typedef __mode_t mode_t;
        typedef __nlink_t nlink_t;
        typedef __uid_t uid_t;
        typedef __off_t off_t;
        typedef __off64_t off64_t;
        typedef __id_t id_t;
        typedef __ssize_t ssize_t;
        typedef __daddr_t daddr_t;
        typedef __caddr_t caddr_t;
        typedef __key_t key_t;
        typedef __useconds_t useconds_t;
        typedef __suseconds_t suseconds_t;
        typedef unsigned long size_t;
        typedef unsigned long ulong;
        typedef unsigned short ushort;
        typedef unsigned int uint;
        typedef __int8_t int8_t;
        typedef __int16_t int16_t;
        typedef __int32_t int32_t;
        typedef __int64_t int64_t;
        typedef __uint8_t u_int8_t;
        typedef __uint16_t u_int16_t;
        typedef __uint32_t u_int32_t;
        typedef __uint64_t u_int64_t;
        typedef int register_t __attribute__((mode(__word__)));
        static inline __uint16_t __bswap_16(__uint16_t __bsx) {
            return ((__uint16_t)((((__bsx) >> 8) & 255) | (((__bsx) & 255) << 8)));
        }
        static inline __uint32_t __bswap_32(__uint32_t __bsx) {
            return ((((__bsx) & 4278190080U) >> 24) | (((__bsx) & 16711680U) >> 8) | (((__bsx) & 65280U) << 8) | (((__bsx) & 255U) << 24));
        }
        static inline __uint64_t __bswap_64(__uint64_t __bsx) {
            return ((((__bsx) & 18374686479671623680ULL) >> 56) | (((__bsx) & 71776119061217280ULL) >> 40) | (((__bsx) & 280375465082880ULL) >> 24) | (((__bsx) & 1095216660480ULL) >> 8) | (((__bsx) & 4278190080ULL) << 8) | (((__bsx) & 16711680ULL) << 24) | (((__bsx) & 65280ULL) << 40) | (((__bsx) & 255ULL) << 56));
        }
        static inline __uint16_t __uint16_identity(__uint16_t __x) {
            return __x;
        }
        static inline __uint32_t __uint32_identity(__uint32_t __x) {
            return __x;
        }
        static inline __uint64_t __uint64_identity(__uint64_t __x) {
            return __x;
        }
        typedef __sigset_t sigset_t;
        typedef long __fd_mask;
        typedef struct {
            __fd_mask fds_bits[16];
        } fd_set;
        typedef __fd_mask fd_mask;
        extern "C" {
            extern int select(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);
            extern int pselect(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);
        }
        typedef __blksize_t blksize_t;
        typedef __blkcnt_t blkcnt_t;
        typedef __fsblkcnt_t fsblkcnt_t;
        typedef __fsfilcnt_t fsfilcnt_t;
        typedef __blkcnt64_t blkcnt64_t;
        typedef __fsblkcnt64_t fsblkcnt64_t;
        typedef __fsfilcnt64_t fsfilcnt64_t;
    }
    extern long random() noexcept(true);
    extern void srandom(unsigned int __seed) noexcept(true);
    extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen) noexcept(true) __attribute__((nonnull(2)));
    extern char *setstate(char *__statebuf) noexcept(true) __attribute__((nonnull(1)));
    struct random_data {
        int32_t *fptr;
        int32_t *rptr;
        int32_t *state;
        int rand_type;
        int rand_deg;
        int rand_sep;
        int32_t *end_ptr;
    };
    extern int random_r(struct random_data *__restrict __buf, int32_t *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int srandom_r(unsigned int __seed, struct random_data *__buf) noexcept(true) __attribute__((nonnull(2)));
    extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) noexcept(true) __attribute__((nonnull(2, 4)));
    extern int setstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int rand() noexcept(true);
    extern void srand(unsigned int __seed) noexcept(true);
    extern int rand_r(unsigned int *__seed) noexcept(true);
    extern double drand48() noexcept(true);
    extern double erand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern long lrand48() noexcept(true);
    extern long nrand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern long mrand48() noexcept(true);
    extern long jrand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern void srand48(long __seedval) noexcept(true);
    extern unsigned short *seed48(unsigned short __seed16v[3]) noexcept(true) __attribute__((nonnull(1)));
    extern void lcong48(unsigned short __param[7]) noexcept(true) __attribute__((nonnull(1)));
    struct drand48_data {
        unsigned short __x[3];
        unsigned short __old_x[3];
        unsigned short __c;
        unsigned short __init;
        unsigned long long __a;
    };
    extern int drand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int lrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int mrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int srand48_r(long __seedval, struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(2)));
    extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(1, 2)));
    extern __uint32_t arc4random() noexcept(true);
    extern void arc4random_buf(void *__buf, size_t __size) noexcept(true) __attribute__((nonnull(1)));
    extern __uint32_t arc4random_uniform(__uint32_t __upper_bound) noexcept(true);
    extern void *malloc(size_t __size) noexcept(true) __attribute__((malloc));
    extern void *calloc(size_t __nmemb, size_t __size) noexcept(true) __attribute__((malloc));
    extern void *realloc(void *__ptr, size_t __size) noexcept(true) __attribute__((warn_unused_result("")));
    extern void free(void *__ptr) noexcept(true);
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) noexcept(true) __attribute__((warn_unused_result("")));
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) noexcept(true);
    typedef unsigned long size_t;
    extern "C" {
        extern void *alloca(size_t __size) noexcept(true);
    }
    extern void *valloc(size_t __size) noexcept(true) __attribute__((malloc));
    extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size) noexcept(true) __attribute__((nonnull(1)));
    extern void *aligned_alloc(size_t __alignment, size_t __size) noexcept(true) __attribute__((malloc)) __attribute__((alloc_align(1)));
    extern void abort() noexcept(true);
    extern int atexit(void (*__func)()) noexcept(true) __attribute__((nonnull(1)));
    extern "C++" int at_quick_exit(void (*__func)()) noexcept(true) asm("at_quick_exit") __attribute__((nonnull(1)))
    extern int on_exit(void (*__func)(int, void *), void *__arg) noexcept(true) __attribute__((nonnull(1)));
    extern void exit(int __status) noexcept(true);
    extern void quick_exit(int __status) noexcept(true);
    extern void _Exit(int __status) noexcept(true);
    extern char *getenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern char *secure_getenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern int putenv(char *__string) noexcept(true) __attribute__((nonnull(1)));
    extern int setenv(const char *__name, const char *__value, int __replace) noexcept(true) __attribute__((nonnull(2)));
    extern int unsetenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern int clearenv() noexcept(true);
    extern char *mktemp(char *__template) noexcept(true) __attribute__((nonnull(1)));
    extern int mkstemp(char *__template) __attribute__((nonnull(1)));
    extern int mkstemp64(char *__template) __attribute__((nonnull(1)));
    extern int mkstemps(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern int mkstemps64(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern char *mkdtemp(char *__template) noexcept(true) __attribute__((nonnull(1)));
    extern int mkostemp(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemp64(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int system(const char *__command);
    extern char *canonicalize_file_name(const char *__name) noexcept(true) __attribute__((nonnull(1))) __attribute__((malloc));
    extern char *realpath(const char *__restrict __name, char *__restrict __resolved) noexcept(true);
    typedef int (*__compar_fn_t)(const void *, const void *);
    typedef __compar_fn_t comparison_fn_t;
    typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
    extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 2, 5)));
    extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 4)));
    extern void qsort_r(void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg) __attribute__((nonnull(1, 4)));
    extern int abs(int __x) noexcept(true) __attribute__((const));
    extern long labs(long __x) noexcept(true) __attribute__((const));
    extern long long llabs(long long __x) noexcept(true) __attribute__((const));
    extern div_t div(int __numer, int __denom) noexcept(true) __attribute__((const));
    extern ldiv_t ldiv(long __numer, long __denom) noexcept(true) __attribute__((const));
    extern lldiv_t lldiv(long long __numer, long long __denom) noexcept(true) __attribute__((const));
    extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *gcvt(double __value, int __ndigit, char *__buf) noexcept(true) __attribute__((nonnull(3)));
    extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *qgcvt(long double __value, int __ndigit, char *__buf) noexcept(true) __attribute__((nonnull(3)));
    extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int mblen(const char *__s, size_t __n) noexcept(true);
    extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) noexcept(true);
    extern int wctomb(char *__s, wchar_t __wchar) noexcept(true);
    extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) noexcept(true);
    extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) noexcept(true);
    extern int rpmatch(const char *__response) noexcept(true) __attribute__((nonnull(1)));
    extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) noexcept(true) __attribute__((nonnull(1, 2, 3)));
    extern int posix_openpt(int __oflag);
    extern int grantpt(int __fd) noexcept(true);
    extern int unlockpt(int __fd) noexcept(true);
    extern char *ptsname(int __fd) noexcept(true);
    extern int ptsname_r(int __fd, char *__buf, size_t __buflen) noexcept(true) __attribute__((nonnull(2)));
    extern int getpt();
    extern int getloadavg(double __loadavg[], int __nelem) noexcept(true) __attribute__((nonnull(1)));
}
extern "C++" {
    namespace std {
        using ::abs;
        inline long abs(long __i) {
            return __builtin_labs(__i);
        }
        inline long long abs(long long __x) {
            return __builtin_llabs(__x);
        }
        inline constexpr double abs(double __x) {
            return __builtin_fabs(__x);
        }
        inline constexpr float abs(float __x) {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double abs(long double __x) {
            return __builtin_fabsl(__x);
        }
    }
}
extern "C++" {
    namespace std {
        using ::div_t;
        using ::ldiv_t;
        using ::abort;
        using ::aligned_alloc;
        using ::atexit;
        using ::at_quick_exit;
        using ::atof;
        using ::atoi;
        using ::atol;
        using ::bsearch;
        using ::calloc;
        using ::div;
        using ::exit;
        using ::free;
        using ::getenv;
        using ::labs;
        using ::ldiv;
        using ::malloc;
        using ::mblen;
        using ::mbstowcs;
        using ::mbtowc;
        using ::qsort;
        using ::quick_exit;
        using ::rand;
        using ::realloc;
        using ::srand;
        using ::strtod;
        using ::strtol;
        using ::strtoul;
        using ::system;
        using ::wcstombs;
        using ::wctomb;
        inline ldiv_t div(long __i, long __j) noexcept {
            return ldiv(__i, __j);
        }
    }
    namespace __gnu_cxx {
        using ::lldiv_t;
        using ::_Exit;
        using ::llabs;
        inline lldiv_t div(long long __n, long long __d) {
            lldiv_t __q;
            __q.quot = __n / __d;
            __q.rem = __n % __d;
            return __q;
        }
        using ::lldiv;
        using ::atoll;
        using ::strtoll;
        using ::strtoull;
        using ::strtof;
        using ::strtold;
    }
    namespace std {
        using ::__gnu_cxx::lldiv_t;
        using ::__gnu_cxx::_Exit;
        using ::__gnu_cxx::llabs;
        using ::__gnu_cxx::div;
        using ::__gnu_cxx::lldiv;
        using ::__gnu_cxx::atoll;
        using ::__gnu_cxx::strtof;
        using ::__gnu_cxx::strtoll;
        using ::__gnu_cxx::strtoull;
        using ::__gnu_cxx::strtold;
    }
}
extern "C" {
    typedef unsigned long size_t;
    typedef struct _G_fpos_t {
        __off_t __pos;
        __mbstate_t __state;
    } __fpos_t;
    typedef struct _G_fpos64_t {
        __off64_t __pos;
        __mbstate_t __state;
    } __fpos64_t;
    struct _IO_FILE;
    struct _IO_marker;
    struct _IO_codecvt;
    struct _IO_wide_data;
    typedef void _IO_lock_t;
    struct _IO_FILE {
        int _flags;
        char *_IO_read_ptr;
        char *_IO_read_end;
        char *_IO_read_base;
        char *_IO_write_base;
        char *_IO_write_ptr;
        char *_IO_write_end;
        char *_IO_buf_base;
        char *_IO_buf_end;
        char *_IO_save_base;
        char *_IO_backup_base;
        char *_IO_save_end;
        struct _IO_marker *_markers;
        struct _IO_FILE *_chain;
        int _fileno;
        int _flags2;
        __off_t _old_offset;
        unsigned short _cur_column;
        signed char _vtable_offset;
        char _shortbuf[1];
        _IO_lock_t *_lock;
        __off64_t _offset;
        struct _IO_codecvt *_codecvt;
        struct _IO_wide_data *_wide_data;
        struct _IO_FILE *_freeres_list;
        void *_freeres_buf;
        size_t __pad5;
        int _mode;
        char _unused2[20];
    };
    typedef __ssize_t (cookie_read_function_t)(void *, char *, size_t);
    typedef __ssize_t (cookie_write_function_t)(void *, const char *, size_t);
    typedef int (cookie_seek_function_t)(void *, __off64_t *, int);
    typedef int (cookie_close_function_t)(void *);
    typedef struct _IO_cookie_io_functions_t {
        cookie_read_function_t *read;
        cookie_write_function_t *write;
        cookie_seek_function_t *seek;
        cookie_close_function_t *close;
    } cookie_io_functions_t;
    typedef __fpos_t fpos_t;
    typedef __fpos64_t fpos64_t;
    extern FILE *stdin;
    extern FILE *stdout;
    extern FILE *stderr;
    extern int remove(const char *__filename) noexcept(true);
    extern int rename(const char *__old, const char *__new) noexcept(true);
    extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) noexcept(true);
    extern int renameat2(int __oldfd, const char *__old, int __newfd, const char *__new, unsigned int __flags) noexcept(true);
    extern int fclose(FILE *__stream) __attribute__((nonnull(1)));
    extern FILE *tmpfile() __attribute__((malloc));
    extern FILE *tmpfile64() __attribute__((malloc));
    extern char *tmpnam(char[20]) noexcept(true);
    extern char *tmpnam_r(char __s[20]) noexcept(true);
    extern char *tempnam(const char *__dir, const char *__pfx) noexcept(true) __attribute__((malloc));
    extern int fflush(FILE *__stream);
    extern int fflush_unlocked(FILE *__stream);
    extern int fcloseall();
    extern FILE *fopen(const char *__restrict __filename, const char *__restrict __modes) __attribute__((malloc));
    extern FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __attribute__((nonnull(3)));
    extern FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes) __attribute__((malloc));
    extern FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __attribute__((nonnull(3)));
    extern FILE *fdopen(int __fd, const char *__modes) noexcept(true) __attribute__((malloc));
    extern FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, cookie_io_functions_t __io_funcs) noexcept(true) __attribute__((malloc));
    extern FILE *fmemopen(void *__s, size_t __len, const char *__modes) noexcept(true) __attribute__((malloc));
    extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern void setbuf(FILE *__restrict __stream, char *__restrict __buf) noexcept(true);
    extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n) noexcept(true);
    extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf, size_t __size) noexcept(true);
    extern void setlinebuf(FILE *__stream) noexcept(true);
    extern int fprintf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int printf(const char *__restrict __format, ...);
    extern int sprintf(char *__restrict __s, const char *__restrict __format, ...) noexcept(true);
    extern int vfprintf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg);
    extern int vprintf(const char *__restrict __format, __gnuc_va_list __arg);
    extern int vsprintf(char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int snprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, ...) noexcept(true) __attribute__((format(printf, 3, 4)));
    extern int vsnprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) __attribute__((format(printf, 3, 0)));
    extern int vasprintf(char **__restrict __ptr, const char *__restrict __f, __gnuc_va_list __arg) noexcept(true) __attribute__((format(printf, 2, 0)));
    extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int vdprintf(int __fd, const char *__restrict __fmt, __gnuc_va_list __arg) __attribute__((format(printf, 2, 0)));
    extern int dprintf(int __fd, const char *__restrict __fmt, ...) __attribute__((format(printf, 2, 3)));
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int scanf(const char *__restrict __format, ...);
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) noexcept(true);
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...) asm("__isoc23_fscanf");
    extern int scanf(const char *__restrict __format, ...) asm("__isoc23_scanf");
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) noexcept(true) asm("__isoc23_sscanf");
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) __attribute__((format(scanf, 2, 0)));
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) asm("__isoc23_vfscanf") __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) asm("__isoc23_vscanf") __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) asm("__isoc23_vsscanf") __attribute__((format(scanf, 2, 0)));
    extern int fgetc(FILE *__stream);
    extern int getc(FILE *__stream);
    extern int getchar();
    extern int getc_unlocked(FILE *__stream);
    extern int getchar_unlocked();
    extern int fgetc_unlocked(FILE *__stream);
    extern int fputc(int __c, FILE *__stream);
    extern int putc(int __c, FILE *__stream);
    extern int putchar(int __c);
    extern int fputc_unlocked(int __c, FILE *__stream);
    extern int putc_unlocked(int __c, FILE *__stream);
    extern int putchar_unlocked(int __c);
    extern int getw(FILE *__stream);
    extern int putw(int __w, FILE *__stream);
    extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern char *fgets_unlocked(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern __ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n, FILE *__restrict __stream);
    extern int fputs(const char *__restrict __s, FILE *__restrict __stream);
    extern int puts(const char *__s);
    extern int ungetc(int __c, FILE *__stream);
    extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s);
    extern int fputs_unlocked(const char *__restrict __s, FILE *__restrict __stream);
    extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite_unlocked(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern int fseek(FILE *__stream, long __off, int __whence);
    extern long ftell(FILE *__stream);
    extern void rewind(FILE *__stream);
    extern int fseeko(FILE *__stream, __off_t __off, int __whence);
    extern __off_t ftello(FILE *__stream);
    extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos);
    extern int fsetpos(FILE *__stream, const fpos_t *__pos);
    extern int fseeko64(FILE *__stream, __off64_t __off, int __whence);
    extern __off64_t ftello64(FILE *__stream);
    extern int fgetpos64(FILE *__restrict __stream, fpos64_t *__restrict __pos);
    extern int fsetpos64(FILE *__stream, const fpos64_t *__pos);
    extern void clearerr(FILE *__stream) noexcept(true);
    extern int feof(FILE *__stream) noexcept(true);
    extern int ferror(FILE *__stream) noexcept(true);
    extern void clearerr_unlocked(FILE *__stream) noexcept(true);
    extern int feof_unlocked(FILE *__stream) noexcept(true);
    extern int ferror_unlocked(FILE *__stream) noexcept(true);
    extern void perror(const char *__s) __attribute__((cold));
    extern int fileno(FILE *__stream) noexcept(true);
    extern int fileno_unlocked(FILE *__stream) noexcept(true);
    extern int pclose(FILE *__stream);
    extern FILE *popen(const char *__command, const char *__modes) __attribute__((malloc));
    extern char *ctermid(char *__s) noexcept(true);
    extern char *cuserid(char *__s);
    struct obstack;
    extern int obstack_printf(struct obstack *__restrict __obstack, const char *__restrict __format, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int obstack_vprintf(struct obstack *__restrict __obstack, const char *__restrict __format, __gnuc_va_list __args) noexcept(true) __attribute__((format(printf, 2, 0)));
    extern void flockfile(FILE *__stream) noexcept(true);
    extern int ftrylockfile(FILE *__stream) noexcept(true);
    extern void funlockfile(FILE *__stream) noexcept(true);
    extern int __uflow(FILE *);
    extern int __overflow(FILE *, int);
}
namespace std {
    using ::FILE;
    using ::fpos_t;
    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::fopen;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::perror;
    using ::printf;
    using ::putc;
    using ::putchar;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;
}
namespace __gnu_cxx {
    using ::snprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsnprintf;
    using ::vsscanf;
}
namespace std {
    using ::__gnu_cxx::snprintf;
    using ::__gnu_cxx::vfscanf;
    using ::__gnu_cxx::vscanf;
    using ::__gnu_cxx::vsnprintf;
    using ::__gnu_cxx::vsscanf;
}
extern "C" {
    extern int *__errno_location() noexcept(true) __attribute__((const));
    extern char *program_invocation_name;
    extern char *program_invocation_short_name;
    typedef int error_t;
}
namespace __gnu_cxx {
    template <typename _TRet, typename _Ret = _TRet, typename _CharT, typename ..._Base> _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base...), const char *__name, const _CharT *__str, std::size_t *__idx, _Base ...__base) {
        _Ret __ret;
        _CharT *__endptr;
        const struct _Save_errno {
            _Save_errno() : _M_errno((*__errno_location())) {
                (*__errno_location()) = 0;
            }
            ~_Save_errno() {
                if ((*__errno_location()) == 0)
                    (*__errno_location()) = this->_M_errno;
            }
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
            static bool _S_chk(_TRet, std::false_type) {
                return false;
            }
            static bool _S_chk(_TRet __val, std::true_type) {
                return __val < _TRet(__numeric_traits<int>::__min) || __val > _TRet(__numeric_traits<int>::__max);
            }
        };
        const _TRet __tmp = __convf(__str, &__endptr, __base...);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        int __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, char, <int>>(unsigned long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        unsigned long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, char, <int>>(long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, char, <int>>(unsigned long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base) {
        unsigned long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, char, <>>(float (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx) {
        float __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, char, <>>(double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx) {
        double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, char, <>>(long double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx) {
        long double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        int __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, wchar_t, <int>>(unsigned long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        unsigned long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, wchar_t, <int>>(long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, wchar_t, <int>>(unsigned long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base) {
        unsigned long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, wchar_t, <>>(float (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx) {
        float __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, wchar_t, <>>(double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx) {
        double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, wchar_t, <>>(long double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx) {
        long double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template <typename _String, typename _CharT = typename _String::value_type> _String __to_xstring(int (*__convf)(_CharT *, std::size_t, const _CharT *, __va_list_tag *), std::size_t __n, const _CharT *__fmt, ...) {
        _CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return _String(__s, __s + __len);
    }
    template<> std::basic_string<char> __to_xstring<std::basic_string<char>, char>(int (*__convf)(char *, std::size_t, const char *, __va_list_tag *), std::size_t __n, const char *__fmt, ...) {
        char *__s = static_cast<char *>(__builtin_alloca(sizeof(char) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::basic_string<char>(__s, __s + __len);
    }
    template<> std::basic_string<wchar_t> __to_xstring<std::basic_string<wchar_t>, wchar_t>(int (*__convf)(wchar_t *, std::size_t, const wchar_t *, __va_list_tag *), std::size_t __n, const wchar_t *__fmt, ...) {
        wchar_t *__s = static_cast<wchar_t *>(__builtin_alloca(sizeof(wchar_t) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::basic_string<wchar_t>(__s, __s + __len);
    }
}
namespace std {
    namespace __detail {
        template <typename _Tp> constexpr bool __integer_to_chars_is_unsigned = !__gnu_cxx::__int_traits<_Tp>::__is_signed;
        template <typename _Tp> constexpr unsigned int __to_chars_len(_Tp __value, int __base = 10) noexcept {
            static_assert(__integer_to_chars_is_unsigned<_Tp>, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned int>(unsigned int __value, int __base = 10) noexcept {
            static_assert(__integer_to_chars_is_unsigned<unsigned int>, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned long>(unsigned long __value, int __base = 10) noexcept {
            static_assert(__integer_to_chars_is_unsigned<unsigned long>, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned long long>(unsigned long long __value, int __base = 10) noexcept {
            static_assert(__integer_to_chars_is_unsigned<unsigned long long>, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template <typename _Tp> void __to_chars_10_impl(char *__first, unsigned int __len, _Tp __val) noexcept {
            static_assert(__integer_to_chars_is_unsigned<_Tp>, "implementation bug");
            constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned int>(char *__first, unsigned int __len, unsigned int __val) noexcept {
            static_assert(__integer_to_chars_is_unsigned<unsigned int>, "implementation bug");
            constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned long>(char *__first, unsigned int __len, unsigned long __val) noexcept {
            static_assert(__integer_to_chars_is_unsigned<unsigned long>, "implementation bug");
            constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned long long>(char *__first, unsigned int __len, unsigned long long __val) noexcept {
            static_assert(__integer_to_chars_is_unsigned<unsigned long long>, "implementation bug");
            constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        constexpr bool __integer_to_chars_is_unsigned = !__gnu_cxx::__int_traits<unsigned int>::__is_signed;
        constexpr bool __integer_to_chars_is_unsigned = !__gnu_cxx::__int_traits<unsigned long>::__is_signed;
        constexpr bool __integer_to_chars_is_unsigned = !__gnu_cxx::__int_traits<unsigned long long>::__is_signed;
    }
}
namespace std {
    inline namespace __cxx11 {
        inline int stoi(const string &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const string &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const string &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const string &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const string &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const string &__str, size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const string &__str, size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const string &__str, size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx);
        }
        inline string to_string(int __val) noexcept [[nodiscard("")]] {
            const bool __neg = __val < 0;
            const unsigned int __uval = __neg ? (unsigned int)~__val + 1U : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline string to_string(unsigned int __val) noexcept [[nodiscard("")]] {
            string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline string to_string(long __val) [[nodiscard("")]] {
            const bool __neg = __val < 0;
            const unsigned long __uval = __neg ? (unsigned long)~__val + 1UL : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline string to_string(unsigned long __val) [[nodiscard("")]] {
            string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline string to_string(long long __val) [[nodiscard("")]] {
            const bool __neg = __val < 0;
            const unsigned long long __uval = __neg ? (unsigned long long)~__val + 1ULL : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline string to_string(unsigned long long __val) [[nodiscard("")]] {
            string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline string to_string(float __val) [[nodiscard("")]] {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline string to_string(double __val) [[nodiscard("")]] {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline string to_string(long double __val) [[nodiscard("")]] {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%Lf", __val);
        }
        inline int stoi(const wstring &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const wstring &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const wstring &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const wstring &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const wstring &__str, size_t *__idx = 0, int __base = 10) {
            return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const wstring &__str, size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const wstring &__str, size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const wstring &__str, size_t *__idx = 0) {
            return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx);
        }
        inline wstring to_wstring(int __val) [[nodiscard("")]] {
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int), L"%d", __val);
        }
        inline wstring to_wstring(unsigned int __val) [[nodiscard("")]] {
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(unsigned int), L"%u", __val);
        }
        inline wstring to_wstring(long __val) [[nodiscard("")]] {
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long), L"%ld", __val);
        }
        inline wstring to_wstring(unsigned long __val) [[nodiscard("")]] {
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(unsigned long), L"%lu", __val);
        }
        inline wstring to_wstring(long long __val) [[nodiscard("")]] {
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long long), L"%lld", __val);
        }
        inline wstring to_wstring(unsigned long long __val) [[nodiscard("")]] {
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(unsigned long long), L"%llu", __val);
        }
        inline wstring to_wstring(float __val) [[nodiscard("")]] {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline wstring to_wstring(double __val) [[nodiscard("")]] {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline wstring to_wstring(long double __val) [[nodiscard("")]] {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%Lf", __val);
        }
    }
}
namespace std {
    template <typename _CharT, typename _Alloc, typename _StrT = basic_string<_CharT, char_traits<_CharT>, _Alloc>> struct __str_hash_base : public __hash_base<size_t, _StrT> {
        size_t operator()(const _StrT &__s) const noexcept [[nodiscard("")]] {
            return _Hash_impl::hash(__s.data(), __s.length() * sizeof(_CharT));
        }
    };
    template <typename _Alloc> struct hash<basic_string<char, char_traits<char>, _Alloc>> : public __str_hash_base<char, _Alloc> {
    };
    template <typename _Alloc> struct hash<basic_string<wchar_t, char_traits<wchar_t>, _Alloc>> : public __str_hash_base<wchar_t, _Alloc> {
    };
    template <typename _Alloc> struct __is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, _Alloc>>> : std::false_type {
    };
    template <typename _Alloc> struct hash<basic_string<char8_t, char_traits<char8_t>, _Alloc>> : public __str_hash_base<char8_t, _Alloc> {
    };
    template <typename _Alloc> struct hash<basic_string<char16_t, char_traits<char16_t>, _Alloc>> : public __str_hash_base<char16_t, _Alloc> {
    };
    template <typename _Alloc> struct hash<basic_string<char32_t, char_traits<char32_t>, _Alloc>> : public __str_hash_base<char32_t, _Alloc> {
    };
    template<> struct __is_fast_hash<hash<string>> : std::false_type {
    };
    template<> struct __is_fast_hash<hash<wstring>> : std::false_type {
    };
    template<> struct __is_fast_hash<hash<u16string>> : std::false_type {
    };
    template<> struct __is_fast_hash<hash<u32string>> : std::false_type {
    };
    template<> struct __is_fast_hash<hash<u8string>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_literals {
            inline constexpr basic_string<char> operator""s(const char *__str, size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<char>{__str, __len};
            }
            inline constexpr basic_string<wchar_t> operator""s(const wchar_t *__str, size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<wchar_t>{__str, __len};
            }
            inline constexpr basic_string<char8_t> operator""s(const char8_t *__str, size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<char8_t>{__str, __len};
            }
            inline constexpr basic_string<char16_t> operator""s(const char16_t *__str, size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<char16_t>{__str, __len};
            }
            inline constexpr basic_string<char32_t> operator""s(const char32_t *__str, size_t __len) __attribute__((abi_tag("cxx11"))) {
                return basic_string<char32_t>{__str, __len};
            }
        }
    }
    namespace __detail {
        namespace __variant {
            template <typename> struct _Never_valueless_alt;
            template <typename _Tp, typename _Traits, typename _Alloc> struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>> : __and_<is_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>, is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>>::type {
            };
        }
    }
}
namespace std {
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type npos;
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept {
        if (this == std::__addressof(__s))
            return;
        _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());
        if (this->_M_is_local())
            if (__s._M_is_local()) {
                if (this->length() && __s.length()) {
                    _CharT __tmp_data[_S_local_capacity + 1];
                    traits_type::copy(__tmp_data, __s._M_local_buf, __s.length() + 1);
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                    traits_type::copy(this->_M_local_buf, __tmp_data, __s.length() + 1);
                } else if (__s.length()) {
                    traits_type::copy(this->_M_local_buf, __s._M_local_buf, __s.length() + 1);
                    this->_M_length(__s.length());
                    __s._M_set_length(0);
                    return;
                } else if (this->length()) {
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                    __s._M_length(this->length());
                    this->_M_set_length(0);
                    return;
                }
            } else {
                const size_type __tmp_capacity = __s._M_allocated_capacity;
                traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                _M_data(__s._M_data());
                __s._M_data(__s._M_local_buf);
                this->_M_capacity(__tmp_capacity);
            }
        else {
            const size_type __tmp_capacity = this->_M_allocated_capacity;
            if (__s._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __s._M_local_buf, __s.length() + 1);
                __s._M_data(_M_data());
                _M_data(this->_M_local_buf);
            } else {
                pointer __tmp_ptr = _M_data();
                _M_data(__s._M_data());
                __s._M_data(__tmp_ptr);
                this->_M_capacity(__s._M_allocated_capacity);
            }
            __s._M_capacity(__tmp_capacity);
        }
        const size_type __tmp_length = this->length();
        this->_M_length(__s.length());
        __s._M_length(__tmp_length);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::pointer basic_string<_CharT, _Traits, _Alloc>::_M_create(size_type &__capacity, size_type __old_capacity) {
        if (__capacity > this->max_size())
            std::__throw_length_error(("basic_string::_M_create"));
        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
            __capacity = 2 * __old_capacity;
            if (__capacity > this->max_size())
                __capacity = this->max_size();
        }
        return _S_allocate(_M_get_allocator(), __capacity + 1);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag) {
        size_type __len = 0;
        size_type __capacity = size_type(_S_local_capacity);
        pointer __p = this->_M_use_local_data();
        while (__beg != __end && __len < __capacity)
            {
                __p[__len++] = *__beg;
                ++__beg;
            }
        struct _Guard {
            constexpr explicit _Guard(basic_string<_CharT, _Traits, _Alloc> *__s) : _M_guarded(__s) {
            }
            constexpr ~_Guard() {
                if (this->_M_guarded)
                    this->_M_guarded->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> *_M_guarded;
        } __guard(this);
        while (__beg != __end)
            {
                if (__len == __capacity) {
                    __capacity = __len + 1;
                    pointer __another = this->_M_create(__capacity, __len);
                    this->_S_copy(__another, _M_data(), __len);
                    this->_M_dispose();
                    _M_data(__another);
                    this->_M_capacity(__capacity);
                }
                traits_type::assign(_M_data()[__len++], *__beg);
                ++__beg;
            }
        __guard._M_guarded = 0;
        this->_M_set_length(__len);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::forward_iterator_tag) {
        size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
        if (__dnew > size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__dnew, size_type(0)));
            this->_M_capacity(__dnew);
        } else
            this->_M_use_local_data();
        struct _Guard {
            constexpr explicit _Guard(basic_string<_CharT, _Traits, _Alloc> *__s) : _M_guarded(__s) {
            }
            constexpr ~_Guard() {
                if (this->_M_guarded)
                    this->_M_guarded->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> *_M_guarded;
        } __guard(this);
        this->_S_copy_chars(_M_data(), __beg, __end);
        __guard._M_guarded = 0;
        this->_M_set_length(__dnew);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(size_type __n, _CharT __c) {
        if (__n > size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__n, size_type(0)));
            this->_M_capacity(__n);
        } else
            this->_M_use_local_data();
        if (__n)
            this->_S_assign(_M_data(), __n, __c);
        this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_assign(const basic_string<_CharT, _Traits, _Alloc> &__str) {
        if (this != std::__addressof(__str)) {
            const size_type __rsize = __str.length();
            const size_type __capacity = this->capacity();
            if (__rsize > __capacity) {
                size_type __new_capacity = __rsize;
                pointer __tmp = this->_M_create(__new_capacity, __capacity);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__new_capacity);
            }
            if (__rsize)
                this->_S_copy(_M_data(), __str._M_data(), __rsize);
            this->_M_set_length(__rsize);
        }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::reserve(size_type __res) {
        const size_type __capacity = this->capacity();
        if (__res <= __capacity)
            return;
        pointer __tmp = this->_M_create(__res, __capacity);
        this->_S_copy(__tmp, _M_data(), this->length() + 1);
        this->_M_dispose();
        _M_data(__tmp);
        this->_M_capacity(__res);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(size_type __pos, size_type __len1, const _CharT *__s, size_type __len2) {
        const size_type __how_much = this->length() - __pos - __len1;
        size_type __new_capacity = this->length() + __len2 - __len1;
        pointer __r = this->_M_create(__new_capacity, this->capacity());
        if (__pos)
            this->_S_copy(__r, _M_data(), __pos);
        if (__s && __len2)
            this->_S_copy(__r + __pos, __s, __len2);
        if (__how_much)
            this->_S_copy(__r + __pos + __len2, _M_data() + __pos + __len1, __how_much);
        this->_M_dispose();
        _M_data(__r);
        this->_M_capacity(__new_capacity);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_erase(size_type __pos, size_type __n) {
        const size_type __how_much = this->length() - __pos - __n;
        if (__how_much && __n)
            this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
        this->_M_set_length(this->length() - __n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::reserve() {
        if (this->_M_is_local())
            return;
        const size_type __length = this->length();
        const size_type __capacity = this->_M_allocated_capacity;
        if (__length <= size_type(_S_local_capacity)) {
            this->_S_copy(this->_M_use_local_data(), _M_data(), __length + 1);
            this->_M_destroy(__capacity);
            _M_data(_M_local_data());
        } else if (__length < __capacity)
            try {
                pointer __tmp = _S_allocate(_M_get_allocator(), __length + 1);
                this->_S_copy(__tmp, _M_data(), __length + 1);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__length);
            } catch (const __cxxabiv1::__forced_unwind &) {
                throw;
            } catch (...) {
            }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n, _CharT __c) {
        const size_type __size = this->size();
        if (__size < __n)
            this->append(__n - __size, __c);
        else if (__n < __size)
            this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s, size_type __n) {
        const size_type __len = __n + this->size();
        if (__len <= this->capacity()) {
            if (__n)
                this->_S_copy(this->_M_data() + this->size(), __s, __n);
        } else
            this->_M_mutate(this->size(), size_type(0), __s, __n);
        this->_M_set_length(__len);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InputIterator> constexpr basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type) {
        const basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2, this->get_allocator());
        const size_type __n1 = __i2 - __i1;
        return this->_M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c) {
        this->_M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
        const size_type __old_size = this->size();
        const size_type __new_size = __old_size + __n2 - __n1;
        if (__new_size <= this->capacity()) {
            pointer __p = this->_M_data() + __pos1;
            const size_type __how_much = __old_size - __pos1 - __n1;
            if (__how_much && __n1 != __n2)
                this->_S_move(__p + __n2, __p + __n1, __how_much);
        } else
            this->_M_mutate(__pos1, __n1, 0, __n2);
        if (__n2)
            this->_S_assign(this->_M_data() + __pos1, __n2, __c);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_replace_cold(pointer __p, size_type __len1, const _CharT *__s, const size_type __len2, const size_type __how_much) __attribute__((noinline)) __attribute__((cold)) {
        if (__len2 && __len2 <= __len1)
            this->_S_move(__p, __s, __len2);
        if (__how_much && __len1 != __len2)
            this->_S_move(__p + __len2, __p + __len1, __how_much);
        if (__len2 > __len1) {
            if (__s + __len2 <= __p + __len1)
                this->_S_move(__p, __s, __len2);
            else if (__s >= __p + __len1) {
                const size_type __poff = (__s - __p) + (__len2 - __len1);
                this->_S_copy(__p, __p + __poff, __len2);
            } else {
                const size_type __nleft = (__p + __len1) - __s;
                this->_S_move(__p, __s, __nleft);
                this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
            }
        }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace(size_type __pos, size_type __len1, const _CharT *__s, const size_type __len2) {
        this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
        const size_type __old_size = this->size();
        const size_type __new_size = __old_size + __len2 - __len1;
        if (__new_size <= this->capacity()) {
            pointer __p = this->_M_data() + __pos;
            const size_type __how_much = __old_size - __pos - __len1;
            if (std::is_constant_evaluated()) {
                auto __newp = _S_allocate(_M_get_allocator(), __new_size);
                _S_copy(__newp, this->_M_data(), __pos);
                _S_copy(__newp + __pos, __s, __len2);
                _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
                _S_copy(this->_M_data(), __newp, __new_size);
                this->_M_get_allocator().deallocate(__newp, __new_size);
            } else if (__builtin_expect(this->_M_disjunct(__s), true)) {
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2)
                    this->_S_copy(__p, __s, __len2);
            } else
                this->_M_replace_cold(__p, __len1, __s, __len2, __how_much);
        } else
            this->_M_mutate(__pos, __len1, __s, __len2);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, size_type __n, size_type __pos = 0) const {
        this->_M_check(__pos, "basic_string::copy");
        __n = this->_M_limit(__pos, __n);
        ;
        if (__n)
            _S_copy(__s, _M_data() + __pos, __n);
        return __n;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, size_type __pos, size_type __n) const noexcept {
        ;
        const size_type __size = this->size();
        if (__n == 0)
            return __pos <= __size ? __pos : npos;
        if (__pos >= __size)
            return npos;
        const _CharT __elem0 = __s[0];
        const _CharT *const __data = data();
        const _CharT *__first = __data + __pos;
        const _CharT *const __last = __data + __size;
        size_type __len = __size - __pos;
        while (__len >= __n)
            {
                __first = traits_type::find(__first, __len - __n + 1, __elem0);
                if (!__first)
                    return npos;
                if (traits_type::compare(__first, __s, __n) == 0)
                    return __first - __data;
                __len = __last - ++__first;
            }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, size_type __pos = 0) const noexcept {
        size_type __ret = npos;
        const size_type __size = this->size();
        if (__pos < __size) {
            const _CharT *__data = _M_data();
            const size_type __n = __size - __pos;
            const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
            if (__p)
                __ret = __p - __data;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, size_type __pos, size_type __n) const noexcept {
        ;
        const size_type __size = this->size();
        if (__n <= __size) {
            __pos = std::min(size_type(__size - __n), __pos);
            const _CharT *__data = _M_data();
            do {
                if (traits_type::compare(__data + __pos, __s, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, size_type __pos = npos) const noexcept {
        size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(_M_data()[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept {
        ;
        for (; __n && __pos < this->size(); ++__pos) {
            const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept {
        ;
        size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept {
        ;
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::find(__s, __n, _M_data()[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept {
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::eq(_M_data()[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept {
        ;
        size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept {
        size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(_M_data()[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        typedef ctype<_CharT> __ctype_type;
        typedef typename __ctype_type::ctype_base __ctype_base;
        __size_type __extracted = 0;
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                __str.erase();
                _CharT __buf[128];
                __size_type __len = 0;
                const streamsize __w = __in.width();
                const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        if (__len == sizeof (__buf) / sizeof(_CharT)) {
                            __str.append(__buf, sizeof (__buf) / sizeof(_CharT));
                            __len = 0;
                        }
                        __buf[__len++] = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                __str.append(__buf, __len);
                if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        __size_type __extracted = 0;
        const __size_type __n = __str.max_size();
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            try {
                __str.erase();
                const __int_type __idelim = _Traits::to_int_type(__delim);
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !_Traits::eq_int_type(__c, __idelim))
                    {
                        __str += _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                else if (_Traits::eq_int_type(__c, __idelim)) {
                    ++__extracted;
                    __in.rdbuf()->sbumpc();
                } else
                    __err |= __ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
}
typedef long ptrdiff_t;
typedef unsigned long size_t;
typedef unsigned long rsize_t;
extern "C++" {
    namespace std {
        using ::max_align_t;
    }
    namespace std {
        enum class byte : unsigned char {
        };
        template <typename _IntegerType> struct __byte_operand {
        };
        template<> struct __byte_operand<bool> {
            using __type = byte;
        };
        template<> struct __byte_operand<char> {
            using __type = byte;
        };
        template<> struct __byte_operand<signed char> {
            using __type = byte;
        };
        template<> struct __byte_operand<unsigned char> {
            using __type = byte;
        };
        template<> struct __byte_operand<wchar_t> {
            using __type = byte;
        };
        template<> struct __byte_operand<char8_t> {
            using __type = byte;
        };
        template<> struct __byte_operand<char16_t> {
            using __type = byte;
        };
        template<> struct __byte_operand<char32_t> {
            using __type = byte;
        };
        template<> struct __byte_operand<short> {
            using __type = byte;
        };
        template<> struct __byte_operand<unsigned short> {
            using __type = byte;
        };
        template<> struct __byte_operand<int> {
            using __type = byte;
        };
        template<> struct __byte_operand<unsigned int> {
            using __type = byte;
        };
        template<> struct __byte_operand<long> {
            using __type = byte;
        };
        template<> struct __byte_operand<unsigned long> {
            using __type = byte;
        };
        template<> struct __byte_operand<long long> {
            using __type = byte;
        };
        template<> struct __byte_operand<unsigned long long> {
            using __type = byte;
        };
        template <typename _IntegerType> struct __byte_operand<const _IntegerType> : __byte_operand<_IntegerType> {
        };
        template <typename _IntegerType> struct __byte_operand<volatile _IntegerType> : __byte_operand<_IntegerType> {
        };
        template <typename _IntegerType> struct __byte_operand<const volatile _IntegerType> : __byte_operand<_IntegerType> {
        };
        template <typename _IntegerType> using __byte_op_t = typename __byte_operand<_IntegerType>::__type;
        template <typename _IntegerType> constexpr __byte_op_t<_IntegerType> operator<<(byte __b, _IntegerType __shift) noexcept [[gnu::always_inline]] {
            return (byte)(unsigned char)((unsigned int)__b << __shift);
        }
        template <typename _IntegerType> constexpr __byte_op_t<_IntegerType> operator>>(byte __b, _IntegerType __shift) noexcept [[gnu::always_inline]] {
            return (byte)(unsigned char)((unsigned int)__b >> __shift);
        }
        constexpr byte operator|(byte __l, byte __r) noexcept [[gnu::always_inline]] {
            return (byte)(unsigned char)((unsigned int)__l | (unsigned int)__r);
        }
        constexpr byte operator&(byte __l, byte __r) noexcept [[gnu::always_inline]] {
            return (byte)(unsigned char)((unsigned int)__l & (unsigned int)__r);
        }
        constexpr byte operator^(byte __l, byte __r) noexcept [[gnu::always_inline]] {
            return (byte)(unsigned char)((unsigned int)__l ^ (unsigned int)__r);
        }
        constexpr byte operator~(byte __b) noexcept [[gnu::always_inline]] {
            return (byte)(unsigned char)~(unsigned int)__b;
        }
        template <typename _IntegerType> constexpr __byte_op_t<_IntegerType> &operator<<=(byte &__b, _IntegerType __shift) noexcept [[gnu::always_inline]] {
            return __b = __b << __shift;
        }
        template <typename _IntegerType> constexpr __byte_op_t<_IntegerType> &operator>>=(byte &__b, _IntegerType __shift) noexcept [[gnu::always_inline]] {
            return __b = __b >> __shift;
        }
        constexpr byte &operator|=(byte &__l, byte __r) noexcept [[gnu::always_inline]] {
            return __l = __l | __r;
        }
        constexpr byte &operator&=(byte &__l, byte __r) noexcept [[gnu::always_inline]] {
            return __l = __l & __r;
        }
        constexpr byte &operator^=(byte &__l, byte __r) noexcept [[gnu::always_inline]] {
            return __l = __l ^ __r;
        }
        template <typename _IntegerType> constexpr _IntegerType to_integer(__byte_op_t<_IntegerType> __b) noexcept [[nodiscard("")]] [[gnu::always_inline]] {
            return _IntegerType(__b);
        }
    }
}
namespace std {
    struct __erased_type {
    };
    template <typename _Alloc, typename _Tp> using __is_erased_or_convertible = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;
    struct allocator_arg_t {
        explicit allocator_arg_t() noexcept = default
    };
    constexpr allocator_arg_t allocator_arg = allocator_arg_t();
    template <typename _Tp, typename _Alloc, typename = __void_t<>> struct __uses_allocator_helper : false_type {
    };
    template <typename _Tp, typename _Alloc> struct __uses_allocator_helper<_Tp, _Alloc, __void_t<typename _Tp::allocator_type>> : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type {
    };
    template <typename _Tp, typename _Alloc> struct uses_allocator : __uses_allocator_helper<_Tp, _Alloc>::type {
    };
    struct __uses_alloc_base {
    };
    struct __uses_alloc0 : __uses_alloc_base {
        struct _Sink {
            constexpr void operator=(const void *) {
            }
        } _M_a;
    };
    template <typename _Alloc> struct __uses_alloc1 : __uses_alloc_base {
        const _Alloc *_M_a;
    };
    template <typename _Alloc> struct __uses_alloc2 : __uses_alloc_base {
        const _Alloc *_M_a;
    };
    template <bool, typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc;
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc<true, _Tp, _Alloc, _Args...> : __conditional_t<is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>::value, __uses_alloc1<_Alloc>, __uses_alloc2<_Alloc>> {
        static_assert(__or_<is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>, is_constructible<_Tp, _Args..., const _Alloc &>>::value, "construction with an allocator must be possible if uses_allocator is true");
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc<false, _Tp, _Alloc, _Args...> : __uses_alloc0 {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> using __uses_alloc_t = __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;
    template <typename _Tp, typename _Alloc, typename ..._Args> inline constexpr __uses_alloc_t<_Tp, _Alloc, _Args...> __use_alloc(const _Alloc &__a) {
        __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
        __ret._M_a = std::__addressof(__a);
        return __ret;
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __use_alloc(const _Alloc &&) = delete
    template <typename _Tp, typename _Alloc> constexpr bool uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;
    template <template <typename ...> class _Predicate, typename _Tp, typename _Alloc, typename ..._Args> struct __is_uses_allocator_predicate : __conditional_t<uses_allocator<_Tp, _Alloc>::value, __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>, _Predicate<_Tp, _Args..., _Alloc>>, _Predicate<_Tp, _Args...>> {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __is_uses_allocator_constructible : __is_uses_allocator_predicate<std::is_constructible, _Tp, _Alloc, _Args...> {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr bool __is_uses_allocator_constructible_v = __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __is_nothrow_uses_allocator_constructible : __is_uses_allocator_predicate<std::is_nothrow_constructible, _Tp, _Alloc, _Args...> {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr bool __is_nothrow_uses_allocator_constructible_v = __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;
    template <typename _Tp, typename ..._Args> void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp *__ptr, _Args &&...__args) {
        ::new ((void *)__ptr) _Tp(std::forward<_Args>(__args)...);
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp *__ptr, _Args &&...__args) {
        ::new ((void *)__ptr) _Tp(allocator_arg, *__a._M_a, std::forward<_Args>(__args)...);
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp *__ptr, _Args &&...__args) {
        ::new ((void *)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a);
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct(const _Alloc &__a, _Tp *__ptr, _Args &&...__args) {
        std::__uses_allocator_construct_impl(std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr, std::forward<_Args>(__args)...);
    }
}
namespace std {
    namespace ranges {
        namespace __detail {
            template <typename _Range> concept __simple_view = view<_Range> && range<const _Range> && same_as<iterator_t<_Range>, iterator_t<const _Range>> && same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;
            template <typename _It> concept __has_arrow = input_iterator<_It> && (is_pointer_v<_It> || requires (_It __it) { __it.operator->(); });
            using std::__detail::__different_from;
        }
        template <typename _Derived> class view_interface {
        private:
            constexpr _Derived &_M_derived() noexcept {
                static_assert(derived_from<_Derived, view_interface<_Derived>>);
                static_assert(view<_Derived>);
                return static_cast<_Derived &>(*this);
            }
            constexpr const _Derived &_M_derived() const noexcept {
                static_assert(derived_from<_Derived, view_interface<_Derived>>);
                static_assert(view<_Derived>);
                return static_cast<const _Derived &>(*this);
            }
            static constexpr bool _S_bool(bool) noexcept;
            template <typename _Tp> static constexpr bool _S_empty(_Tp &__t) noexcept(noexcept(_S_bool(ranges::begin(__t) == ranges::end(__t)))) {
                return ranges::begin(__t) == ranges::end(__t);
            }
            template <typename _Tp> static constexpr auto _S_size(_Tp &__t) noexcept(noexcept(ranges::end(__t) - ranges::begin(__t))) {
                return ranges::end(__t) - ranges::begin(__t);
            }
        public:
            constexpr bool empty() noexcept(noexcept(_S_empty(_M_derived()))) requires forward_range<_Derived> && (!sized_range<_Derived>) {
                return _S_empty(_M_derived());
            }
            constexpr bool empty() noexcept(noexcept(ranges::size(_M_derived()) == 0)) requires sized_range<_Derived> {
                return ranges::size(_M_derived()) == 0;
            }
            constexpr bool empty() const noexcept(noexcept(_S_empty(_M_derived()))) requires forward_range<const _Derived> && (!sized_range<const _Derived>) {
                return _S_empty(_M_derived());
            }
            constexpr bool empty() const noexcept(noexcept(ranges::size(_M_derived()) == 0)) requires sized_range<const _Derived> {
                return ranges::size(_M_derived()) == 0;
            }
            constexpr explicit operator bool() noexcept(noexcept(ranges::empty(_M_derived()))) requires requires { ranges::empty(_M_derived()); } {
                return !ranges::empty(_M_derived());
            }
            constexpr explicit operator bool() const noexcept(noexcept(ranges::empty(_M_derived()))) requires requires { ranges::empty(_M_derived()); } {
                return !ranges::empty(_M_derived());
            }
            constexpr auto data() noexcept(noexcept(ranges::begin(_M_derived()))) requires contiguous_iterator<iterator_t<_Derived>> {
                return std::to_address(ranges::begin(_M_derived()));
            }
            constexpr auto data() const noexcept(noexcept(ranges::begin(_M_derived()))) requires range<const _Derived> && contiguous_iterator<iterator_t<const _Derived>> {
                return std::to_address(ranges::begin(_M_derived()));
            }
            constexpr auto size() noexcept(noexcept(_S_size(_M_derived()))) requires forward_range<_Derived> && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>> {
                return _S_size(_M_derived());
            }
            constexpr auto size() const noexcept(noexcept(_S_size(_M_derived()))) requires forward_range<const _Derived> && sized_sentinel_for<sentinel_t<const _Derived>, iterator_t<const _Derived>> {
                return _S_size(_M_derived());
            }
            constexpr decltype(auto) front() requires forward_range<_Derived> {
                do {
                    if (std::__is_constant_evaluated() && !bool(!empty()))
                        __builtin_unreachable();
                } while (false);
                return *ranges::begin(_M_derived());
            }
            constexpr decltype(auto) front() const requires forward_range<const _Derived> {
                do {
                    if (std::__is_constant_evaluated() && !bool(!empty()))
                        __builtin_unreachable();
                } while (false);
                return *ranges::begin(_M_derived());
            }
            constexpr decltype(auto) back() requires bidirectional_range<_Derived> && common_range<_Derived> {
                do {
                    if (std::__is_constant_evaluated() && !bool(!empty()))
                        __builtin_unreachable();
                } while (false);
                return *ranges::prev(ranges::end(_M_derived()));
            }
            constexpr decltype(auto) back() const requires bidirectional_range<const _Derived> && common_range<const _Derived> {
                do {
                    if (std::__is_constant_evaluated() && !bool(!empty()))
                        __builtin_unreachable();
                } while (false);
                return *ranges::prev(ranges::end(_M_derived()));
            }
            template <random_access_range _Range = _Derived> constexpr decltype(auto) operator[](range_difference_t<_Range> __n) {
                return ranges::begin(_M_derived())[__n];
            }
            template <random_access_range _Range = const _Derived> constexpr decltype(auto) operator[](range_difference_t<_Range> __n) const {
                return ranges::begin(_M_derived())[__n];
            }
        };
        namespace __detail {
            template <typename _From, typename _To> concept __uses_nonqualification_pointer_conversion = is_pointer_v<_From> && is_pointer_v<_To> && !convertible_to<remove_pointer_t<_From> (*)[], remove_pointer_t<_To> (*)[]>;
            template <typename _From, typename _To> concept __convertible_to_non_slicing = convertible_to<_From, _To> && !__uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;
            template <typename _Tp> concept __pair_like = !is_reference_v<_Tp> && requires (_Tp __t) { typename tuple_size<_Tp>::type; requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>; typename tuple_element_t<0, remove_const_t<_Tp>>; typename tuple_element_t<1, remove_const_t<_Tp>>; { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp> &>; { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp> &>; };
            template <typename _Tp, typename _Up, typename _Vp> concept __pair_like_convertible_from = !range<_Tp> && __pair_like<_Tp> && constructible_from<_Tp, _Up, _Vp> && __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>> && convertible_to<_Vp, tuple_element_t<1, _Tp>>;
        }
        namespace views {
            struct _Drop;
        }
        enum class subrange_kind : bool {
            unsized,
            sized
        };
        template <input_or_output_iterator _It, sentinel_for<_It> _Sent = _It, subrange_kind _Kind = sized_sentinel_for<_Sent, _It> ? subrange_kind::sized : subrange_kind::unsized> class subrange : public view_interface<subrange<_It, _Sent, _Kind>> {
        private:
            static constexpr bool _S_store_size = _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;
            friend  struct views::_Drop;
            _It _M_begin = _It();
            _Sent _M_end = _Sent() [[no_unique_address]];
            using __size_type = __detail::__make_unsigned_like_t<iter_difference_t<_It>>;
            template <typename, bool = _S_store_size> struct _Size {
            };
            template <typename _Tp> struct _Size<_Tp, true> {
                _Tp _M_size;
            };
            _Size<__size_type> _M_size = {} [[no_unique_address]];
        public:
            subrange<_It, _Sent, _Kind>() requires default_initializable<_It> = default
            template <> constexpr subrange<_It, _Sent, _Kind>(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s) noexcept(is_nothrow_constructible_v<_It, decltype(__i)> && is_nothrow_constructible_v<_Sent, _Sent &>) : _M_begin(std::move(__i)), _M_end(__s) requires (!_S_store_size) {
            }
            template <> constexpr subrange<_It, _Sent, _Kind>(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s, __size_type __n) noexcept(is_nothrow_constructible_v<_It, decltype(__i)> && is_nothrow_constructible_v<_Sent, _Sent &>) : _M_begin(std::move(__i)), _M_end(__s) requires (_Kind == subrange_kind::sized) {
                if (_S_store_size)
                    this->_M_size._M_size = __n;
            }
            template <__detail::__different_from<subrange<_It, _Sent, _Kind>> _Rng> constexpr subrange<_It, _Sent, _Kind>(_Rng &&__r) noexcept(noexcept(subrange<_It, _Sent, _Kind>(__r, ranges::size(__r)))) : subrange<_It, _Sent, _Kind>(__r, ranges::size(__r)) requires _S_store_size && sized_range<_Rng> {
            }
            template <__detail::__different_from<subrange<_It, _Sent, _Kind>> _Rng> constexpr subrange<_It, _Sent, _Kind>(_Rng &&__r) noexcept(noexcept(subrange<_It, _Sent, _Kind>(ranges::begin(__r), ranges::end(__r)))) : subrange<_It, _Sent, _Kind>(ranges::begin(__r), ranges::end(__r)) requires (!_S_store_size) {
            }
            template <borrowed_range _Rng> constexpr subrange<_It, _Sent, _Kind>(_Rng &&__r, __size_type __n) noexcept(noexcept(subrange<_It, _Sent, _Kind>(ranges::begin(__r), ranges::end(__r), __n))) : subrange<_It, _Sent, _Kind>({ranges::begin(__r), ranges::end(__r), __n}) requires (_Kind == subrange_kind::sized) {
            }
            template <__detail::__different_from<subrange<_It, _Sent, _Kind>> _PairLike> constexpr operator _PairLike() const {
                return _PairLike(this->_M_begin, this->_M_end);
            }
            constexpr _It begin() const requires copyable<_It> {
                return this->_M_begin;
            }
            constexpr _It begin() requires (!copyable<_It>) [[nodiscard("")]] {
                return std::move(this->_M_begin);
            }
            constexpr _Sent end() const {
                return this->_M_end;
            }
            constexpr bool empty() const {
                return this->_M_begin == this->_M_end;
            }
            constexpr __size_type size() const requires (_Kind == subrange_kind::sized) {
                if (_S_store_size)
                    return this->_M_size._M_size;
                else
                    return __detail::__to_unsigned_like(this->_M_end - this->_M_begin);
            }
            constexpr subrange<_It, _Sent, _Kind> next(iter_difference_t<_It> __n = 1) const & requires forward_iterator<_It> [[nodiscard("")]] {
                auto __tmp = *this;
                __tmp.advance(__n);
                return __tmp;
            }
            constexpr subrange<_It, _Sent, _Kind> next(iter_difference_t<_It> __n = 1) && [[nodiscard("")]] {
                this->advance(__n);
                return std::move(*this);
            }
            constexpr subrange<_It, _Sent, _Kind> prev(iter_difference_t<_It> __n = 1) const requires bidirectional_iterator<_It> [[nodiscard("")]] {
                auto __tmp = *this;
                __tmp.advance(- __n);
                return __tmp;
            }
            constexpr subrange<_It, _Sent, _Kind> &advance(iter_difference_t<_It> __n) {
                if (bidirectional_iterator<_It>)
                    if (__n < 0) {
                        ranges::advance(this->_M_begin, __n);
                        if (_S_store_size)
                            this->_M_size._M_size += __detail::__to_unsigned_like(- __n);
                        return *this;
                    }
                do {
                    if (std::__is_constant_evaluated() && !bool(__n >= 0))
                        __builtin_unreachable();
                } while (false);
                auto __d = __n - ranges::advance(this->_M_begin, __n, this->_M_end);
                if (_S_store_size)
                    this->_M_size._M_size -= __detail::__to_unsigned_like(__d);
                return *this;
            }
        };
        template <input_or_output_iterator _It, sentinel_for<_It> _Sent> subrange(_It, _Sent) -> subrange<_It, _Sent>;
        template <input_or_output_iterator _It, sentinel_for<_It> _Sent> subrange(_It, _Sent, __detail::__make_unsigned_like_t<iter_difference_t<_It>>) -> subrange<_It, _Sent, subrange_kind::sized>;
        template <borrowed_range _Rng> subrange(_Rng &&) -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, (sized_range<_Rng> || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>) ? subrange_kind::sized : subrange_kind::unsized>;
        template <borrowed_range _Rng> subrange(_Rng &&, __detail::__make_unsigned_like_t<range_difference_t<_Rng>>) -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;
        template <size_t _Num, class _It, class _Sent, subrange_kind _Kind> constexpr auto get(const subrange<_It, _Sent, _Kind> &__r) {
            if (_Num == 0)
                return __r.begin();
            else
                return __r.end();
        }
        template <size_t _Num, class _It, class _Sent, subrange_kind _Kind> constexpr auto get(subrange<_It, _Sent, _Kind> &&__r) {
            if (_Num == 0)
                return __r.begin();
            else
                return __r.end();
        }
        constexpr bool enable_borrowed_range = true;
        template <range _Range> using borrowed_subrange_t = __conditional_t<borrowed_range<_Range>, subrange<iterator_t<_Range>>, dangling>;
    }
    namespace ranges {
        struct __find_fn {
            template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp, typename _Proj = identity> constexpr _Iter operator()(_Iter __first, _Sent __last, const _Tp &__value, _Proj __proj = {}) const {
                while (__first != __last && !(std::__invoke(__proj, *__first) == __value))
                    ++__first;
                return __first;
            }
            template <input_range _Range, typename _Tp, typename _Proj = identity> constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r, const _Tp &__value, _Proj __proj = {}) const {
                return (*this)(ranges::begin(__r), ranges::end(__r), __value, std::move(__proj));
            }
        };
        constexpr __find_fn find{};
        struct __find_if_fn {
            template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Proj = identity, indirect_unary_predicate<projected<_Iter, _Proj>> _Pred> constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
                while (__first != __last && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
                    ++__first;
                return __first;
            }
            template <input_range _Range, typename _Proj = identity, indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred> constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r, _Pred __pred, _Proj __proj = {}) const {
                return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred), std::move(__proj));
            }
        };
        constexpr __find_if_fn find_if{};
        struct __find_if_not_fn {
            template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Proj = identity, indirect_unary_predicate<projected<_Iter, _Proj>> _Pred> constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
                while (__first != __last && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
                    ++__first;
                return __first;
            }
            template <input_range _Range, typename _Proj = identity, indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred> constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r, _Pred __pred, _Proj __proj = {}) const {
                return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred), std::move(__proj));
            }
        };
        constexpr __find_if_not_fn find_if_not{};
        template <typename _Iter1, typename _Iter2> struct in_in_result {
            _Iter1 in1 [[no_unique_address]];
            _Iter2 in2 [[no_unique_address]];
            template <typename _IIter1, typename _IIter2> constexpr operator in_in_result<_IIter1, _IIter2>() const & {
                return {this->in1, this->in2};
            }
            template <typename _IIter1, typename _IIter2> constexpr operator in_in_result<_IIter1, _IIter2>() && {
                return {std::move(this->in1), std::move(this->in2)};
            }
        };
        template <typename _Iter1, typename _Iter2> using mismatch_result = in_in_result<_Iter1, _Iter2>;
        struct __mismatch_fn {
            template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1, input_iterator _Iter2, sentinel_for<_Iter2> _Sent2, typename _Pred = ranges::equal_to, typename _Proj1 = identity, typename _Proj2 = identity> constexpr mismatch_result<_Iter1, _Iter2> operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
                while (__first1 != __last1 && __first2 != __last2 && (bool)std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
                    {
                        ++__first1;
                        ++__first2;
                    }
                return {std::move(__first1), std::move(__first2)};
            }
            template <input_range _Range1, input_range _Range2, typename _Pred = ranges::equal_to, typename _Proj1 = identity, typename _Proj2 = identity> constexpr mismatch_result<iterator_t<_Range1>, iterator_t<_Range2>> operator()(_Range1 &&__r1, _Range2 &&__r2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
                return (*this)(ranges::begin(__r1), ranges::end(__r1), ranges::begin(__r2), ranges::end(__r2), std::move(__pred), std::move(__proj1), std::move(__proj2));
            }
        };
        constexpr __mismatch_fn mismatch{};
        struct __search_fn {
            template <forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1, forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2, typename _Pred = ranges::equal_to, typename _Proj1 = identity, typename _Proj2 = identity> constexpr subrange<_Iter1> operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
                if (__first1 == __last1 || __first2 == __last2)
                    return {__first1, __first1};
                for (;;) {
                    for (;;) {
                        if (__first1 == __last1)
                            return {__first1, __first1};
                        if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
                            break;
                        ++__first1;
                    }
                    auto __cur1 = __first1;
                    auto __cur2 = __first2;
                    for (;;) {
                        if (++__cur2 == __last2)
                            return {__first1, ++__cur1};
                        if (++__cur1 == __last1)
                            return {__cur1, __cur1};
                        if (!(bool)std::__invoke(__pred, std::__invoke(__proj1, *__cur1), std::__invoke(__proj2, *__cur2))) {
                            ++__first1;
                            break;
                        }
                    }
                }
            }
            template <forward_range _Range1, forward_range _Range2, typename _Pred = ranges::equal_to, typename _Proj1 = identity, typename _Proj2 = identity> constexpr borrowed_subrange_t<_Range1> operator()(_Range1 &&__r1, _Range2 &&__r2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
                return (*this)(ranges::begin(__r1), ranges::end(__r1), ranges::begin(__r2), ranges::end(__r2), std::move(__pred), std::move(__proj1), std::move(__proj2));
            }
        };
        constexpr __search_fn search{};
        struct __min_fn {
            template <typename _Tp, typename _Proj = identity, indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp = ranges::less> constexpr const _Tp &operator()(const _Tp &__a, const _Tp &__b, _Comp __comp = {}, _Proj __proj = {}) const {
                if (std::__invoke(__comp, std::__invoke(__proj, __b), std::__invoke(__proj, __a)))
                    return __b;
                else
                    return __a;
            }
            template <input_range _Range, typename _Proj = identity, indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less> constexpr range_value_t<_Range> operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
                auto __first = ranges::begin(__r);
                auto __last = ranges::end(__r);
                do {
                    if (std::__is_constant_evaluated() && !bool(__first != __last))
                        __builtin_unreachable();
                } while (false);
                auto __result = *__first;
                while (++__first != __last)
                    {
                        auto __tmp = *__first;
                        if (std::__invoke(__comp, std::__invoke(__proj, __tmp), std::__invoke(__proj, __result)))
                            __result = std::move(__tmp);
                    }
                return __result;
            }
            template <copyable _Tp, typename _Proj = identity, indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp = ranges::less> constexpr _Tp operator()(initializer_list<_Tp> __r, _Comp __comp = {}, _Proj __proj = {}) const {
                return (*this)(ranges::subrange(__r), std::move(__comp), std::move(__proj));
            }
        };
        constexpr __min_fn min{};
        struct __adjacent_find_fn {
            template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Proj = identity, indirect_binary_predicate<projected<_Iter, _Proj>projected<_Iter, _Proj>> _Pred = ranges::equal_to> constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred = {}, _Proj __proj = {}) const {
                if (__first == __last)
                    return __first;
                auto __next = __first;
                for (; ++__next != __last; __first = __next) {
                    if (std::__invoke(__pred, std::__invoke(__proj, *__first), std::__invoke(__proj, *__next)))
                        return __first;
                }
                return __next;
            }
            template <forward_range _Range, typename _Proj = identity, indirect_binary_predicate<projected<iterator_t<_Range>, _Proj>projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to> constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r, _Pred __pred = {}, _Proj __proj = {}) const {
                return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred), std::move(__proj));
            }
        };
        constexpr __adjacent_find_fn adjacent_find{};
    }
    using ranges::get;
    template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind> struct tuple_size<ranges::subrange<_Iter, _Sent, _Kind>> : integral_constant<size_t, 2> {
    };
    template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind> struct tuple_element<0, ranges::subrange<_Iter, _Sent, _Kind>> {
        using type = _Iter;
    };
    template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind> struct tuple_element<1, ranges::subrange<_Iter, _Sent, _Kind>> {
        using type = _Sent;
    };
    template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind> struct tuple_element<0, const ranges::subrange<_Iter, _Sent, _Kind>> {
        using type = _Iter;
    };
    template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind> struct tuple_element<1, const ranges::subrange<_Iter, _Sent, _Kind>> {
        using type = _Sent;
    };
}
namespace std {
    template <typename ..._Elements> class tuple;
    template <typename _Tp> struct __is_empty_non_tuple : is_empty<_Tp> {
    };
    template <typename _El0, typename ..._El> struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type {
    };
    template <typename _Tp> using __empty_not_final = __conditional_t<__is_final(_Tp), false_type, __is_empty_non_tuple<_Tp>>;
    template <size_t _Idx, typename _Head, bool = __empty_not_final<_Head>::value> struct _Head_base;
    template <size_t _Idx, typename _Head> struct _Head_base<_Idx, _Head, true> {
        constexpr _Head_base<_Idx, type-parameter-0-1, true>() : _M_head_impl() {
        }
        constexpr _Head_base<_Idx, type-parameter-0-1, true>(const _Head &__h) : _M_head_impl(__h) {
        }
        _Head_base<_Idx, type-parameter-0-1, true>(const _Head_base<_Idx, type-parameter-0-1, true> &) = default
        _Head_base<_Idx, type-parameter-0-1, true>(_Head_base<_Idx, type-parameter-0-1, true> &&) = default
        template <typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, true>(_UHead &&__h) : _M_head_impl(std::forward<_UHead>(__h)) {
        }
        constexpr _Head_base<_Idx, type-parameter-0-1, true>(allocator_arg_t, __uses_alloc0) : _M_head_impl() {
        }
        template <typename _Alloc> constexpr _Head_base<_Idx, type-parameter-0-1, true>(allocator_arg_t, __uses_alloc1<_Alloc> __a) : _M_head_impl(allocator_arg, *__a._M_a) {
        }
        template <typename _Alloc> constexpr _Head_base<_Idx, type-parameter-0-1, true>(allocator_arg_t, __uses_alloc2<_Alloc> __a) : _M_head_impl(*__a._M_a) {
        }
        template <typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, true>(__uses_alloc0, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead)) {
        }
        template <typename _Alloc, typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, true>(__uses_alloc1<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) {
        }
        template <typename _Alloc, typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, true>(__uses_alloc2<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) {
        }
        static constexpr _Head &_M_head(_Head_base<_Idx, type-parameter-0-1, true> &__b) noexcept {
            return __b._M_head_impl;
        }
        static constexpr const _Head &_M_head(const _Head_base<_Idx, type-parameter-0-1, true> &__b) noexcept {
            return __b._M_head_impl;
        }
        _Head _M_head_impl [[no_unique_address]];
    };
    template <size_t _Idx, typename _Head> struct _Head_base<_Idx, _Head, false> {
        constexpr _Head_base<_Idx, type-parameter-0-1, false>() : _M_head_impl() {
        }
        constexpr _Head_base<_Idx, type-parameter-0-1, false>(const _Head &__h) : _M_head_impl(__h) {
        }
        _Head_base<_Idx, type-parameter-0-1, false>(const _Head_base<_Idx, type-parameter-0-1, false> &) = default
        _Head_base<_Idx, type-parameter-0-1, false>(_Head_base<_Idx, type-parameter-0-1, false> &&) = default
        template <typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, false>(_UHead &&__h) : _M_head_impl(std::forward<_UHead>(__h)) {
        }
        constexpr _Head_base<_Idx, type-parameter-0-1, false>(allocator_arg_t, __uses_alloc0) : _M_head_impl() {
        }
        template <typename _Alloc> constexpr _Head_base<_Idx, type-parameter-0-1, false>(allocator_arg_t, __uses_alloc1<_Alloc> __a) : _M_head_impl(allocator_arg, *__a._M_a) {
        }
        template <typename _Alloc> constexpr _Head_base<_Idx, type-parameter-0-1, false>(allocator_arg_t, __uses_alloc2<_Alloc> __a) : _M_head_impl(*__a._M_a) {
        }
        template <typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, false>(__uses_alloc0, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead)) {
        }
        template <typename _Alloc, typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, false>(__uses_alloc1<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) {
        }
        template <typename _Alloc, typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, false>(__uses_alloc2<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) {
        }
        static constexpr _Head &_M_head(_Head_base<_Idx, type-parameter-0-1, false> &__b) noexcept {
            return __b._M_head_impl;
        }
        static constexpr const _Head &_M_head(const _Head_base<_Idx, type-parameter-0-1, false> &__b) noexcept {
            return __b._M_head_impl;
        }
        _Head _M_head_impl;
    };
    template <size_t _Idx, typename ..._Elements> struct _Tuple_impl;
    template <size_t _Idx, typename _Head, typename ..._Tail> struct _Tuple_impl<_Idx, _Head, _Tail...> : public _Tuple_impl<_Idx + 1, _Tail...>, private _Head_base<_Idx, _Head> {
        friend template <size_t, typename ...> struct _Tuple_impl;
        typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
        typedef _Head_base<_Idx, _Head> _Base;
        static constexpr _Head &_M_head(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept {
            return _Base::_M_head(__t);
        }
        static constexpr const _Head &_M_head(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept {
            return _Base::_M_head(__t);
        }
        static constexpr _Inherited &_M_tail(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept {
            return __t;
        }
        static constexpr const _Inherited &_M_tail(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept {
            return __t;
        }
        constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>() : _Inherited(), _Base() {
        }
        constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Head &__head, const _Tail &...__tail) : _Inherited(__tail...), _Base(__head) {
        }
        template <typename _UHead, typename ..._UTail, typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>> constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_UHead &&__head, _UTail &&...__tail) : _Inherited(std::forward<_UTail>(__tail)...), _Base(std::forward<_UHead>(__head)) {
        }
        _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &) = default
        _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &operator=(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &) = delete
        _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &&) = default
        template <typename ..._UElements> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Tuple_impl<_Idx, _UElements...> &__in) : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)), _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) {
        }
        template <typename _UHead, typename ..._UTails> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_Tuple_impl<_Idx, _UHead, _UTails...> &&__in) : _Inherited(std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))), _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) {
        }
        template <typename _Alloc> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a), _Base(__tag, __use_alloc<_Head>(__a)) {
        }
        template <typename _Alloc> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(allocator_arg_t __tag, const _Alloc &__a, const _Head &__head, const _Tail &...__tail) : _Inherited(__tag, __a, __tail...), _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) {
        }
        template <typename _Alloc, typename _UHead, typename ..._UTail, typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(allocator_arg_t __tag, const _Alloc &__a, _UHead &&__head, _UTail &&...__tail) : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...), _Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(__head)) {
        }
        template <typename _Alloc> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__in) : _Inherited(__tag, __a, _M_tail(__in)), _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) {
        }
        template <typename _Alloc> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &&__in) : _Inherited(__tag, __a, std::move(_M_tail(__in))), _Base(__use_alloc<_Head, _Alloc, _Head>(__a), std::forward<_Head>(_M_head(__in))) {
        }
        template <typename _Alloc, typename _UHead, typename ..._UTails> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, _UHead, _UTails...> &__in) : _Inherited(__tag, __a, _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)), _Base(__use_alloc<_Head, _Alloc, const _UHead &>(__a), _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)) {
        }
        template <typename _Alloc, typename _UHead, typename ..._UTails> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, _UHead, _UTails...> &&__in) : _Inherited(__tag, __a, std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))), _Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) {
        }
        template <typename ..._UElements> constexpr void _M_assign(const _Tuple_impl<_Idx, _UElements...> &__in) {
            _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
            _M_tail(*this)._M_assign(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
        }
        template <typename _UHead, typename ..._UTails> constexpr void _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...> &&__in) {
            _M_head(*this) = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
            _M_tail(*this)._M_assign(std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
        }
    protected:
        constexpr void _M_swap(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__in) {
            using std::swap;
            swap(_M_head(*this), _M_head(__in));
            _Inherited::_M_swap(_M_tail(__in));
        }
    };
    template <size_t _Idx, typename _Head> struct _Tuple_impl<_Idx, _Head> : private _Head_base<_Idx, _Head> {
        friend template <size_t, typename ...> struct _Tuple_impl;
        typedef _Head_base<_Idx, _Head> _Base;
        static constexpr _Head &_M_head(_Tuple_impl<_Idx, type-parameter-0-1> &__t) noexcept {
            return _Base::_M_head(__t);
        }
        static constexpr const _Head &_M_head(const _Tuple_impl<_Idx, type-parameter-0-1> &__t) noexcept {
            return _Base::_M_head(__t);
        }
        constexpr _Tuple_impl<_Idx, type-parameter-0-1>() : _Base() {
        }
        constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1>(const _Head &__head) : _Base(__head) {
        }
        template <typename _UHead> constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1>(_UHead &&__head) : _Base(std::forward<_UHead>(__head)) {
        }
        _Tuple_impl<_Idx, type-parameter-0-1>(const _Tuple_impl<_Idx, type-parameter-0-1> &) = default
        _Tuple_impl<_Idx, type-parameter-0-1> &operator=(const _Tuple_impl<_Idx, type-parameter-0-1> &) = delete
        constexpr _Tuple_impl<_Idx, type-parameter-0-1>(_Tuple_impl<_Idx, type-parameter-0-1> &&__in) noexcept(is_nothrow_move_constructible<_Head>::value) : _Base(static_cast<_Base &&>(__in)) {
        }
        template <typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(const _Tuple_impl<_Idx, _UHead> &__in) : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) {
        }
        template <typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(_Tuple_impl<_Idx, _UHead> &&__in) : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in))) {
        }
        template <typename _Alloc> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a) : _Base(__tag, __use_alloc<_Head>(__a)) {
        }
        template <typename _Alloc> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const _Head &__head) : _Base(__use_alloc<_Head, _Alloc, const _Head &>(__a), __head) {
        }
        template <typename _Alloc, typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, _UHead &&__head) : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(__head)) {
        }
        template <typename _Alloc> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, type-parameter-0-1> &__in) : _Base(__use_alloc<_Head, _Alloc, const _Head &>(__a), _M_head(__in)) {
        }
        template <typename _Alloc> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, type-parameter-0-1> &&__in) : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), std::forward<_Head>(_M_head(__in))) {
        }
        template <typename _Alloc, typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, _UHead> &__in) : _Base(__use_alloc<_Head, _Alloc, const _UHead &>(__a), _Tuple_impl<_Idx, _UHead>::_M_head(__in)) {
        }
        template <typename _Alloc, typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, _UHead> &&__in) : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in))) {
        }
        template <typename _UHead> constexpr void _M_assign(const _Tuple_impl<_Idx, _UHead> &__in) {
            _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
        }
        template <typename _UHead> constexpr void _M_assign(_Tuple_impl<_Idx, _UHead> &&__in) {
            _M_head(*this) = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
        }
    protected:
        constexpr void _M_swap(_Tuple_impl<_Idx, type-parameter-0-1> &__in) {
            using std::swap;
            swap(_M_head(*this), _M_head(__in));
        }
    };
    template <bool, typename ..._Types> struct _TupleConstraints {
        template <typename ..._UTypes> using __constructible = __and_<is_constructible<_Types, _UTypes>...>;
        template <typename ..._UTypes> using __convertible = __and_<is_convertible<_UTypes, _Types>...>;
        template <typename ..._UTypes> static constexpr bool __is_implicitly_constructible() {
            return __and_<__constructible<_UTypes...>, __convertible<_UTypes...>>::value;
        }
        template <typename ..._UTypes> static constexpr bool __is_explicitly_constructible() {
            return __and_<__constructible<_UTypes...>, __not_<__convertible<_UTypes...>>>::value;
        }
        static constexpr bool __is_implicitly_default_constructible() {
            return __and_<std::__is_implicitly_default_constructible<_Types>...>::value;
        }
        static constexpr bool __is_explicitly_default_constructible() {
            return __and_<is_default_constructible<_Types>..., __not_<__and_<std::__is_implicitly_default_constructible<_Types>...>>>::value;
        }
    };
    template <typename ..._Types> struct _TupleConstraints<false, _Types...> {
        template <typename ..._UTypes> static constexpr bool __is_implicitly_constructible() {
            return false;
        }
        template <typename ..._UTypes> static constexpr bool __is_explicitly_constructible() {
            return false;
        }
    };
    template <typename ..._Elements> class tuple : public _Tuple_impl<0, _Elements...> {
        typedef _Tuple_impl<0, _Elements...> _Inherited;
        template <bool _Cond> using _TCC = _TupleConstraints<_Cond, _Elements...>;
        template <bool _Dummy> using _ImplicitDefaultCtor = __enable_if_t<_TCC<_Dummy>::__is_implicitly_default_constructible(), bool>;
        template <bool _Dummy> using _ExplicitDefaultCtor = __enable_if_t<_TCC<_Dummy>::__is_explicitly_default_constructible(), bool>;
        template <bool _Cond, typename ..._Args> using _ImplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_implicitly_constructible<_Args...>(), bool>;
        template <bool _Cond, typename ..._Args> using _ExplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_explicitly_constructible<_Args...>(), bool>;
        template <typename ..._UElements> static constexpr __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool> __assignable() {
            return __and_<is_assignable<_Elements &, _UElements>...>::value;
        }
        template <typename ..._UElements> static constexpr bool __nothrow_assignable() {
            return __and_<is_nothrow_assignable<_Elements &, _UElements>...>::value;
        }
        template <typename ..._UElements> static constexpr bool __nothrow_constructible() {
            return __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
        }
        template <typename _Up> static constexpr bool __valid_args() {
            return sizeof...(_Elements) == 1 && !is_same<tuple<type-parameter-0-0...>, __remove_cvref_t<_Up>>::value;
        }
        template <typename, typename, typename ..._Tail> static constexpr bool __valid_args() {
            return (sizeof...(_Tail) + 2) == sizeof...(_Elements);
        }
        template <typename _Tuple, typename = tuple<type-parameter-0-0...>, typename = __remove_cvref_t<_Tuple>> struct _UseOtherCtor : false_type {
        };
        template <typename _Tuple, typename _Tp, typename _Up> struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>> : __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>::type {
        };
        template <typename _Tuple, typename _Tp> struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>> : true_type {
        };
        template <typename _Tuple> static constexpr bool __use_other_ctor() {
            return _UseOtherCtor<_Tuple>::value;
        }
    public:
        template <typename _Dummy = void, _ImplicitDefaultCtor<is_void<_Dummy>::value> = true> constexpr tuple<type-parameter-0-0...>() noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value) : _Inherited() {
        }
        template <typename _Dummy = void, _ExplicitDefaultCtor<is_void<_Dummy>::value> = false> constexpr explicit tuple<type-parameter-0-0...>() noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value) : _Inherited() {
        }
        template <bool _NotEmpty = (sizeof...(_Elements) >= 1), _ImplicitCtor<_NotEmpty, const _Elements &...> = true> constexpr tuple<type-parameter-0-0...>(const _Elements &...__elements) noexcept(__nothrow_constructible<const _Elements &...>()) : _Inherited(__elements...) {
        }
        template <bool _NotEmpty = (sizeof...(_Elements) >= 1), _ExplicitCtor<_NotEmpty, const _Elements &...> = false> constexpr explicit tuple<type-parameter-0-0...>(const _Elements &...__elements) noexcept(__nothrow_constructible<const _Elements &...>()) : _Inherited(__elements...) {
        }
        template <typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ImplicitCtor<_Valid, _UElements...> = true> constexpr tuple<type-parameter-0-0...>(_UElements &&...__elements) noexcept(__nothrow_constructible<_UElements...>()) : _Inherited(std::forward<_UElements>(__elements)...) {
        }
        template <typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ExplicitCtor<_Valid, _UElements...> = false> constexpr explicit tuple<type-parameter-0-0...>(_UElements &&...__elements) noexcept(__nothrow_constructible<_UElements...>()) : _Inherited(std::forward<_UElements>(__elements)...) {
        }
        tuple<type-parameter-0-0...>(const tuple<type-parameter-0-0...> &) = default
        tuple<type-parameter-0-0...>(tuple<type-parameter-0-0...> &&) = default
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ImplicitCtor<_Valid, const _UElements &...> = true> constexpr tuple<type-parameter-0-0...>(const tuple<_UElements...> &__in) noexcept(__nothrow_constructible<const _UElements &...>()) : _Inherited(static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ExplicitCtor<_Valid, const _UElements &...> = false> constexpr explicit tuple<type-parameter-0-0...>(const tuple<_UElements...> &__in) noexcept(__nothrow_constructible<const _UElements &...>()) : _Inherited(static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ImplicitCtor<_Valid, _UElements...> = true> constexpr tuple<type-parameter-0-0...>(tuple<_UElements...> &&__in) noexcept(__nothrow_constructible<_UElements...>()) : _Inherited(static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ExplicitCtor<_Valid, _UElements...> = false> constexpr explicit tuple<type-parameter-0-0...>(tuple<_UElements...> &&__in) noexcept(__nothrow_constructible<_UElements...>()) : _Inherited(static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {
        }
        template <typename _Alloc, _ImplicitDefaultCtor<is_object<_Alloc>::value> = true> constexpr tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a) {
        }
        template <typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1), _ImplicitCtor<_NotEmpty, const _Elements &...> = true> constexpr tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, const _Elements &...__elements) : _Inherited(__tag, __a, __elements...) {
        }
        template <typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1), _ExplicitCtor<_NotEmpty, const _Elements &...> = false> constexpr explicit tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, const _Elements &...__elements) : _Inherited(__tag, __a, __elements...) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ImplicitCtor<_Valid, _UElements...> = true> constexpr tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, _UElements &&...__elements) : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ExplicitCtor<_Valid, _UElements...> = false> constexpr explicit tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, _UElements &&...__elements) : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...) {
        }
        template <typename _Alloc> constexpr tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, const tuple<type-parameter-0-0...> &__in) : _Inherited(__tag, __a, static_cast<const _Inherited &>(__in)) {
        }
        template <typename _Alloc> constexpr tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, tuple<type-parameter-0-0...> &&__in) : _Inherited(__tag, __a, static_cast<_Inherited &&>(__in)) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ImplicitCtor<_Valid, const _UElements &...> = true> constexpr tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, const tuple<_UElements...> &__in) : _Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ExplicitCtor<_Valid, const _UElements &...> = false> constexpr explicit tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, const tuple<_UElements...> &__in) : _Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ImplicitCtor<_Valid, _UElements...> = true> constexpr tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, tuple<_UElements...> &&__in) : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ExplicitCtor<_Valid, _UElements...> = false> constexpr explicit tuple<type-parameter-0-0...>(allocator_arg_t __tag, const _Alloc &__a, tuple<_UElements...> &&__in) : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {
        }
        constexpr tuple<type-parameter-0-0...> &operator=(__conditional_t<__assignable<const _Elements &...>(), const tuple<type-parameter-0-0...> &, const __nonesuch &> __in) noexcept(__nothrow_assignable<const _Elements &...>()) {
            this->_M_assign(__in);
            return *this;
        }
        constexpr tuple<type-parameter-0-0...> &operator=(__conditional_t<__assignable<_Elements...>(), tuple<type-parameter-0-0...> &&, __nonesuch &&> __in) noexcept(__nothrow_assignable<_Elements...>()) {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename ..._UElements> constexpr __enable_if_t<__assignable<const _UElements &...>(), tuple<type-parameter-0-0...> &> operator=(const tuple<_UElements...> &__in) noexcept(__nothrow_assignable<const _UElements &...>()) {
            this->_M_assign(__in);
            return *this;
        }
        template <typename ..._UElements> constexpr __enable_if_t<__assignable<_UElements...>(), tuple<type-parameter-0-0...> &> operator=(tuple<_UElements...> &&__in) noexcept(__nothrow_assignable<_UElements...>()) {
            this->_M_assign(std::move(__in));
            return *this;
        }
        constexpr void swap(tuple<type-parameter-0-0...> &__in) noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value) {
            _Inherited::_M_swap(__in);
        }
    };
    template <typename ..._UTypes> tuple(_UTypes ...) -> tuple<_UTypes...>;
    template <typename _T1, typename _T2> tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
    template <typename _Alloc, typename ..._UTypes> tuple(allocator_arg_t, _Alloc, _UTypes ...) -> tuple<_UTypes...>;
    template <typename _Alloc, typename _T1, typename _T2> tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
    template <typename _Alloc, typename ..._UTypes> tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;
    template<> class tuple<> {
    public:
        constexpr void swap(tuple<> &) noexcept {
        }
        tuple() = default
        template <typename _Alloc> constexpr tuple(allocator_arg_t, const _Alloc &) noexcept {
        }
        template <typename _Alloc> constexpr tuple(allocator_arg_t, const _Alloc &, const tuple<> &) noexcept {
        }
    };
    template <typename _T1, typename _T2> class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2> {
        typedef _Tuple_impl<0, _T1, _T2> _Inherited;
        template <bool _Dummy, typename _U1, typename _U2> using _ImplicitDefaultCtor = __enable_if_t<_TupleConstraints<_Dummy, _U1, _U2>::__is_implicitly_default_constructible(), bool>;
        template <bool _Dummy, typename _U1, typename _U2> using _ExplicitDefaultCtor = __enable_if_t<_TupleConstraints<_Dummy, _U1, _U2>::__is_explicitly_default_constructible(), bool>;
        template <bool _Dummy> using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;
        template <bool _Cond, typename _U1, typename _U2> using _ImplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(), bool>;
        template <bool _Cond, typename _U1, typename _U2> using _ExplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(), bool>;
        template <typename _U1, typename _U2> static constexpr bool __assignable() {
            return __and_<is_assignable<_T1 &, _U1>, is_assignable<_T2 &, _U2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool __nothrow_assignable() {
            return __and_<is_nothrow_assignable<_T1 &, _U1>, is_nothrow_assignable<_T2 &, _U2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool __nothrow_constructible() {
            return __and_<is_nothrow_constructible<_T1, _U1>, is_nothrow_constructible<_T2, _U2>>::value;
        }
        static constexpr bool __nothrow_default_constructible() {
            return __and_<is_nothrow_default_constructible<_T1>, is_nothrow_default_constructible<_T2>>::value;
        }
        template <typename _U1> static constexpr bool __is_alloc_arg() {
            return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value;
        }
    public:
        template <bool _Dummy = true, _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>() noexcept(__nothrow_default_constructible()) : _Inherited() {
        }
        template <bool _Dummy = true, _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>() noexcept(__nothrow_default_constructible()) : _Inherited() {
        }
        template <bool _Dummy = true, _ImplicitCtor<_Dummy, const _T1 &, const _T2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const _T1 &__a1, const _T2 &__a2) noexcept(__nothrow_constructible<const _T1 &, const _T2 &>()) : _Inherited(__a1, __a2) {
        }
        template <bool _Dummy = true, _ExplicitCtor<_Dummy, const _T1 &, const _T2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const _T1 &__a1, const _T2 &__a2) noexcept(__nothrow_constructible<const _T1 &, const _T2 &>()) : _Inherited(__a1, __a2) {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(_U1 &&__a1, _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>()) : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(_U1 &&__a1, _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>()) : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {
        }
        tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<type-parameter-0-0, type-parameter-0-1> &) = default
        tuple<type-parameter-0-0, type-parameter-0-1>(tuple<type-parameter-0-0, type-parameter-0-1> &&) = default
        template <typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(tuple<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(tuple<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const pair<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : _Inherited(__in.first, __in.second) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const pair<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : _Inherited(__in.first, __in.second) {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(pair<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : _Inherited(std::forward<_U1>(__in.first), std::forward<_U2>(__in.second)) {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(pair<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : _Inherited(std::forward<_U1>(__in.first), std::forward<_U2>(__in.second)) {
        }
        template <typename _Alloc, _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a) {
        }
        template <typename _Alloc, bool _Dummy = true, _ImplicitCtor<_Dummy, const _T1 &, const _T2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const _T1 &__a1, const _T2 &__a2) : _Inherited(__tag, __a, __a1, __a2) {
        }
        template <typename _Alloc, bool _Dummy = true, _ExplicitCtor<_Dummy, const _T1 &, const _T2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const _T1 &__a1, const _T2 &__a2) : _Inherited(__tag, __a, __a1, __a2) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2) : _Inherited(__tag, __a, std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2) : _Inherited(__tag, __a, std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {
        }
        template <typename _Alloc> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const tuple<type-parameter-0-0, type-parameter-0-1> &__in) : _Inherited(__tag, __a, static_cast<const _Inherited &>(__in)) {
        }
        template <typename _Alloc> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, tuple<type-parameter-0-0, type-parameter-0-1> &&__in) : _Inherited(__tag, __a, static_cast<_Inherited &&>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const tuple<_U1, _U2> &__in) : _Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const tuple<_U1, _U2> &__in) : _Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, tuple<_U1, _U2> &&__in) : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, tuple<_U1, _U2> &&__in) : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const pair<_U1, _U2> &__in) : _Inherited(__tag, __a, __in.first, __in.second) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, const pair<_U1, _U2> &__in) : _Inherited(__tag, __a, __in.first, __in.second) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, pair<_U1, _U2> &&__in) : _Inherited(__tag, __a, std::forward<_U1>(__in.first), std::forward<_U2>(__in.second)) {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(allocator_arg_t __tag, const _Alloc &__a, pair<_U1, _U2> &&__in) : _Inherited(__tag, __a, std::forward<_U1>(__in.first), std::forward<_U2>(__in.second)) {
        }
        constexpr tuple<type-parameter-0-0, type-parameter-0-1> &operator=(__conditional_t<__assignable<const _T1 &, const _T2 &>(), const tuple<type-parameter-0-0, type-parameter-0-1> &, const __nonesuch &> __in) noexcept(__nothrow_assignable<const _T1 &, const _T2 &>()) {
            this->_M_assign(__in);
            return *this;
        }
        constexpr tuple<type-parameter-0-0, type-parameter-0-1> &operator=(__conditional_t<__assignable<_T1, _T2>(), tuple<type-parameter-0-0, type-parameter-0-1> &&, __nonesuch &&> __in) noexcept(__nothrow_assignable<_T1, _T2>()) {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename _U1, typename _U2> constexpr __enable_if_t<__assignable<const _U1 &, const _U2 &>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(const tuple<_U1, _U2> &__in) noexcept(__nothrow_assignable<const _U1 &, const _U2 &>()) {
            this->_M_assign(__in);
            return *this;
        }
        template <typename _U1, typename _U2> constexpr __enable_if_t<__assignable<_U1, _U2>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(tuple<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>()) {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename _U1, typename _U2> constexpr __enable_if_t<__assignable<const _U1 &, const _U2 &>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(const pair<_U1, _U2> &__in) noexcept(__nothrow_assignable<const _U1 &, const _U2 &>()) {
            this->_M_head(*this) = __in.first;
            this->_M_tail(*this)._M_head(*this) = __in.second;
            return *this;
        }
        template <typename _U1, typename _U2> constexpr __enable_if_t<__assignable<_U1, _U2>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(pair<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>()) {
            this->_M_head(*this) = std::forward<_U1>(__in.first);
            this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
            return *this;
        }
        constexpr void swap(tuple<type-parameter-0-0, type-parameter-0-1> &__in) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::value) {
            _Inherited::_M_swap(__in);
        }
    };
    template <typename ..._Elements> struct tuple_size<tuple<_Elements...>> : public integral_constant<size_t, sizeof...(_Elements)> {
    };
    constexpr size_t tuple_size_v = sizeof...(_Types);
    constexpr size_t tuple_size_v = sizeof...(_Types);
    template <size_t __i, typename ..._Types> struct tuple_element<__i, tuple<_Types...>> {
        static_assert(__i < sizeof...(_Types), "tuple index must be in range");
        using type = typename _Nth_type<__i, _Types...>::type;
    };
    template <size_t __i, typename _Head, typename ..._Tail> constexpr _Head &__get_helper(_Tuple_impl<__i, _Head, _Tail...> &__t) noexcept {
        return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
    }
    template <size_t __i, typename _Head, typename ..._Tail> constexpr const _Head &__get_helper(const _Tuple_impl<__i, _Head, _Tail...> &__t) noexcept {
        return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
    }
    template <size_t __i, typename ..._Types> __enable_if_t<(__i >= sizeof...(_Types))> __get_helper(const tuple<_Types...> &) = delete
    template <size_t __i, typename ..._Elements> constexpr __tuple_element_t<__i, tuple<_Elements...>> &get(tuple<_Elements...> &__t) noexcept {
        return std::__get_helper<__i>(__t);
    }
    template <size_t __i, typename ..._Elements> constexpr const __tuple_element_t<__i, tuple<_Elements...>> &get(const tuple<_Elements...> &__t) noexcept {
        return std::__get_helper<__i>(__t);
    }
    template <size_t __i, typename ..._Elements> constexpr __tuple_element_t<__i, tuple<_Elements...>> &&get(tuple<_Elements...> &&__t) noexcept {
        typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
        return std::forward<__element_type>(std::__get_helper<__i>(__t));
    }
    template <size_t __i, typename ..._Elements> constexpr const __tuple_element_t<__i, tuple<_Elements...>> &&get(const tuple<_Elements...> &&__t) noexcept {
        typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
        return std::forward<const __element_type>(std::__get_helper<__i>(__t));
    }
    template <size_t __i, typename ..._Elements> constexpr __enable_if_t<(__i >= sizeof...(_Elements))> get(const tuple<_Elements...> &) = delete
    template <typename _Tp, typename ..._Types> constexpr _Tp &get(tuple<_Types...> &__t) noexcept {
        constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
        static_assert(__idx < sizeof...(_Types), "the type T in std::get<T> must occur exactly once in the tuple");
        return std::__get_helper<__idx>(__t);
    }
    template <typename _Tp, typename ..._Types> constexpr _Tp &&get(tuple<_Types...> &&__t) noexcept {
        constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
        static_assert(__idx < sizeof...(_Types), "the type T in std::get<T> must occur exactly once in the tuple");
        return std::forward<_Tp>(std::__get_helper<__idx>(__t));
    }
    template <typename _Tp, typename ..._Types> constexpr const _Tp &get(const tuple<_Types...> &__t) noexcept {
        constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
        static_assert(__idx < sizeof...(_Types), "the type T in std::get<T> must occur exactly once in the tuple");
        return std::__get_helper<__idx>(__t);
    }
    template <typename _Tp, typename ..._Types> constexpr const _Tp &&get(const tuple<_Types...> &&__t) noexcept {
        constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
        static_assert(__idx < sizeof...(_Types), "the type T in std::get<T> must occur exactly once in the tuple");
        return std::forward<const _Tp>(std::__get_helper<__idx>(__t));
    }
    template <typename _Tp, typename _Up, size_t __i, size_t __size> struct __tuple_compare {
        static constexpr bool __eq(const _Tp &__t, const _Up &__u) {
            return bool(std::get<__i>(__t) == std::get<__i>(__u)) && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
        }
        static constexpr bool __less(const _Tp &__t, const _Up &__u) {
            return bool(std::get<__i>(__t) < std::get<__i>(__u)) || (!bool(std::get<__i>(__u) < std::get<__i>(__t)) && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
        }
    };
    template <typename _Tp, typename _Up, size_t __size> struct __tuple_compare<_Tp, _Up, __size, __size> {
        static constexpr bool __eq(const _Tp &, const _Up &) {
            return true;
        }
        static constexpr bool __less(const _Tp &, const _Up &) {
            return false;
        }
    };
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator==(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u) {
        static_assert(sizeof...(_TElements) == sizeof...(_UElements), "tuple objects can only be compared if they have equal sizes.");
        using __compare = __tuple_compare<tuple<_TElements...>, tuple<_UElements...>, 0, sizeof...(_TElements)>;
        return __compare::__eq(__t, __u);
    }
    template <typename _Cat, typename _Tp, typename _Up> constexpr _Cat __tuple_cmp(const _Tp &, const _Up &, index_sequence<>) {
        return _Cat::equivalent;
    }
    template <typename _Cat, typename _Tp, typename _Up, size_t _Idx0, size_t ..._Idxs> constexpr _Cat __tuple_cmp(const _Tp &__t, const _Up &__u, index_sequence<_Idx0, _Idxs...>) {
        auto __c = __detail::__synth3way(std::get<_Idx0>(__t), std::get<_Idx0>(__u));
        if (__c != 0)
            return __c;
        return std::__tuple_cmp<_Cat>(__t, __u, index_sequence<_Idxs...>());
    }
    template <typename ..._Tps, typename ..._Ups> constexpr common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...> operator<=>(const tuple<_Tps...> &__t, const tuple<_Ups...> &__u) {
        using _Cat = common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>;
        return std::__tuple_cmp<_Cat>(__t, __u, index_sequence_for<_Tps...>());
    }
    template <typename ..._Elements> constexpr tuple<typename __decay_and_strip<_Elements>::__type...> make_tuple(_Elements &&...__args) {
        typedef tuple<typename __decay_and_strip<_Elements>::__type...> __result_type;
        return __result_type(std::forward<_Elements>(__args)...);
    }
    template <typename ..._Elements> constexpr tuple<_Elements &&...> forward_as_tuple(_Elements &&...__args) noexcept {
        return tuple<_Elements &&...>(std::forward<_Elements>(__args)...);
    }
    template <typename _Tp, size_t _Nm> struct array;
    template <size_t _Int, typename _Tp, size_t _Nm> constexpr _Tp &get(array<_Tp, _Nm> &) noexcept;
    template <size_t _Int, typename _Tp, size_t _Nm> constexpr _Tp &&get(array<_Tp, _Nm> &&) noexcept;
    template <size_t _Int, typename _Tp, size_t _Nm> constexpr const _Tp &get(const array<_Tp, _Nm> &) noexcept;
    template <size_t _Int, typename _Tp, size_t _Nm> constexpr const _Tp &&get(const array<_Tp, _Nm> &&) noexcept;
    template <size_t, typename, typename, size_t> struct __make_tuple_impl;
    template <size_t _Idx, typename _Tuple, typename ..._Tp, size_t _Nm> struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm> : __make_tuple_impl<_Idx + 1, tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>, _Tuple, _Nm> {
    };
    template <size_t _Nm, typename _Tuple, typename ..._Tp> struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm> {
        typedef tuple<_Tp...> __type;
    };
    template <typename _Tuple> struct __do_make_tuple : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value> {
    };
    template <typename _Tuple> struct __make_tuple : public __do_make_tuple<__remove_cvref_t<_Tuple>> {
    };
    template <typename ...> struct __combine_tuples;
    template<> struct __combine_tuples<> {
        typedef tuple<> __type;
    };
    template <typename ..._Ts> struct __combine_tuples<tuple<_Ts...>> {
        typedef tuple<_Ts...> __type;
    };
    template <typename ..._T1s, typename ..._T2s, typename ..._Rem> struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...> {
        typedef typename __combine_tuples<tuple<_T1s..., _T2s...>, _Rem...>::__type __type;
    };
    template <typename ..._Tpls> struct __tuple_cat_result {
        typedef typename __combine_tuples<typename __make_tuple<_Tpls>::__type...>::__type __type;
    };
    template <typename ...> struct __make_1st_indices;
    template<> struct __make_1st_indices<> {
        typedef _Index_tuple<> __type;
    };
    template <typename _Tp, typename ..._Tpls> struct __make_1st_indices<_Tp, _Tpls...> {
        typedef typename _Build_index_tuple<tuple_size<typename remove_reference<_Tp>::type>::value>::__type __type;
    };
    template <typename _Ret, typename _Indices, typename ..._Tpls> struct __tuple_concater;
    template <typename _Ret, size_t ..._Is, typename _Tp, typename ..._Tpls> struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...> {
        template <typename ..._Us> static constexpr _Ret _S_do(_Tp &&__tp, _Tpls &&...__tps, _Us &&...__us) {
            typedef typename __make_1st_indices<_Tpls...>::__type __idx;
            typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
            return __next::_S_do(std::forward<_Tpls>(__tps)..., std::forward<_Us>(__us)..., std::get<_Is>(std::forward<_Tp>(__tp))...);
        }
    };
    template <typename _Ret> struct __tuple_concater<_Ret, _Index_tuple<>> {
        template <typename ..._Us> static constexpr _Ret _S_do(_Us &&...__us) {
            return _Ret(std::forward<_Us>(__us)...);
        }
    };
    template <typename ..._Tps> struct __is_tuple_like_impl<tuple<_Tps...>> : true_type {
    };
    template <typename ..._Tpls, typename = typename enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type> constexpr auto tuple_cat(_Tpls &&...__tpls) -> typename __tuple_cat_result<_Tpls...>::__type {
        typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
        typedef typename __make_1st_indices<_Tpls...>::__type __idx;
        typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
        return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }
    template <typename ..._Elements> constexpr tuple<_Elements &...> tie(_Elements &...__args) noexcept {
        return tuple<_Elements &...>(__args...);
    }
    template <typename ..._Elements> inline constexpr typename enable_if<__and_<__is_swappable<_Elements>...>::value>::type swap(tuple<_Elements...> &__x, tuple<_Elements...> &__y) noexcept(noexcept(__x.swap(__y))) {
        __x.swap(__y);
    }
    template <typename ..._Elements> constexpr typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type swap(tuple<_Elements...> &, tuple<_Elements...> &) = delete
    struct _Swallow_assign {
        template <class _Tp> constexpr const _Swallow_assign &operator=(const _Tp &) const {
            return *this;
        }
    };
    constexpr _Swallow_assign ignore{};
    template <typename ..._Types, typename _Alloc> struct uses_allocator<tuple<_Types...>, _Alloc> : true_type {
    };
    template <class _T1, class _T2> template <typename ..._Args1, typename ..._Args2> inline constexpr pair<_T1, _T2>::pair<_T1, _T2>(piecewise_construct_t, tuple<_Args1...> __first, tuple<_Args2...> __second) : pair<_T1, _T2>(__first, __second, typename _Build_index_tuple<sizeof...(_Args1)>::__type(), typename _Build_index_tuple<sizeof...(_Args2)>::__type()) {
    }
    template <class _T1, class _T2> template <typename ..._Args1, size_t ..._Indexes1, typename ..._Args2, size_t ..._Indexes2> inline constexpr pair<_T1, _T2>::pair<_T1, _T2>(tuple<_Args1...> &__tuple1, tuple<_Args2...> &__tuple2, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>) : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...), second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...) {
    }
    template <template <typename ...> class _Trait, typename _Tp, typename _Tuple> constexpr bool __unpack_std_tuple = false;
    constexpr bool __unpack_std_tuple = _Trait<_Tp, _Up...>::value;
    constexpr bool __unpack_std_tuple = _Trait<_Tp, _Up &...>::value;
    constexpr bool __unpack_std_tuple = _Trait<_Tp, const _Up...>::value;
    constexpr bool __unpack_std_tuple = _Trait<_Tp, const _Up &...>::value;
    template <typename _Fn, typename _Tuple, size_t ..._Idx> constexpr decltype(auto) __apply_impl(_Fn &&__f, _Tuple &&__t, index_sequence<_Idx...>) {
        return std::__invoke(std::forward<_Fn>(__f), std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }
    template <typename _Fn, typename _Tuple> constexpr decltype(auto) apply(_Fn &&__f, _Tuple &&__t) noexcept(__unpack_std_tuple<std::is_nothrow_invocable, _Fn, _Tuple>) {
        using _Indices = make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
        return std::__apply_impl(std::forward<_Fn>(__f), std::forward<_Tuple>(__t), _Indices{});
    }
    template <typename _Tp, typename _Tuple, size_t ..._Idx> constexpr _Tp __make_from_tuple_impl(_Tuple &&__t, index_sequence<_Idx...>) {
        return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }
    template <typename _Tp, typename _Tuple> constexpr _Tp make_from_tuple(_Tuple &&__t) noexcept(__unpack_std_tuple<std::is_nothrow_constructible, _Tp, _Tuple>) {
        constexpr size_t __n = tuple_size_v<remove_reference_t<_Tuple>>;
        return __make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t), make_index_sequence<__n>{});
    }
}
namespace std {
    template <typename _Tp> concept _Std_pair = __is_pair<remove_cv_t<_Tp>>;
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr auto uses_allocator_construction_args(const _Alloc &__a, _Args &&...__args) noexcept requires (!_Std_pair<_Tp>) {
        if (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>) {
            if (is_constructible_v<_Tp, allocator_arg_t, const _Alloc &, _Args...>) {
                return tuple<allocator_arg_t, const _Alloc &, _Args &&...>(allocator_arg, __a, std::forward<_Args>(__args)...);
            } else {
                static_assert(is_constructible_v<_Tp, _Args..., const _Alloc &>, "construction with an allocator must be possible if uses_allocator is true");
                return tuple<_Args &&..., const _Alloc &>(std::forward<_Args>(__args)..., __a);
            }
        } else {
            static_assert(is_constructible_v<_Tp, _Args...>);
            return tuple<_Args &&...>(std::forward<_Args>(__args)...);
        }
    }
    template <_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2> constexpr auto uses_allocator_construction_args(const _Alloc &__a, piecewise_construct_t, _Tuple1 &&__x, _Tuple2 &&__y) noexcept;
    template <_Std_pair _Tp, typename _Alloc> constexpr auto uses_allocator_construction_args(const _Alloc &) noexcept;
    template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp> constexpr auto uses_allocator_construction_args(const _Alloc &, _Up &&, _Vp &&) noexcept;
    template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp> constexpr auto uses_allocator_construction_args(const _Alloc &, const pair<_Up, _Vp> &) noexcept;
    template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp> constexpr auto uses_allocator_construction_args(const _Alloc &, pair<_Up, _Vp> &&) noexcept;
    template <_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2> constexpr auto uses_allocator_construction_args(const _Alloc &__a, piecewise_construct_t, _Tuple1 &&__x, _Tuple2 &&__y) noexcept {
        using _Tp1 = typename _Tp::first_type;
        using _Tp2 = typename _Tp::second_type;
        return std::make_tuple(piecewise_construct, std::apply([&__a](auto &&__args1...) {
            return std::uses_allocator_construction_args<_Tp1>(__a, std::forward<decltype(__args1)>(__args1)...);
        }, std::forward<_Tuple1>(__x)), std::apply([&__a](auto &&__args2...) {
            return std::uses_allocator_construction_args<_Tp2>(__a, std::forward<decltype(__args2)>(__args2)...);
        }, std::forward<_Tuple2>(__y)));
    }
    template <_Std_pair _Tp, typename _Alloc> constexpr auto uses_allocator_construction_args(const _Alloc &__a) noexcept {
        using _Tp1 = typename _Tp::first_type;
        using _Tp2 = typename _Tp::second_type;
        return std::make_tuple(piecewise_construct, std::uses_allocator_construction_args<_Tp1>(__a), std::uses_allocator_construction_args<_Tp2>(__a));
    }
    template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp> constexpr auto uses_allocator_construction_args(const _Alloc &__a, _Up &&__u, _Vp &&__v) noexcept {
        using _Tp1 = typename _Tp::first_type;
        using _Tp2 = typename _Tp::second_type;
        return std::make_tuple(piecewise_construct, std::uses_allocator_construction_args<_Tp1>(__a, std::forward<_Up>(__u)), std::uses_allocator_construction_args<_Tp2>(__a, std::forward<_Vp>(__v)));
    }
    template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp> constexpr auto uses_allocator_construction_args(const _Alloc &__a, const pair<_Up, _Vp> &__pr) noexcept {
        using _Tp1 = typename _Tp::first_type;
        using _Tp2 = typename _Tp::second_type;
        return std::make_tuple(piecewise_construct, std::uses_allocator_construction_args<_Tp1>(__a, __pr.first), std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));
    }
    template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp> constexpr auto uses_allocator_construction_args(const _Alloc &__a, pair<_Up, _Vp> &&__pr) noexcept {
        using _Tp1 = typename _Tp::first_type;
        using _Tp2 = typename _Tp::second_type;
        return std::make_tuple(piecewise_construct, std::uses_allocator_construction_args<_Tp1>(__a, std::get<0>(std::move(__pr))), std::uses_allocator_construction_args<_Tp2>(__a, std::get<1>(std::move(__pr))));
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr _Tp make_obj_using_allocator(const _Alloc &__a, _Args &&...__args) {
        return std::make_from_tuple<_Tp>(std::uses_allocator_construction_args<_Tp>(__a, std::forward<_Args>(__args)...));
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr _Tp *uninitialized_construct_using_allocator(_Tp *__p, const _Alloc &__a, _Args &&...__args) {
        return std::apply([&](auto &&__xs...) {
            return std::construct_at(__p, std::forward<decltype(__xs)>(__xs)...);
        }, std::uses_allocator_construction_args<_Tp>(__a, std::forward<_Args>(__args)...));
    }
}
namespace std {
    namespace pmr {
        class memory_resource {
            static constexpr size_t _S_max_align = alignof(max_align_t);
        public:
            memory_resource() = default
            memory_resource(const memory_resource &) = default
            virtual ~memory_resource();
            memory_resource &operator=(const memory_resource &) = default
            void *allocate(size_t __bytes, size_t __alignment = _S_max_align) [[nodiscard("")]] __attribute__((returns_nonnull)) __attribute__((alloc_size(2))) __attribute__((alloc_align(3))) {
                return ::operator new(__bytes, this->do_allocate(__bytes, __alignment));
            }
            void deallocate(void *__p, size_t __bytes, size_t __alignment = _S_max_align) __attribute__((nonnull)) {
                return this->do_deallocate(__p, __bytes, __alignment);
            }
            bool is_equal(const memory_resource &__other) const noexcept [[nodiscard("")]] {
                return this->do_is_equal(__other);
            }
        private:
            virtual void *do_allocate(size_t __bytes, size_t __alignment) = 0;
            virtual void do_deallocate(void *__p, size_t __bytes, size_t __alignment) = 0;
            virtual bool do_is_equal(const memory_resource &__other) const noexcept = 0;
        };
        inline bool operator==(const memory_resource &__a, const memory_resource &__b) noexcept [[nodiscard("")]] {
            return &__a == &__b || __a.is_equal(__b);
        }
        template <typename _Tp> class polymorphic_allocator {
            template <typename _Up> struct __not_pair {
                using type = void;
            };
            template <typename _Up1, typename _Up2> struct __not_pair<pair<_Up1, _Up2>> {
            };
        public:
            using value_type = _Tp;
            polymorphic_allocator<_Tp>() noexcept {
                extern memory_resource *get_default_resource() noexcept __attribute__((returns_nonnull));
                this->_M_resource = get_default_resource();
            }
            polymorphic_allocator<_Tp>(memory_resource *__r) noexcept : _M_resource(__r) __attribute__((nonnull)) {
                ;
            }
            polymorphic_allocator<_Tp>(const polymorphic_allocator<_Tp> &__other) = default
            template <typename _Up> polymorphic_allocator<_Tp>(const polymorphic_allocator<_Up> &__x) noexcept : _M_resource(__x.resource()) {
            }
            polymorphic_allocator<_Tp> &operator=(const polymorphic_allocator<_Tp> &) = delete
            _Tp *allocate(size_t __n) [[nodiscard("")]] __attribute__((returns_nonnull)) {
                if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Tp)) < __n)
                    std::__throw_bad_array_new_length();
                return static_cast<_Tp *>(this->_M_resource->allocate(__n * sizeof(_Tp), alignof(_Tp)));
            }
            void deallocate(_Tp *__p, size_t __n) noexcept __attribute__((nonnull)) {
                this->_M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp));
            }
            void *allocate_bytes(size_t __nbytes, size_t __alignment = alignof(max_align_t)) [[nodiscard("")]] {
                return this->_M_resource->allocate(__nbytes, __alignment);
            }
            void deallocate_bytes(void *__p, size_t __nbytes, size_t __alignment = alignof(max_align_t)) {
                this->_M_resource->deallocate(__p, __nbytes, __alignment);
            }
            template <typename _Up> _Up *allocate_object(size_t __n = 1) [[nodiscard("")]] {
                if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Up)) < __n)
                    std::__throw_bad_array_new_length();
                return static_cast<_Up *>(this->allocate_bytes(__n * sizeof(_Up), alignof(_Up)));
            }
            template <typename _Up> void deallocate_object(_Up *__p, size_t __n = 1) {
                this->deallocate_bytes(__p, __n * sizeof(_Up), alignof(_Up));
            }
            template <typename _Up, typename ..._CtorArgs> _Up *new_object(_CtorArgs &&...__ctor_args) [[nodiscard("")]] {
                _Up *__p = allocate_object<_Up>();
                try {
                    construct(__p, std::forward<_CtorArgs>(__ctor_args)...);
                } catch (...) {
                    deallocate_object(__p);
                    throw;
                }
                return __p;
            }
            template <typename _Up> void delete_object(_Up *__p) {
                __p->~_Up();
                deallocate_object(__p);
            }
            template <typename _Tp1, typename ..._Args> void construct(_Tp1 *__p, _Args &&...__args) __attribute__((nonnull)) {
                std::uninitialized_construct_using_allocator(__p, *this, std::forward<_Args>(__args)...);
            }
            template <typename _Up> void destroy(_Up *__p) __attribute__((deprecated("use 'allocator_traits::destroy' instead"))) __attribute__((nonnull)) {
                __p->~_Up();
            }
            polymorphic_allocator<_Tp> select_on_container_copy_construction() const noexcept {
                return polymorphic_allocator<_Tp>();
            }
            memory_resource *resource() const noexcept __attribute__((returns_nonnull)) {
                return this->_M_resource;
            }
            friend bool operator==(const polymorphic_allocator<_Tp> &__a, const polymorphic_allocator<_Tp> &__b) noexcept [[nodiscard("")]] {
                return *__a.resource() == *__b.resource();
            }
;
        private:
            memory_resource *_M_resource;
        };
        template <typename _Tp1, typename _Tp2> inline bool operator==(const polymorphic_allocator<_Tp1> &__a, const polymorphic_allocator<_Tp2> &__b) noexcept [[nodiscard("")]] {
            return *__a.resource() == *__b.resource();
        }
    }
    template <typename _Alloc> struct allocator_traits
    template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]] {
            return __rhs;
        }
    }
    template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<char8_t>> {
        using allocator_type = allocator<char8_t>;
        using value_type = char8_t;
        using pointer = char8_t *;
        using const_pointer = const char8_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<int>> {
        using allocator_type = allocator<int>;
        using value_type = int;
        using pointer = int *;
        using const_pointer = const int *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    }
    template<> struct allocator_traits<std::allocator<Base<ChildA, ChildB, ChildC> *>> {
        using allocator_type = allocator<Base<ChildA, ChildB, ChildC> *>;
        using value_type = Base<ChildA, ChildB, ChildC> *;
        using pointer = Base<ChildA, ChildB, ChildC> **;
        using const_pointer = Base<ChildA, ChildB, ChildC> *const *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] [[gnu::always_inline]] {
            return __a.allocate(__n);
        }
        static constexpr pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) [[nodiscard("")]] [[gnu::always_inline]];
        static constexpr void deallocate(allocator_type &__a, pointer __p, size_type __n) [[gnu::always_inline]] {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) [[gnu::always_inline]];
        template <typename _Up> static constexpr void destroy(allocator_type &__a __attribute__((unused)), _Up *__p) [[gnu::always_inline]];
        static constexpr size_type max_size(const allocator_type &__a __attribute__((unused))) noexcept [[gnu::always_inline]] {
            return size_t(-1) / sizeof(value_type);
        }
        static constexpr allocator_type select_on_container_copy_construction(const allocator_type &__rhs) [[gnu::always_inline]];
    };
    template <typename _Tp> struct allocator_traits<pmr::polymorphic_allocator<_Tp>> {
        using allocator_type = pmr::polymorphic_allocator<_Tp>;
        using value_type = _Tp;
        using pointer = _Tp *;
        using const_pointer = const _Tp *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = false_type;
        using propagate_on_container_swap = false_type;
        static allocator_type select_on_container_copy_construction(const allocator_type &) noexcept {
            return allocator_type();
        }
        using is_always_equal = false_type;
        template <typename _Up> using rebind_alloc = pmr::polymorphic_allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<pmr::polymorphic_allocator<_Up>>;
        static pointer allocate(allocator_type &__a, size_type __n) [[nodiscard("")]] {
            return __a.allocate(__n);
        }
        static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer) [[nodiscard("")]] {
            return __a.allocate(__n);
        }
        static void deallocate(allocator_type &__a, pointer __p, size_type __n) {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(allocator_type &__a, _Up *__p, _Args &&...__args) {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static constexpr void destroy(allocator_type &, _Up *__p) noexcept(is_nothrow_destructible<_Up>::value) {
            __p->~_Up();
        }
        static constexpr size_type max_size(const allocator_type &) noexcept {
            return size_t(-1) / sizeof(value_type);
        }
    };
}
namespace std {
    namespace pmr {
        template <typename _CharT, typename _Traits = char_traits<_CharT>> using basic_string = std::basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>;
        using string = basic_string<char>;
        using u8string = basic_string<char8_t>;
        using u16string = basic_string<char16_t>;
        using u32string = basic_string<char32_t>;
        using wstring = basic_string<wchar_t>;
    }
}
namespace std {
    template <typename _CharT, typename _Traits, typename _Alloc, typename _Predicate> inline constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type erase_if(basic_string<_CharT, _Traits, _Alloc> &__cont, _Predicate __pred) {
        using namespace __gnu_cxx;
        const auto __osz = __cont.size();
        const auto __end = __cont.end();
        auto __removed = std::__remove_if(__cont.begin(), __end, __ops::__pred_iter(std::ref(__pred)));
        __cont.erase(__removed, __end);
        return __osz - __cont.size();
    }
    template <typename _CharT, typename _Traits, typename _Alloc, typename _Up> inline constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type erase(basic_string<_CharT, _Traits, _Alloc> &__cont, const _Up &__value) {
        using namespace __gnu_cxx;
        const auto __osz = __cont.size();
        const auto __end = __cont.end();
        auto __removed = std::__remove_if(__cont.begin(), __end, __ops::__iter_equals_val(__value));
        __cont.erase(__removed, __end);
        return __osz - __cont.size();
    }
}
namespace std {
    class locale {
    public:
        typedef int category;
        class facet;
        class id;
        class _Impl;
        friend  class facet;
        friend  class _Impl;
        friend template <typename _Facet> bool has_facet(const locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const locale &);
        friend template <typename _Facet> const _Facet *__try_use_facet(const locale &) noexcept;
        friend template <typename _Cache> struct __use_cache;
        static const category none = 0;
        static const category ctype = 1L << 0;
        static const category numeric = 1L << 1;
        static const category collate = 1L << 2;
        static const category time = 1L << 3;
        static const category monetary = 1L << 4;
        static const category messages = 1L << 5;
        static const category all = (ctype | numeric | collate | time | monetary | messages);
        locale() throw();
        locale(const locale &__other) throw();
        explicit locale(const char *__s);
        locale(const locale &__base, const char *__s, category __cat);
        explicit locale(const std::string &__s) : NULL TYPE(__s.c_str()) {
        }
        locale(const locale &__base, const std::string &__s, category __cat) : NULL TYPE(__base, __s.c_str(), __cat) {
        }
        locale(const locale &__base, const locale &__add, category __cat);
        template <typename _Facet> locale(const locale &__other, _Facet *__f);
        ~locale() throw();
        const locale &operator=(const locale &__other) throw();
        template <typename _Facet> locale combine(const locale &__other) const;
        string name() const __attribute__((abi_tag("cxx11")));
        bool operator==(const locale &__other) const throw();
        template <typename _Char, typename _Traits, typename _Alloc> bool operator()(const basic_string<_Char, _Traits, _Alloc> &__s1, const basic_string<_Char, _Traits, _Alloc> &__s2) const;
        static locale global(const locale &__loc);
        static const locale &classic();
    private:
        _Impl *_M_impl;
        static _Impl *_S_classic;
        static _Impl *_S_global;
        static const char *const *const _S_categories;
        enum {
            _S_categories_size = 6 + 6
        };
        static __gthread_once_t _S_once;
        explicit locale(_Impl *) throw();
        static void _S_initialize();
        static void _S_initialize_once() throw();
        static category _S_normalize_category(category);
        void _M_coalesce(const locale &__base, const locale &__add, category __cat);
        static const id *const _S_twinned_facets[];
    };
    class facet {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        mutable _Atomic_word _M_refcount;
        static __c_locale _S_c_locale;
        static const char _S_c_name[2];
        static __gthread_once_t _S_once;
        static void _S_initialize_once();
    protected:
        explicit facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0) {
        }
        virtual ~facet() noexcept;
        static void _S_create_c_locale(__c_locale &__cloc, const char *__s, __c_locale __old = 0);
        static __c_locale _S_clone_c_locale(__c_locale &__cloc) throw();
        static void _S_destroy_c_locale(__c_locale &__cloc);
        static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc, const char *__s);
        static __c_locale _S_get_c_locale();
        static const char *_S_get_c_name() throw() __attribute__((const));
        facet(const facet &) = delete
        facet &operator=(const facet &) = delete
    private:
        void _M_add_reference() const throw() {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() const throw() {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        const facet *_M_sso_shim(const id *) const;
        const facet *_M_cow_shim(const id *) const;
    protected:
        class __shim;
    };
    class id {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        friend template <typename _Facet> const _Facet &use_facet(const locale &);
        friend template <typename _Facet> bool has_facet(const locale &) throw();
        friend template <typename _Facet> const _Facet *__try_use_facet(const locale &) noexcept;
        mutable size_t _M_index;
        static _Atomic_word _S_refcount;
        void operator=(const id &);
        id(const id &);
    public:
        id() {
        }
        size_t _M_id() const throw();
    };
    class _Impl {
    public:
        friend  class locale;
        friend  class locale::facet;
        friend template <typename _Facet> bool has_facet(const locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const locale &);
        friend template <typename _Facet> const _Facet *__try_use_facet(const locale &) noexcept;
        friend template <typename _Cache> struct __use_cache;
    private:
        _Atomic_word _M_refcount;
        const facet **_M_facets;
        size_t _M_facets_size;
        const facet **_M_caches;
        char **_M_names;
        static const locale::id *const _S_id_ctype[];
        static const locale::id *const _S_id_numeric[];
        static const locale::id *const _S_id_collate[];
        static const locale::id *const _S_id_time[];
        static const locale::id *const _S_id_monetary[];
        static const locale::id *const _S_id_messages[];
        static const locale::id *const *const _S_facet_categories[];
        void _M_add_reference() throw() {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() throw() {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        _Impl(const _Impl &, size_t);
        _Impl(const char *, size_t);
        _Impl(size_t) throw();
        ~_Impl() throw();
        _Impl(const _Impl &);
        void operator=(const _Impl &);
        bool _M_check_same_name() {
            bool __ret = true;
            if (this->_M_names[1])
                for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
                    __ret = __builtin_strcmp(this->_M_names[__i], this->_M_names[__i + 1]) == 0;
            return __ret;
        }
        void _M_replace_categories(const _Impl *, category);
        void _M_replace_category(const _Impl *, const locale::id *const *);
        void _M_replace_facet(const _Impl *, const locale::id *);
        void _M_install_facet(const locale::id *, const facet *);
        template <typename _Facet> void _M_init_facet(_Facet *__facet) {
            this->_M_install_facet(& _Facet::id, __facet);
        }
        template <typename _Facet> void _M_init_facet_unchecked(_Facet *__facet) {
            __facet->_M_add_reference();
            this->_M_facets[_Facet::id._M_id()] = __facet;
        }
        void _M_install_cache(const facet *, size_t);
        void _M_init_extra(facet **);
        void _M_init_extra(void *, void *, const char *, const char *);
    };
    template <typename _CharT> class collate : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
    protected:
        __c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate<_CharT>(size_t __refs = 0) : facet(__refs), _M_c_locale_collate(_S_get_c_locale()) {
        }
        explicit collate<_CharT>(__c_locale __cloc, size_t __refs = 0) : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc)) {
        }
        int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const {
            return this->do_compare(__lo1, __hi1, __lo2, __hi2);
        }
        string_type transform(const _CharT *__lo, const _CharT *__hi) const {
            return this->do_transform(__lo, __hi);
        }
        long hash(const _CharT *__lo, const _CharT *__hi) const {
            return this->do_hash(__lo, __hi);
        }
        int _M_compare(const _CharT *, const _CharT *) const throw();
        size_t _M_transform(_CharT *, const _CharT *, size_t) const throw();
    protected:
        virtual ~collate<_CharT>() {
            _S_destroy_c_locale(this->_M_c_locale_collate);
        }
        virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const;
        virtual string_type do_transform(const _CharT *__lo, const _CharT *__hi) const;
        virtual long do_hash(const _CharT *__lo, const _CharT *__hi) const;
    };
    locale::id id;
    template <> int collate<char>::_M_compare(const char *, const char *) const throw();
    template <> size_t collate<char>::_M_transform(char *, const char *, size_t) const throw();
    template <> int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const throw();
    template <> size_t collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, size_t) const throw();
    template <typename _CharT> class collate_byname : public collate<_CharT> {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
        explicit collate_byname<_CharT>(const char *__s, size_t __refs = 0) : collate<_CharT>(__refs) {
            if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                this->_S_destroy_c_locale(this->_M_c_locale_collate);
                this->_S_create_c_locale(this->_M_c_locale_collate, __s);
            }
        }
        explicit collate_byname<_CharT>(const string &__s, size_t __refs = 0) : collate_byname<_CharT>(__s.c_str(), __refs) {
        }
    protected:
        virtual ~collate_byname<_CharT>() {
        }
    };
}
namespace std {
    template <typename _Facet> locale::locale(const locale &__other, _Facet *__f) {
        this->_M_impl = new _Impl(*__other._M_impl, 1);
        try {
            this->_M_impl->_M_install_facet(& _Facet::id, __f);
        } catch (...) {
            this->_M_impl->_M_remove_reference();
            throw;
        }
        delete [] this->_M_impl->_M_names[0];
        this->_M_impl->_M_names[0] = 0;
    }
    template <typename _Facet> locale locale::combine(const locale &__other) const {
        _Impl *__tmp = new _Impl(*this->_M_impl, 1);
        try {
            __tmp->_M_replace_facet(__other._M_impl, & _Facet::id);
        } catch (...) {
            __tmp->_M_remove_reference();
            throw;
        }
        return locale(__tmp);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> bool locale::operator()(const basic_string<_CharT, _Traits, _Alloc> &__s1, const basic_string<_CharT, _Traits, _Alloc> &__s2) const {
        typedef std::collate<_CharT> __collate_type;
        const __collate_type &__collate = use_facet<__collate_type>(*this);
        return (__collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0);
    }
    template <typename _Facet> inline const _Facet *__try_use_facet(const locale &__loc) noexcept {
        const size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        if (__is_same(_Facet, ctype<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, num_get<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, num_put<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, codecvt<char, char, mbstate_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, collate<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, moneypunct<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, moneypunct<char, true>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, money_get<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, money_put<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, numpunct<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, time_get<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, time_put<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, messages<char>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, ctype<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, num_get<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, num_put<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, codecvt<wchar_t, char, mbstate_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, collate<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, moneypunct<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, moneypunct<wchar_t, true>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, money_get<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, money_put<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, numpunct<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, time_get<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, time_put<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, messages<wchar_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, codecvt<char16_t, char, mbstate_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__is_same(_Facet, codecvt<char32_t, char, mbstate_t>))
            return static_cast<const _Facet *>(__facets[__i]);
        if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
            return 0;
        return dynamic_cast<const _Facet *>(__facets[__i]);
    }
    template <typename _Facet> inline bool has_facet(const locale &__loc) throw() {
        static_assert(__is_base_of(locale::facet, _Facet), "template argument must be derived from locale::facet");
        return std::__try_use_facet<_Facet>(__loc) != 0;
    }
    template <typename _Facet> inline const _Facet &use_facet(const locale &__loc) {
        static_assert(__is_base_of(locale::facet, _Facet), "template argument must be derived from locale::facet");
        if (const _Facet *__f = std::__try_use_facet<_Facet>(__loc))
            return *__f;
        __throw_bad_cast();
    }
    template <typename _CharT> int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const throw() {
        return 0;
    }
    template <typename _CharT> size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, size_t) const throw() {
        return 0;
    }
    template <typename _CharT> int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const {
        const string_type __one(__lo1, __hi1);
        const string_type __two(__lo2, __hi2);
        const _CharT *__p = __one.c_str();
        const _CharT *__pend = __one.data() + __one.length();
        const _CharT *__q = __two.c_str();
        const _CharT *__qend = __two.data() + __two.length();
        for (;;) {
            const int __res = this->_M_compare(__p, __q);
            if (__res)
                return __res;
            __p += char_traits<_CharT>::length(__p);
            __q += char_traits<_CharT>::length(__q);
            if (__p == __pend && __q == __qend)
                return 0;
            else if (__p == __pend)
                return -1;
            else if (__q == __qend)
                return 1;
            __p++;
            __q++;
        }
    }
    template <typename _CharT> typename collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const {
        string_type __ret;
        const string_type __str(__lo, __hi);
        const _CharT *__p = __str.c_str();
        const _CharT *__pend = __str.data() + __str.length();
        size_t __len = (__hi - __lo) * 2;
        _CharT *__c = new _CharT [__len];
        try {
            for (;;) {
                size_t __res = this->_M_transform(__c, __p, __len);
                if (__res >= __len) {
                    __len = __res + 1;
                    delete [] __c , __c = 0;
                    __c = new _CharT [__len];
                    __res = this->_M_transform(__c, __p, __len);
                }
                __ret.append(__c, __res);
                __p += char_traits<_CharT>::length(__p);
                if (__p == __pend)
                    break;
                __p++;
                __ret.push_back(_CharT());
            }
        } catch (...) {
            delete [] __c;
            throw;
        }
        delete [] __c;
        return __ret;
    }
    template <typename _CharT> long collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const {
        unsigned long __val = 0;
        for (; __lo < __hi; ++__lo)
            __val = *__lo + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::__digits - 7)));
        return static_cast<long>(__val);
    }
    template<> class collate<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
    protected:
        __c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(size_t __refs);
        explicit collate(__c_locale __cloc, size_t __refs);
        int compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        string_type transform(const char *__lo, const char *__hi) const;
        long hash(const char *__lo, const char *__hi) const;
        int _M_compare(const char *, const char *) const throw();
        size_t _M_transform(char *, const char *, size_t) const throw();
    protected:
        virtual ~collate<char>() noexcept;
        virtual int do_compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        virtual string_type do_transform(const char *__lo, const char *__hi) const;
        virtual long do_hash(const char *__lo, const char *__hi) const;
    };
    template<> class collate_byname<char> : public collate<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit collate_byname(const char *__s, size_t __refs);
        explicit collate_byname(const string &__s, size_t __refs);
    protected:
        virtual ~collate_byname<char>() noexcept;
    };
    template<> class collate<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
    protected:
        __c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(size_t __refs);
        explicit collate(__c_locale __cloc, size_t __refs);
        int compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        string_type transform(const wchar_t *__lo, const wchar_t *__hi) const;
        long hash(const wchar_t *__lo, const wchar_t *__hi) const;
        int _M_compare(const wchar_t *, const wchar_t *) const throw();
        size_t _M_transform(wchar_t *, const wchar_t *, size_t) const throw();
    protected:
        virtual ~collate<wchar_t>() noexcept;
        virtual int do_compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        virtual string_type do_transform(const wchar_t *__lo, const wchar_t *__hi) const;
        virtual long do_hash(const wchar_t *__lo, const wchar_t *__hi) const;
    };
    template<> class collate_byname<wchar_t> : public collate<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit collate_byname(const char *__s, size_t __refs);
        explicit collate_byname(const string &__s, size_t __refs);
    protected:
        virtual ~collate_byname<wchar_t>() noexcept;
    };
}
namespace std {
    enum class errc : int {
        address_family_not_supported = 97,
        address_in_use = 98,
        address_not_available = 99,
        already_connected = 106,
        argument_list_too_long = 7,
        argument_out_of_domain = 33,
        bad_address = 14,
        bad_file_descriptor = 9,
        bad_message = 74,
        broken_pipe = 32,
        connection_aborted = 103,
        connection_already_in_progress = 114,
        connection_refused = 111,
        connection_reset = 104,
        cross_device_link = 18,
        destination_address_required = 89,
        device_or_resource_busy = 16,
        directory_not_empty = 39,
        executable_format_error = 8,
        file_exists = 17,
        file_too_large = 27,
        filename_too_long = 36,
        function_not_supported = 38,
        host_unreachable = 113,
        identifier_removed = 43,
        illegal_byte_sequence = 84,
        inappropriate_io_control_operation = 25,
        interrupted = 4,
        invalid_argument = 22,
        invalid_seek = 29,
        io_error = 5,
        is_a_directory = 21,
        message_size = 90,
        network_down = 100,
        network_reset = 102,
        network_unreachable = 101,
        no_buffer_space = 105,
        no_child_process = 10,
        no_link = 67,
        no_lock_available = 37,
        no_message_available = 61,
        no_message = 42,
        no_protocol_option = 92,
        no_space_on_device = 28,
        no_stream_resources = 63,
        no_such_device_or_address = 6,
        no_such_device = 19,
        no_such_file_or_directory = 2,
        no_such_process = 3,
        not_a_directory = 20,
        not_a_socket = 88,
        not_a_stream = 60,
        not_connected = 107,
        not_enough_memory = 12,
        not_supported = 95,
        operation_canceled = 125,
        operation_in_progress = 115,
        operation_not_permitted = 1,
        operation_not_supported = 95,
        operation_would_block = 11,
        owner_dead = 130,
        permission_denied = 13,
        protocol_error = 71,
        protocol_not_supported = 93,
        read_only_file_system = 30,
        resource_deadlock_would_occur = 35,
        resource_unavailable_try_again = 11,
        result_out_of_range = 34,
        state_not_recoverable = 131,
        stream_timeout = 62,
        text_file_busy = 26,
        timed_out = 110,
        too_many_files_open_in_system = 23,
        too_many_files_open = 24,
        too_many_links = 31,
        too_many_symbolic_link_levels = 40,
        value_too_large = 75,
        wrong_protocol_type = 91
    };
}
namespace std {
    struct __cow_string {
        union {
            const char *_M_p;
            char _M_bytes[8];
        };
        __cow_string();
        __cow_string(const std::string &);
        __cow_string(const char *, size_t);
        __cow_string(const __cow_string &) noexcept;
        __cow_string &operator=(const __cow_string &) noexcept;
        ~__cow_string();
        __cow_string(__cow_string &&) noexcept;
        __cow_string &operator=(__cow_string &&) noexcept;
    };
    typedef basic_string<char> __sso_string;
    class logic_error : public exception {
        __cow_string _M_msg;
    public:
        explicit logic_error(const string &__arg);
        explicit logic_error(const char *);
        logic_error(logic_error &&) noexcept;
        logic_error &operator=(logic_error &&) noexcept;
        logic_error(const logic_error &) noexcept;
        logic_error &operator=(const logic_error &) noexcept;
        virtual ~logic_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class domain_error : public logic_error {
    public:
        explicit domain_error(const string &__arg);
        explicit domain_error(const char *);
        domain_error(const domain_error &) = default
        domain_error &operator=(const domain_error &) = default
        domain_error(domain_error &&) = default
        domain_error &operator=(domain_error &&) = default
        virtual ~domain_error() noexcept;
    };
    class invalid_argument : public logic_error {
    public:
        explicit invalid_argument(const string &__arg);
        explicit invalid_argument(const char *);
        invalid_argument(const invalid_argument &) = default
        invalid_argument &operator=(const invalid_argument &) = default
        invalid_argument(invalid_argument &&) = default
        invalid_argument &operator=(invalid_argument &&) = default
        virtual ~invalid_argument() noexcept;
    };
    class length_error : public logic_error {
    public:
        explicit length_error(const string &__arg);
        explicit length_error(const char *);
        length_error(const length_error &) = default
        length_error &operator=(const length_error &) = default
        length_error(length_error &&) = default
        length_error &operator=(length_error &&) = default
        virtual ~length_error() noexcept;
    };
    class out_of_range : public logic_error {
    public:
        explicit out_of_range(const string &__arg);
        explicit out_of_range(const char *);
        out_of_range(const out_of_range &) = default
        out_of_range &operator=(const out_of_range &) = default
        out_of_range(out_of_range &&) = default
        out_of_range &operator=(out_of_range &&) = default
        virtual ~out_of_range() noexcept;
    };
    class runtime_error : public exception {
        __cow_string _M_msg;
    public:
        explicit runtime_error(const string &__arg);
        explicit runtime_error(const char *);
        runtime_error(runtime_error &&) noexcept;
        runtime_error &operator=(runtime_error &&) noexcept;
        runtime_error(const runtime_error &) noexcept;
        runtime_error &operator=(const runtime_error &) noexcept;
        virtual ~runtime_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class range_error : public runtime_error {
    public:
        explicit range_error(const string &__arg);
        explicit range_error(const char *);
        range_error(const range_error &) = default
        range_error &operator=(const range_error &) = default
        range_error(range_error &&) = default
        range_error &operator=(range_error &&) = default
        virtual ~range_error() noexcept;
    };
    class overflow_error : public runtime_error {
    public:
        explicit overflow_error(const string &__arg);
        explicit overflow_error(const char *);
        overflow_error(const overflow_error &) = default
        overflow_error &operator=(const overflow_error &) = default
        overflow_error(overflow_error &&) = default
        overflow_error &operator=(overflow_error &&) = default
        virtual ~overflow_error() noexcept;
    };
    class underflow_error : public runtime_error {
    public:
        explicit underflow_error(const string &__arg);
        explicit underflow_error(const char *);
        underflow_error(const underflow_error &) = default
        underflow_error &operator=(const underflow_error &) = default
        underflow_error(underflow_error &&) = default
        underflow_error &operator=(underflow_error &&) = default
        virtual ~underflow_error() noexcept;
    };
}
namespace std {
    class error_code;
    class error_condition;
    class system_error;
    template <typename _Tp> struct is_error_code_enum : public false_type {
    };
    template<> struct is_error_code_enum<std::error_category> : public false_type {
    };
    template<> struct is_error_code_enum<int> : public false_type {
    };
    template<> struct is_error_code_enum<std::strong_ordering> : public false_type {
    };
    template<> struct is_error_code_enum<std::error_code> : public false_type {
    };
    template<> struct is_error_code_enum<std::_Bit_iterator> : public false_type {
    };
    template<> struct is_error_code_enum<std::_Bit_const_iterator> : public false_type {
    };
    template<> struct is_error_code_enum<const char *> : public false_type {
    };
    template<> struct is_error_code_enum<float> : public false_type {
    };
    template<> struct is_error_code_enum<__gnu_cxx::__normal_iterator<Base<ChildA, ChildB, ChildC> **, std::vector<Base<ChildA, ChildB, ChildC> *>>> : public false_type {
    };
    template<> struct is_error_code_enum<__gnu_cxx::__normal_iterator<int *, std::vector<int>>> : public false_type {
    };
    template <typename _Tp> struct is_error_condition_enum : public false_type {
    };
    template<> struct is_error_condition_enum<std::error_category> : public false_type {
    };
    template<> struct is_error_condition_enum<std::strong_ordering> : public false_type {
    };
    template<> struct is_error_condition_enum<std::_Bit_iterator> : public false_type {
    };
    template<> struct is_error_condition_enum<std::_Bit_const_iterator> : public false_type {
    };
    template<> struct is_error_condition_enum<__gnu_cxx::__normal_iterator<Base<ChildA, ChildB, ChildC> **, std::vector<Base<ChildA, ChildB, ChildC> *>>> : public false_type {
    };
    template<> struct is_error_condition_enum<__gnu_cxx::__normal_iterator<int *, std::vector<int>>> : public false_type {
    };
    template<> struct is_error_condition_enum<errc> : public true_type {
    };
    template <typename _Tp> constexpr bool is_error_code_enum_v = is_error_code_enum<_Tp>::value;
    template <typename _Tp> constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;
    inline namespace _V2 {
        class error_category {
        public:
            error_category() noexcept = default
            virtual ~error_category();
            error_category(const error_category &) = delete
            error_category &operator=(const error_category &) = delete
            virtual const char *name() const noexcept = 0;
        private:
            virtual __cow_string _M_message(int) const __attribute__((abi_tag("cxx11")));
        public:
            virtual string message(int) const __attribute__((abi_tag("cxx11"))) = 0;
        public:
            virtual error_condition default_error_condition(int __i) const noexcept;
            virtual bool equivalent(int __i, const error_condition &__cond) const noexcept;
            virtual bool equivalent(const error_code &__code, int __i) const noexcept;
            bool operator==(const error_category &__other) const noexcept [[nodiscard("")]] {
                return this == &__other;
            }
            strong_ordering operator<=>(const error_category &__rhs) const noexcept [[nodiscard("")]] {
                return std::compare_three_way()(this, &__rhs);
            }
        };
        const error_category &generic_category() noexcept [[nodiscard("")]] [[gnu::const]];
        const error_category &system_category() noexcept [[nodiscard("")]] [[gnu::const]];
    }
    namespace __adl_only {
        void make_error_code() = delete
        void make_error_condition() = delete
    }
    class error_code {
        template <typename _ErrorCodeEnum> using _Check = __enable_if_t<is_error_code_enum<_ErrorCodeEnum>::value>;
    public:
        error_code() noexcept : _M_value(0), _M_cat(&system_category()) {
        }
        error_code(int __v, const error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) {
        }
        template <typename _ErrorCodeEnum, typename = _Check<_ErrorCodeEnum>> error_code(_ErrorCodeEnum __e) noexcept {
            using __adl_only::make_error_code;
            *this = make_error_code(__e);
        }
        template<> error_code<std::io_errc, void>(std::io_errc __e) noexcept        error_code(const error_code &) noexcept : _M_value(._M_value), _M_cat(._M_cat) = default        error_code &operator=(const error_code &) = default
        void assign(int __v, const error_category &__cat) noexcept {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        void clear() noexcept {
            this->assign(0, system_category());
        }
        int value() const noexcept [[nodiscard("")]] {
            return this->_M_value;
        }
        const error_category &category() const noexcept [[nodiscard("")]] {
            return *this->_M_cat;
        }
        error_condition default_error_condition() const noexcept;
        string message() const __attribute__((abi_tag("cxx11"))) {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept [[nodiscard("")]] {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const error_category *_M_cat;
    };
    inline error_code make_error_code(errc __e) noexcept [[nodiscard("")]] {
        return error_code(static_cast<int>(__e), generic_category());
    }
    inline strong_ordering operator<=>(const error_code &__lhs, const error_code &__rhs) noexcept [[nodiscard("")]] {
        if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)
            return __c;
        return __lhs.value() <=> __rhs.value();
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const error_code &__e) {
        return (__os << __e.category().name() << ':' << __e.value());
    }
    class error_condition {
        template <typename _ErrorConditionEnum> using _Check = __enable_if_t<is_error_condition_enum<_ErrorConditionEnum>::value>;
    public:
        error_condition() noexcept : _M_value(0), _M_cat(&generic_category()) {
        }
        error_condition(int __v, const error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) {
        }
        template <typename _ErrorConditionEnum, typename = _Check<_ErrorConditionEnum>> error_condition(_ErrorConditionEnum __e) noexcept {
            using __adl_only::make_error_condition;
            *this = make_error_condition(__e);
        }
        error_condition(const error_condition &) = default
        error_condition &operator=(const error_condition &) = default
        void assign(int __v, const error_category &__cat) noexcept {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        void clear() noexcept {
            this->assign(0, generic_category());
        }
        int value() const noexcept [[nodiscard("")]] {
            return this->_M_value;
        }
        const error_category &category() const noexcept [[nodiscard("")]] {
            return *this->_M_cat;
        }
        string message() const __attribute__((abi_tag("cxx11"))) {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept [[nodiscard("")]] {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const error_category *_M_cat;
    };
    inline error_condition make_error_condition(errc __e) noexcept [[nodiscard("")]] {
        return error_condition(static_cast<int>(__e), generic_category());
    }
    inline bool operator==(const error_code &__lhs, const error_code &__rhs) noexcept [[nodiscard("")]] {
        return __lhs.category() == __rhs.category() && __lhs.value() == __rhs.value();
    }
    inline bool operator==(const error_code &__lhs, const error_condition &__rhs) noexcept [[nodiscard("")]] {
        return __lhs.category().equivalent(__lhs.value(), __rhs) || __rhs.category().equivalent(__lhs, __rhs.value());
    }
    inline bool operator==(const error_condition &__lhs, const error_condition &__rhs) noexcept [[nodiscard("")]] {
        return __lhs.category() == __rhs.category() && __lhs.value() == __rhs.value();
    }
    inline strong_ordering operator<=>(const error_condition &__lhs, const error_condition &__rhs) noexcept [[nodiscard("")]] {
        if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)
            return __c;
        return __lhs.value() <=> __rhs.value();
    }
    class system_error : public std::runtime_error {
    private:
        error_code _M_code;
    public:
        system_error(error_code __ec = error_code()) : runtime_error(__ec.message()), _M_code(__ec) {
        }
        system_error(error_code __ec, const string &__what) : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) {
        }
        system_error(error_code __ec, const char *__what) : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) {
        }
        system_error(int __v, const error_category &__ecat, const char *__what) : NULL TYPE(error_code(__v, __ecat), __what) {
        }
        system_error(int __v, const error_category &__ecat) : runtime_error(error_code(__v, __ecat).message()), _M_code(__v, __ecat) {
        }
        system_error(int __v, const error_category &__ecat, const string &__what) : runtime_error(__what + ": " + error_code(__v, __ecat).message()), _M_code(__v, __ecat) {
        }
        system_error(const system_error &) = default
        system_error &operator=(const system_error &) = default
        virtual ~system_error() noexcept;
        const error_code &code() const noexcept {
            return this->_M_code;
        }
    };
}
namespace std {
    template<> struct hash<error_code> : public __hash_base<size_t, error_code> {
        size_t operator()(const error_code &__e) const noexcept {
            const size_t __tmp = std::_Hash_impl::hash(__e.value());
            return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
        }
    };
    template<> struct hash<error_condition> : public __hash_base<size_t, error_condition> {
        size_t operator()(const error_condition &__e) const noexcept {
            const size_t __tmp = std::_Hash_impl::hash(__e.value());
            return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
        }
    };
}
namespace std {
    enum _Ios_Fmtflags {
        _S_boolalpha = 1L << 0,
        _S_dec = 1L << 1,
        _S_fixed = 1L << 2,
        _S_hex = 1L << 3,
        _S_internal = 1L << 4,
        _S_left = 1L << 5,
        _S_oct = 1L << 6,
        _S_right = 1L << 7,
        _S_scientific = 1L << 8,
        _S_showbase = 1L << 9,
        _S_showpoint = 1L << 10,
        _S_showpos = 1L << 11,
        _S_skipws = 1L << 12,
        _S_unitbuf = 1L << 13,
        _S_uppercase = 1L << 14,
        _S_adjustfield = _S_left | _S_right | _S_internal,
        _S_basefield = _S_dec | _S_oct | _S_hex,
        _S_floatfield = _S_scientific | _S_fixed,
        _S_ios_fmtflags_end = 1L << 16,
        _S_ios_fmtflags_max = 2147483647,
        _S_ios_fmtflags_min = ~2147483647
    };
    inline constexpr _Ios_Fmtflags operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b) {
        return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr _Ios_Fmtflags operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) {
        return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr _Ios_Fmtflags operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b) {
        return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr _Ios_Fmtflags operator~(_Ios_Fmtflags __a) {
        return _Ios_Fmtflags(~static_cast<int>(__a));
    }
    inline const _Ios_Fmtflags &operator|=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) {
        return __a = __a | __b;
    }
    inline const _Ios_Fmtflags &operator&=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) {
        return __a = __a & __b;
    }
    inline const _Ios_Fmtflags &operator^=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) {
        return __a = __a ^ __b;
    }
    enum _Ios_Openmode {
        _S_app = 1L << 0,
        _S_ate = 1L << 1,
        _S_bin = 1L << 2,
        _S_in = 1L << 3,
        _S_out = 1L << 4,
        _S_trunc = 1L << 5,
        _S_noreplace = 1L << 6,
        _S_ios_openmode_end = 1L << 16,
        _S_ios_openmode_max = 2147483647,
        _S_ios_openmode_min = ~2147483647
    };
    inline constexpr _Ios_Openmode operator&(_Ios_Openmode __a, _Ios_Openmode __b) {
        return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr _Ios_Openmode operator|(_Ios_Openmode __a, _Ios_Openmode __b) {
        return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr _Ios_Openmode operator^(_Ios_Openmode __a, _Ios_Openmode __b) {
        return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr _Ios_Openmode operator~(_Ios_Openmode __a) {
        return _Ios_Openmode(~static_cast<int>(__a));
    }
    inline const _Ios_Openmode &operator|=(_Ios_Openmode &__a, _Ios_Openmode __b) {
        return __a = __a | __b;
    }
    inline const _Ios_Openmode &operator&=(_Ios_Openmode &__a, _Ios_Openmode __b) {
        return __a = __a & __b;
    }
    inline const _Ios_Openmode &operator^=(_Ios_Openmode &__a, _Ios_Openmode __b) {
        return __a = __a ^ __b;
    }
    enum _Ios_Iostate {
        _S_goodbit = 0,
        _S_badbit = 1L << 0,
        _S_eofbit = 1L << 1,
        _S_failbit = 1L << 2,
        _S_ios_iostate_end = 1L << 16,
        _S_ios_iostate_max = 2147483647,
        _S_ios_iostate_min = ~2147483647
    };
    inline constexpr _Ios_Iostate operator&(_Ios_Iostate __a, _Ios_Iostate __b) {
        return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr _Ios_Iostate operator|(_Ios_Iostate __a, _Ios_Iostate __b) {
        return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr _Ios_Iostate operator^(_Ios_Iostate __a, _Ios_Iostate __b) {
        return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr _Ios_Iostate operator~(_Ios_Iostate __a) {
        return _Ios_Iostate(~static_cast<int>(__a));
    }
    inline const _Ios_Iostate &operator|=(_Ios_Iostate &__a, _Ios_Iostate __b) {
        return __a = __a | __b;
    }
    inline const _Ios_Iostate &operator&=(_Ios_Iostate &__a, _Ios_Iostate __b) {
        return __a = __a & __b;
    }
    inline const _Ios_Iostate &operator^=(_Ios_Iostate &__a, _Ios_Iostate __b) {
        return __a = __a ^ __b;
    }
    enum _Ios_Seekdir {
        _S_beg = 0,
        _S_cur = 1,
        _S_end = 2,
        _S_ios_seekdir_end = 1L << 16
    };
    enum class io_errc : int {
        stream = 1
    };
    template<> struct is_error_code_enum<io_errc> : public true_type {
    };
    const error_category &iostream_category() noexcept [[nodiscard("")]] [[gnu::const]];
    inline error_code make_error_code(io_errc __e) noexcept [[nodiscard("")]] {
        return error_code(static_cast<int>(__e), iostream_category());
    }
    inline error_condition make_error_condition(io_errc __e) noexcept [[nodiscard("")]] {
        return error_condition(static_cast<int>(__e), iostream_category());
    }
    class ios_base {
    public:
        class __attribute__((abi_tag("cxx11"))) failure : public system_error {
        public:
            explicit failure(const string &__str);
            explicit failure(const string &, const error_code &);
            explicit failure(const char *, const error_code & = io_errc::stream);
            virtual ~failure() throw();
            virtual const char *what() const throw();
        };
        typedef _Ios_Fmtflags fmtflags;
        static const fmtflags boolalpha = _S_boolalpha;
        static const fmtflags dec = _S_dec;
        static const fmtflags fixed = _S_fixed;
        static const fmtflags hex = _S_hex;
        static const fmtflags internal = _S_internal;
        static const fmtflags left = _S_left;
        static const fmtflags oct = _S_oct;
        static const fmtflags right = _S_right;
        static const fmtflags scientific = _S_scientific;
        static const fmtflags showbase = _S_showbase;
        static const fmtflags showpoint = _S_showpoint;
        static const fmtflags showpos = _S_showpos;
        static const fmtflags skipws = _S_skipws;
        static const fmtflags unitbuf = _S_unitbuf;
        static const fmtflags uppercase = _S_uppercase;
        static const fmtflags adjustfield = _S_adjustfield;
        static const fmtflags basefield = _S_basefield;
        static const fmtflags floatfield = _S_floatfield;
        typedef _Ios_Iostate iostate;
        static const iostate badbit = _S_badbit;
        static const iostate eofbit = _S_eofbit;
        static const iostate failbit = _S_failbit;
        static const iostate goodbit = _S_goodbit;
        typedef _Ios_Openmode openmode;
        static const openmode app = _S_app;
        static const openmode ate = _S_ate;
        static const openmode binary = _S_bin;
        static const openmode in = _S_in;
        static const openmode out = _S_out;
        static const openmode trunc = _S_trunc;
        static const openmode __noreplace = _S_noreplace;
        typedef _Ios_Seekdir seekdir;
        static const seekdir beg = _S_beg;
        static const seekdir cur = _S_cur;
        static const seekdir end = _S_end;
        enum event {
            erase_event,
            imbue_event,
            copyfmt_event
        };
        typedef void (*event_callback)(event, ios_base &, int);
        void register_callback(event_callback __fn, int __index);
    protected:
        streamsize _M_precision;
        streamsize _M_width;
        fmtflags _M_flags;
        iostate _M_exception;
        iostate _M_streambuf_state;
        struct _Callback_list {
            _Callback_list *_M_next;
            ios_base::event_callback _M_fn;
            int _M_index;
            _Atomic_word _M_refcount;
            _Callback_list(ios_base::event_callback __fn, int __index, _Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) {
            }
            void _M_add_reference() {
                __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
            }
            int _M_remove_reference() {
                ;
                int __res = __gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1);
                if (__res == 0) {
                    ;
                }
                return __res;
            }
        };
        _Callback_list *_M_callbacks;
        void _M_call_callbacks(event __ev) throw();
        void _M_dispose_callbacks() throw();
        struct _Words {
            void *_M_pword;
            long _M_iword;
            _Words() : _M_pword(0), _M_iword(0) {
            }
        };
        _Words _M_word_zero;
        enum {
            _S_local_word_size = 8
        };
        _Words _M_local_word[8];
        int _M_word_size;
        _Words *_M_word;
        _Words &_M_grow_words(int __index, bool __iword);
        locale _M_ios_locale;
        void _M_init() throw();
    public:
        class Init {
            friend  class ios_base;
        public:
            Init();
            ~Init();
            Init(const Init &) = default
            Init &operator=(const Init &) = default
        private:
            static _Atomic_word _S_refcount;
            static bool _S_synced_with_stdio;
        };
        fmtflags flags() const {
            return this->_M_flags;
        }
        fmtflags flags(fmtflags __fmtfl) {
            fmtflags __old = this->_M_flags;
            this->_M_flags = __fmtfl;
            return __old;
        }
        fmtflags setf(fmtflags __fmtfl) {
            fmtflags __old = this->_M_flags;
            this->_M_flags |= __fmtfl;
            return __old;
        }
        fmtflags setf(fmtflags __fmtfl, fmtflags __mask) {
            fmtflags __old = this->_M_flags;
            this->_M_flags &= ~ __mask;
            this->_M_flags |= (__fmtfl & __mask);
            return __old;
        }
        void unsetf(fmtflags __mask) {
            this->_M_flags &= ~ __mask;
        }
        streamsize precision() const {
            return this->_M_precision;
        }
        streamsize precision(streamsize __prec) {
            streamsize __old = this->_M_precision;
            this->_M_precision = __prec;
            return __old;
        }
        streamsize width() const {
            return this->_M_width;
        }
        streamsize width(streamsize __wide) {
            streamsize __old = this->_M_width;
            this->_M_width = __wide;
            return __old;
        }
        static bool sync_with_stdio(bool __sync = true);
        locale imbue(const locale &__loc) throw();
        locale getloc() const {
            return this->_M_ios_locale;
        }
        const locale &_M_getloc() const {
            return this->_M_ios_locale;
        }
        static int xalloc() throw();
        long &iword(int __ix) {
            _Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, true);
            return __word._M_iword;
        }
        void *&pword(int __ix) {
            _Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, false);
            return __word._M_pword;
        }
        virtual ~ios_base() throw();
    protected:
        ios_base() throw();
    public:
        ios_base(const ios_base &) = delete
        ios_base &operator=(const ios_base &) = delete
    protected:
        void _M_move(ios_base &) noexcept;
        void _M_swap(ios_base &__rhs) noexcept;
    };
    inline ios_base &boolalpha(ios_base &__base) {
        __base.setf(ios_base::boolalpha);
        return __base;
    }
    inline ios_base &noboolalpha(ios_base &__base) {
        __base.unsetf(ios_base::boolalpha);
        return __base;
    }
    inline ios_base &showbase(ios_base &__base) {
        __base.setf(ios_base::showbase);
        return __base;
    }
    inline ios_base &noshowbase(ios_base &__base) {
        __base.unsetf(ios_base::showbase);
        return __base;
    }
    inline ios_base &showpoint(ios_base &__base) {
        __base.setf(ios_base::showpoint);
        return __base;
    }
    inline ios_base &noshowpoint(ios_base &__base) {
        __base.unsetf(ios_base::showpoint);
        return __base;
    }
    inline ios_base &showpos(ios_base &__base) {
        __base.setf(ios_base::showpos);
        return __base;
    }
    inline ios_base &noshowpos(ios_base &__base) {
        __base.unsetf(ios_base::showpos);
        return __base;
    }
    inline ios_base &skipws(ios_base &__base) {
        __base.setf(ios_base::skipws);
        return __base;
    }
    inline ios_base &noskipws(ios_base &__base) {
        __base.unsetf(ios_base::skipws);
        return __base;
    }
    inline ios_base &uppercase(ios_base &__base) {
        __base.setf(ios_base::uppercase);
        return __base;
    }
    inline ios_base &nouppercase(ios_base &__base) {
        __base.unsetf(ios_base::uppercase);
        return __base;
    }
    inline ios_base &unitbuf(ios_base &__base) {
        __base.setf(ios_base::unitbuf);
        return __base;
    }
    inline ios_base &nounitbuf(ios_base &__base) {
        __base.unsetf(ios_base::unitbuf);
        return __base;
    }
    inline ios_base &internal(ios_base &__base) {
        __base.setf(ios_base::internal, ios_base::adjustfield);
        return __base;
    }
    inline ios_base &left(ios_base &__base) {
        __base.setf(ios_base::left, ios_base::adjustfield);
        return __base;
    }
    inline ios_base &right(ios_base &__base) {
        __base.setf(ios_base::right, ios_base::adjustfield);
        return __base;
    }
    inline ios_base &dec(ios_base &__base) {
        __base.setf(ios_base::dec, ios_base::basefield);
        return __base;
    }
    inline ios_base &hex(ios_base &__base) {
        __base.setf(ios_base::hex, ios_base::basefield);
        return __base;
    }
    inline ios_base &oct(ios_base &__base) {
        __base.setf(ios_base::oct, ios_base::basefield);
        return __base;
    }
    inline ios_base &fixed(ios_base &__base) {
        __base.setf(ios_base::fixed, ios_base::floatfield);
        return __base;
    }
    inline ios_base &scientific(ios_base &__base) {
        __base.setf(ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline ios_base &hexfloat(ios_base &__base) {
        __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline ios_base &defaultfloat(ios_base &__base) {
        __base.unsetf(ios_base::floatfield);
        return __base;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(istream &, char *, streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<_CharT, _Traits>() {
        }
        locale pubimbue(const locale &__loc) {
            locale __tmp(this->getloc());
            this->imbue(__loc);
            this->_M_buf_locale = __loc;
            return __tmp;
        }
        locale getloc() const {
            return this->_M_buf_locale;
        }
        basic_streambuf<_CharT, _Traits> *pubsetbuf(char_type *__s, streamsize __n) {
            return this->setbuf(__s, __n);
        }
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out) {
            return this->seekoff(__off, __way, __mode);
        }
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out) {
            return this->seekpos(__sp, __mode);
        }
        int pubsync() {
            return this->sync();
        }
        streamsize in_avail() {
            const streamsize __ret = this->egptr() - this->gptr();
            return __ret ? __ret : this->showmanyc();
        }
        int_type snextc() {
            int_type __ret = traits_type::eof();
            if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
                __ret = this->sgetc();
            return __ret;
        }
        int_type sbumpc() {
            int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true)) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            } else
                __ret = this->uflow();
            return __ret;
        }
        int_type sgetc() {
            int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true))
                __ret = traits_type::to_int_type(*this->gptr());
            else
                __ret = this->underflow();
            return __ret;
        }
        streamsize sgetn(char_type *__s, streamsize __n) {
            return this->xsgetn(__s, __n);
        }
        int_type sputbackc(char_type __c) {
            int_type __ret;
            const bool __testpos = this->eback() < this->gptr();
            if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[-1]), false))
                __ret = this->pbackfail(traits_type::to_int_type(__c));
            else {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            }
            return __ret;
        }
        int_type sungetc() {
            int_type __ret;
            if (__builtin_expect(this->eback() < this->gptr(), true)) {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            } else
                __ret = this->pbackfail();
            return __ret;
        }
        int_type sputc(char_type __c) {
            int_type __ret;
            if (__builtin_expect(this->pptr() < this->epptr(), true)) {
                *this->pptr() = __c;
                this->pbump(1);
                __ret = traits_type::to_int_type(__c);
            } else
                __ret = this->overflow(traits_type::to_int_type(__c));
            return __ret;
        }
        streamsize sputn(const char_type *__s, streamsize __n) {
            return this->xsputn(__s, __n);
        }
    protected:
        basic_streambuf<_CharT, _Traits>() : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(locale()) {
        }
        char_type *eback() const {
            return this->_M_in_beg;
        }
        char_type *gptr() const {
            return this->_M_in_cur;
        }
        char_type *egptr() const {
            return this->_M_in_end;
        }
        void gbump(int __n) {
            this->_M_in_cur += __n;
        }
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) {
            this->_M_in_beg = __gbeg;
            this->_M_in_cur = __gnext;
            this->_M_in_end = __gend;
        }
        char_type *pbase() const {
            return this->_M_out_beg;
        }
        char_type *pptr() const {
            return this->_M_out_cur;
        }
        char_type *epptr() const {
            return this->_M_out_end;
        }
        void pbump(int __n) {
            this->_M_out_cur += __n;
        }
        void setp(char_type *__pbeg, char_type *__pend) {
            this->_M_out_beg = this->_M_out_cur = __pbeg;
            this->_M_out_end = __pend;
        }
        virtual void imbue(const locale &__loc __attribute__((unused))) {
        }
        virtual basic_streambuf<char_type, _Traits> *setbuf(char_type *, streamsize) {
            return this;
        }
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {
            return pos_type(off_type(-1));
        }
        virtual pos_type seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {
            return pos_type(off_type(-1));
        }
        virtual int sync() {
            return 0;
        }
        virtual streamsize showmanyc() {
            return 0;
        }
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow() {
            return traits_type::eof();
        }
        virtual int_type uflow() {
            int_type __ret = traits_type::eof();
            const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
            if (!__testeof) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            }
            return __ret;
        }
        virtual int_type pbackfail(int_type __c = traits_type::eof() __attribute__((unused))) {
            return traits_type::eof();
        }
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c = traits_type::eof() __attribute__((unused))) {
            return traits_type::eof();
        }
        void __safe_gbump(streamsize __n) {
            this->_M_in_cur += __n;
        }
        void __safe_pbump(streamsize __n) {
            this->_M_out_cur += __n;
        }
    protected:
        basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &);
        basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &);
        void swap(basic_streambuf<_CharT, _Traits> &__sb) {
            std::swap(this->_M_in_beg, __sb._M_in_beg);
            std::swap(this->_M_in_cur, __sb._M_in_cur);
            std::swap(this->_M_in_end, __sb._M_in_end);
            std::swap(this->_M_out_beg, __sb._M_out_beg);
            std::swap(this->_M_out_cur, __sb._M_out_cur);
            std::swap(this->_M_out_end, __sb._M_out_end);
            std::swap(this->_M_buf_locale, __sb._M_buf_locale);
        }
    };
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits>::basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &) = default
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits> &std::basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf<_CharT, _Traits> &) = default
    template<> streamsize __copy_streambufs_eof<char, std::char_traits<char>>(basic_streambuf<char> *__sbin, basic_streambuf<char> *__sbout, bool &__ineof);
    template<> streamsize __copy_streambufs_eof<wchar_t, std::char_traits<wchar_t>>(basic_streambuf<wchar_t> *__sbin, basic_streambuf<wchar_t> *__sbout, bool &__ineof);
}
namespace std {
    template <typename _CharT, typename _Traits> streamsize basic_streambuf<_CharT, _Traits>::xsgetn(char_type *__s, streamsize __n) {
        streamsize __ret = 0;
        while (__ret < __n)
            {
                const streamsize __buf_len = this->egptr() - this->gptr();
                if (__buf_len) {
                    const streamsize __remaining = __n - __ret;
                    const streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(__s, this->gptr(), __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_gbump(__len);
                }
                if (__ret < __n) {
                    const int_type __c = this->uflow();
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        traits_type::assign(*__s++, traits_type::to_char_type(__c));
                        ++__ret;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> streamsize basic_streambuf<_CharT, _Traits>::xsputn(const char_type *__s, streamsize __n) {
        streamsize __ret = 0;
        while (__ret < __n)
            {
                const streamsize __buf_len = this->epptr() - this->pptr();
                if (__buf_len) {
                    const streamsize __remaining = __n - __ret;
                    const streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(this->pptr(), __s, __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_pbump(__len);
                }
                if (__ret < __n) {
                    int_type __c = this->overflow(traits_type::to_int_type(*__s));
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        ++__ret;
                        ++__s;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof) {
        streamsize __ret = 0;
        __ineof = true;
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
            {
                __c = __sbout->sputc(_Traits::to_char_type(__c));
                if (_Traits::eq_int_type(__c, _Traits::eof())) {
                    __ineof = false;
                    break;
                }
                ++__ret;
                __c = __sbin->snextc();
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> inline streamsize __copy_streambufs(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout) {
        bool __ineof;
        return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
    template<> class basic_streambuf<char> {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> streamsize __copy_streambufs_eof<>(basic_streambuf<char> *, basic_streambuf<char> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(istream &, char *, streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<char>();
        locale pubimbue(const locale &__loc);
        locale getloc() const;
        basic_streambuf<char> *pubsetbuf(char_type *__s, streamsize __n);
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        streamsize in_avail();
        int_type snextc();
        int_type sbumpc();
        int_type sgetc();
        streamsize sgetn(char_type *__s, streamsize __n);
        int_type sputbackc(char_type __c);
        int_type sungetc();
        int_type sputc(char_type __c);
        streamsize sputn(const char_type *__s, streamsize __n);
    protected:
        basic_streambuf();
        char_type *eback() const;
        char_type *gptr() const;
        char_type *egptr() const;
        void gbump(int __n);
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
        char_type *pbase() const;
        char_type *pptr() const;
        char_type *epptr() const;
        void pbump(int __n);
        void setp(char_type *__pbeg, char_type *__pend);
        virtual void imbue(const locale &__loc __attribute__((unused)));
        virtual basic_streambuf<char_type, char_traits<char>> *setbuf(char_type *, streamsize);
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode);
        virtual pos_type seekpos(pos_type, ios_base::openmode);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c __attribute__((unused)));
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c __attribute__((unused)));
        void __safe_gbump(streamsize __n);
        void __safe_pbump(streamsize __n);
    protected:
        basic_streambuf(const basic_streambuf<char> &);
        basic_streambuf<char> &operator=(const basic_streambuf<char> &);
        void swap(basic_streambuf<char> &__sb);
    };
    template<> class basic_streambuf<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<char_type, traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> streamsize __copy_streambufs_eof<>(basic_streambuf<wchar_t> *, basic_streambuf<wchar_t> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(istream &, char *, streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        char_type *_M_in_beg;
        char_type *_M_in_cur;
        char_type *_M_in_end;
        char_type *_M_out_beg;
        char_type *_M_out_cur;
        char_type *_M_out_end;
        locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<wchar_t>();
        locale pubimbue(const locale &__loc);
        locale getloc() const;
        basic_streambuf<wchar_t> *pubsetbuf(char_type *__s, streamsize __n);
        pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        streamsize in_avail();
        int_type snextc();
        int_type sbumpc();
        int_type sgetc();
        streamsize sgetn(char_type *__s, streamsize __n);
        int_type sputbackc(char_type __c);
        int_type sungetc();
        int_type sputc(char_type __c);
        streamsize sputn(const char_type *__s, streamsize __n);
    protected:
        basic_streambuf();
        char_type *eback() const;
        char_type *gptr() const;
        char_type *egptr() const;
        void gbump(int __n);
        void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
        char_type *pbase() const;
        char_type *pptr() const;
        char_type *epptr() const;
        void pbump(int __n);
        void setp(char_type *__pbeg, char_type *__pend);
        virtual void imbue(const locale &__loc __attribute__((unused)));
        virtual basic_streambuf<char_type, char_traits<wchar_t>> *setbuf(char_type *, streamsize);
        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode);
        virtual pos_type seekpos(pos_type, ios_base::openmode);
        virtual int sync();
        virtual streamsize showmanyc();
        virtual streamsize xsgetn(char_type *__s, streamsize __n);
        virtual int_type underflow();
        virtual int_type uflow();
        virtual int_type pbackfail(int_type __c __attribute__((unused)));
        virtual streamsize xsputn(const char_type *__s, streamsize __n);
        virtual int_type overflow(int_type __c __attribute__((unused)));
        void __safe_gbump(streamsize __n);
        void __safe_pbump(streamsize __n);
    protected:
        basic_streambuf(const basic_streambuf<wchar_t> &);
        basic_streambuf<wchar_t> &operator=(const basic_streambuf<wchar_t> &);
        void swap(basic_streambuf<wchar_t> &__sb);
    };
}
typedef unsigned long wctype_t;
enum {
    __ISwupper = 0,
    __ISwlower = 1,
    __ISwalpha = 2,
    __ISwdigit = 3,
    __ISwxdigit = 4,
    __ISwspace = 5,
    __ISwprint = 6,
    __ISwgraph = 7,
    __ISwblank = 8,
    __ISwcntrl = 9,
    __ISwpunct = 10,
    __ISwalnum = 11,
    _ISwupper = ((__ISwupper) < 8 ? (int)((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int)((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int)((1UL << (__ISwupper)) >> 8) : (int)((1UL << (__ISwupper)) >> 24)))),
    _ISwlower = ((__ISwlower) < 8 ? (int)((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int)((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int)((1UL << (__ISwlower)) >> 8) : (int)((1UL << (__ISwlower)) >> 24)))),
    _ISwalpha = ((__ISwalpha) < 8 ? (int)((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int)((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int)((1UL << (__ISwalpha)) >> 8) : (int)((1UL << (__ISwalpha)) >> 24)))),
    _ISwdigit = ((__ISwdigit) < 8 ? (int)((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int)((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int)((1UL << (__ISwdigit)) >> 8) : (int)((1UL << (__ISwdigit)) >> 24)))),
    _ISwxdigit = ((__ISwxdigit) < 8 ? (int)((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int)((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int)((1UL << (__ISwxdigit)) >> 8) : (int)((1UL << (__ISwxdigit)) >> 24)))),
    _ISwspace = ((__ISwspace) < 8 ? (int)((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int)((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int)((1UL << (__ISwspace)) >> 8) : (int)((1UL << (__ISwspace)) >> 24)))),
    _ISwprint = ((__ISwprint) < 8 ? (int)((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int)((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int)((1UL << (__ISwprint)) >> 8) : (int)((1UL << (__ISwprint)) >> 24)))),
    _ISwgraph = ((__ISwgraph) < 8 ? (int)((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int)((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int)((1UL << (__ISwgraph)) >> 8) : (int)((1UL << (__ISwgraph)) >> 24)))),
    _ISwblank = ((__ISwblank) < 8 ? (int)((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int)((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int)((1UL << (__ISwblank)) >> 8) : (int)((1UL << (__ISwblank)) >> 24)))),
    _ISwcntrl = ((__ISwcntrl) < 8 ? (int)((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int)((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int)((1UL << (__ISwcntrl)) >> 8) : (int)((1UL << (__ISwcntrl)) >> 24)))),
    _ISwpunct = ((__ISwpunct) < 8 ? (int)((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int)((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int)((1UL << (__ISwpunct)) >> 8) : (int)((1UL << (__ISwpunct)) >> 24)))),
    _ISwalnum = ((__ISwalnum) < 8 ? (int)((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int)((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int)((1UL << (__ISwalnum)) >> 8) : (int)((1UL << (__ISwalnum)) >> 24))))
};
extern "C" {
    extern int iswalnum(wint_t __wc) noexcept(true);
    extern int iswalpha(wint_t __wc) noexcept(true);
    extern int iswcntrl(wint_t __wc) noexcept(true);
    extern int iswdigit(wint_t __wc) noexcept(true);
    extern int iswgraph(wint_t __wc) noexcept(true);
    extern int iswlower(wint_t __wc) noexcept(true);
    extern int iswprint(wint_t __wc) noexcept(true);
    extern int iswpunct(wint_t __wc) noexcept(true);
    extern int iswspace(wint_t __wc) noexcept(true);
    extern int iswupper(wint_t __wc) noexcept(true);
    extern int iswxdigit(wint_t __wc) noexcept(true);
    extern int iswblank(wint_t __wc) noexcept(true);
    extern wctype_t wctype(const char *__property) noexcept(true);
    extern int iswctype(wint_t __wc, wctype_t __desc) noexcept(true);
    extern wint_t towlower(wint_t __wc) noexcept(true);
    extern wint_t towupper(wint_t __wc) noexcept(true);
}
extern "C" {
    typedef const __int32_t *wctrans_t;
    extern wctrans_t wctrans(const char *__property) noexcept(true);
    extern wint_t towctrans(wint_t __wc, wctrans_t __desc) noexcept(true);
    extern int iswalnum_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswalpha_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswcntrl_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswdigit_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswgraph_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswlower_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswprint_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswpunct_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswspace_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswupper_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswxdigit_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswblank_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wctype_t wctype_l(const char *__property, locale_t __locale) noexcept(true);
    extern int iswctype_l(wint_t __wc, wctype_t __desc, locale_t __locale) noexcept(true);
    extern wint_t towlower_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wint_t towupper_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wctrans_t wctrans_l(const char *__property, locale_t __locale) noexcept(true);
    extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, locale_t __locale) noexcept(true);
}
namespace std {
    using ::wctrans_t;
    using ::wctype_t;
    using ::wint_t;
    using ::iswalnum;
    using ::iswalpha;
    using ::iswblank;
    using ::iswcntrl;
    using ::iswctype;
    using ::iswdigit;
    using ::iswgraph;
    using ::iswlower;
    using ::iswprint;
    using ::iswpunct;
    using ::iswspace;
    using ::iswupper;
    using ::iswxdigit;
    using ::towctrans;
    using ::towlower;
    using ::towupper;
    using ::wctrans;
    using ::wctype;
}
namespace std {
    struct ctype_base {
        typedef const int *__to_type;
        typedef unsigned short mask;
        static const mask upper = _ISupper;
        static const mask lower = _ISlower;
        static const mask alpha = _ISalpha;
        static const mask digit = _ISdigit;
        static const mask xdigit = _ISxdigit;
        static const mask space = _ISspace;
        static const mask print = _ISprint;
        static const mask graph = _ISalpha | _ISdigit | _ISpunct;
        static const mask cntrl = _IScntrl;
        static const mask punct = _ISpunct;
        static const mask alnum = _ISalpha | _ISdigit;
        static const mask blank = _ISblank;
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT> {
    public:
        using pointer = void;
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename _Traits::int_type int_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_istream<_CharT, _Traits> istream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2>>::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2 *, bool);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
    private:
        mutable streambuf_type *_M_sbuf;
        int_type _M_c;
    public:
        constexpr istreambuf_iterator<_CharT, _Traits>() noexcept : _M_sbuf(0), _M_c(traits_type::eof()) {
        }
        constexpr istreambuf_iterator<_CharT, _Traits>(default_sentinel_t) noexcept : istreambuf_iterator<_CharT, _Traits>() {
        }
        istreambuf_iterator<_CharT, _Traits>(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        ~istreambuf_iterator<_CharT, _Traits>() = default
        istreambuf_iterator<_CharT, _Traits>(istream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) {
        }
        istreambuf_iterator<_CharT, _Traits>(streambuf_type *__s) noexcept : _M_sbuf(__s), _M_c(traits_type::eof()) {
        }
        istreambuf_iterator<_CharT, _Traits> &operator=(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        char_type operator*() const [[nodiscard("")]] {
            int_type __c = this->_M_get();
            return traits_type::to_char_type(__c);
        }
        istreambuf_iterator<_CharT, _Traits> &operator++() {
            ;
            this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return *this;
        }
        istreambuf_iterator<_CharT, _Traits> operator++(int) {
            ;
            istreambuf_iterator<_CharT, _Traits> __old = *this;
            __old._M_c = this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return __old;
        }
        bool equal(const istreambuf_iterator<_CharT, _Traits> &__b) const [[nodiscard("")]] {
            return this->_M_at_eof() == __b._M_at_eof();
        }
    private:
        int_type _M_get() const {
            int_type __ret = this->_M_c;
            if (this->_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = this->_M_sbuf->sgetc()))
                this->_M_sbuf = 0;
            return __ret;
        }
        bool _M_at_eof() const {
            return _S_is_eof(this->_M_get());
        }
        static bool _S_is_eof(int_type __c) {
            const int_type __eof = traits_type::eof();
            return traits_type::eq_int_type(__c, __eof);
        }
        friend bool operator==(const istreambuf_iterator<_CharT, _Traits> &__i, default_sentinel_t __s) [[nodiscard("")]] {
            return __i._M_at_eof();
        }
;
    };
    template <typename _CharT, typename _Traits> inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b) [[nodiscard("")]] {
        return __a.equal(__b);
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator : public iterator<output_iterator_tag, void, void, void, void> {
    public:
        using difference_type = ptrdiff_t;
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2>>::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
    private:
        streambuf_type *_M_sbuf;
        bool _M_failed;
    public:
        constexpr ostreambuf_iterator<_CharT, _Traits>() noexcept : _M_sbuf(nullptr), _M_failed(true) {
        }
        ostreambuf_iterator<_CharT, _Traits>(ostream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_failed(!this->_M_sbuf) {
        }
        ostreambuf_iterator<_CharT, _Traits>(streambuf_type *__s) noexcept : _M_sbuf(__s), _M_failed(!this->_M_sbuf) {
        }
        ostreambuf_iterator<_CharT, _Traits> &operator=(_CharT __c) {
            if (!this->_M_failed && _Traits::eq_int_type(this->_M_sbuf->sputc(__c), _Traits::eof()))
                this->_M_failed = true;
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator*() [[nodiscard("")]] {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++(int) {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++() {
            return *this;
        }
        bool failed() const noexcept [[nodiscard("")]] {
            return this->_M_failed;
        }
        ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, streamsize __len) {
            if (__builtin_expect(!this->_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
                this->_M_failed = true;
            return *this;
        }
    };
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type copy(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, ostreambuf_iterator<_CharT> __result) {
        if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed) {
            bool __ineof;
            __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
            if (!__ineof)
                __result._M_failed = true;
        }
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type __copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator<_CharT> __result) {
        const streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator<_CharT> __result) {
        const streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, _CharT *__result) {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf) {
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                    const streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        traits_type::copy(__result, __sb->gptr(), __n);
                        __sb->__safe_gbump(__n);
                        __result += __n;
                        __c = __sb->underflow();
                    } else {
                        *__result++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                    }
                }
        }
        return __result;
    }
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT *__result, bool __strict __attribute__((unused))) {
        if (__n == 0)
            return __result;
        ;
        _CharT *__beg = __result;
        __result += __it._M_sbuf->sgetn(__beg, __n);
        ;
        return __result;
    }
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, istreambuf_iterator<_CharT>>::__type find(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, const _CharT &__val) {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        if (__first._M_sbuf && !__last._M_sbuf) {
            const int_type __ival = traits_type::to_int_type(__val);
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __ival))
                {
                    streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                        if (__p)
                            __n = __p - __sb->gptr();
                        __sb->__safe_gbump(__n);
                        __c = __sb->sgetc();
                    } else
                        __c = __sb->snextc();
                }
            __first._M_c = __eof;
        }
        return __first;
    }
    template <typename _CharT, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, void>::__type advance(istreambuf_iterator<_CharT> &__i, _Distance __n) {
        if (__n == 0)
            return;
        do {
            if (std::__is_constant_evaluated() && !bool(__n > 0))
                __builtin_unreachable();
        } while (false);
        ;
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        streambuf_type *__sb = __i._M_sbuf;
        while (__n > 0)
            {
                streamsize __size = __sb->egptr() - __sb->gptr();
                if (__size > __n) {
                    __sb->__safe_gbump(__n);
                    break;
                }
                __sb->__safe_gbump(__size);
                __n -= __size;
                if (traits_type::eq_int_type(__sb->underflow(), __eof)) {
                    ;
                    break;
                }
            }
        __i._M_c = __eof;
    }
}
namespace std {
    template <typename _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const __c_locale &) throw();
    template<> void __convert_to_v<float>(const char *, float &, ios_base::iostate &, const __c_locale &) throw();
    template<> void __convert_to_v<double>(const char *, double &, ios_base::iostate &, const __c_locale &) throw();
    template<> void __convert_to_v<long double>(const char *, long double &, ios_base::iostate &, const __c_locale &) throw();
    template <typename _CharT, typename _Traits> struct __pad {
        static void _S_pad(ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, streamsize __newlen, streamsize __oldlen);
    };
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, size_t __gsize, const _CharT *__first, const _CharT *__last);
    template <typename _CharT> inline ostreambuf_iterator<_CharT> __write(ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len) {
        __s._M_put(__ws, __len);
        return __s;
    }
    template <typename _CharT, typename _OutIter> inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len) {
        for (int __j = 0; __j < __len; __j++ , ++__s)
            *__s = __ws[__j];
        return __s;
    }
    template <typename _CharT> class __ctype_abstract_base : public locale::facet, public ctype_base {
    public:
        typedef _CharT char_type;
        bool is(mask __m, char_type __c) const {
            return this->do_is(__m, __c);
        }
        const char_type *is(const char_type *__lo, const char_type *__hi, mask *__vec) const {
            return this->do_is(__lo, __hi, __vec);
        }
        const char_type *scan_is(mask __m, const char_type *__lo, const char_type *__hi) const {
            return this->do_scan_is(__m, __lo, __hi);
        }
        const char_type *scan_not(mask __m, const char_type *__lo, const char_type *__hi) const {
            return this->do_scan_not(__m, __lo, __hi);
        }
        char_type toupper(char_type __c) const {
            return this->do_toupper(__c);
        }
        const char_type *toupper(char_type *__lo, const char_type *__hi) const {
            return this->do_toupper(__lo, __hi);
        }
        char_type tolower(char_type __c) const {
            return this->do_tolower(__c);
        }
        const char_type *tolower(char_type *__lo, const char_type *__hi) const {
            return this->do_tolower(__lo, __hi);
        }
        char_type widen(char __c) const {
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, char_type *__to) const {
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(char_type __c, char __dfault) const {
            return this->do_narrow(__c, __dfault);
        }
        const char_type *narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const {
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
    protected:
        explicit __ctype_abstract_base<_CharT>(size_t __refs = 0) : facet(__refs) {
        }
        virtual ~__ctype_abstract_base<_CharT>() {
        }
        virtual bool do_is(mask __m, char_type __c) const = 0;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const = 0;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const = 0;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_toupper(char_type __c) const = 0;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_tolower(char_type __c) const = 0;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const = 0;
        virtual char do_narrow(char_type __c, char __dfault) const = 0;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const = 0;
    };
    template<> class __ctype_abstract_base<wchar_t> : public locale::facet, public ctype_base {
    public:
        typedef wchar_t char_type;
        bool is(mask __m, char_type __c) const;
        const char_type *is(const char_type *__lo, const char_type *__hi, mask *__vec) const;
        const char_type *scan_is(mask __m, const char_type *__lo, const char_type *__hi) const;
        const char_type *scan_not(mask __m, const char_type *__lo, const char_type *__hi) const;
        char_type toupper(char_type __c) const;
        const char_type *toupper(char_type *__lo, const char_type *__hi) const;
        char_type tolower(char_type __c) const;
        const char_type *tolower(char_type *__lo, const char_type *__hi) const;
        char_type widen(char __c) const;
        const char *widen(const char *__lo, const char *__hi, char_type *__to) const;
        char narrow(char_type __c, char __dfault) const;
        const char_type *narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const;
    protected:
        explicit __ctype_abstract_base(size_t __refs);
        virtual ~__ctype_abstract_base<wchar_t>() noexcept;
        virtual bool do_is(mask __m, char_type __c) const = 0;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const = 0;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const = 0;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_toupper(char_type __c) const = 0;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_tolower(char_type __c) const = 0;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const = 0;
        virtual char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const = 0;
        virtual char do_narrow(char_type __c, char __dfault) const = 0;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const = 0;
    };
    template <typename _CharT> class ctype : public __ctype_abstract_base<_CharT> {
    public:
        typedef _CharT char_type;
        typedef typename __ctype_abstract_base<_CharT>::mask mask;
        static locale::id id;
        explicit ctype<_CharT>(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) {
        }
    protected:
        virtual ~ctype<_CharT>();
        virtual bool do_is(mask __m, char_type __c) const;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__dest) const;
        virtual char do_narrow(char_type, char __dfault) const;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const;
    };
    locale::id id;
    template <typename _CharT, typename _Traits, typename _Alloc> class ctype<basic_string<_CharT, _Traits, _Alloc>>;
    template<> class ctype<char> : public locale::facet, public ctype_base {
    public:
        typedef char char_type;
    protected:
        __c_locale _M_c_locale_ctype;
        bool _M_del;
        __to_type _M_toupper;
        __to_type _M_tolower;
        const mask *_M_table;
        mutable char _M_widen_ok;
        mutable char _M_widen[256];
        mutable char _M_narrow[256];
        mutable char _M_narrow_ok;
    public:
        static locale::id id;
        static const size_t table_size = 1 + static_cast<unsigned char>(-1);
        explicit ctype(const mask *__table = 0, bool __del = false, size_t __refs = 0);
        explicit ctype(__c_locale __cloc, const mask *__table = 0, bool __del = false, size_t __refs = 0);
        inline bool is(mask __m, char __c) const;
        inline const char *is(const char *__lo, const char *__hi, mask *__vec) const;
        inline const char *scan_is(mask __m, const char *__lo, const char *__hi) const;
        inline const char *scan_not(mask __m, const char *__lo, const char *__hi) const;
        char_type toupper(char_type __c) const {
            return this->do_toupper(__c);
        }
        const char_type *toupper(char_type *__lo, const char_type *__hi) const {
            return this->do_toupper(__lo, __hi);
        }
        char_type tolower(char_type __c) const {
            return this->do_tolower(__c);
        }
        const char_type *tolower(char_type *__lo, const char_type *__hi) const {
            return this->do_tolower(__lo, __hi);
        }
        char_type widen(char __c) const {
            if (this->_M_widen_ok)
                return this->_M_widen[static_cast<unsigned char>(__c)];
            this->_M_widen_init();
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, char_type *__to) const {
            if (this->_M_widen_ok == 1) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_widen_ok)
                this->_M_widen_init();
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(char_type __c, char __dfault) const {
            if (this->_M_narrow[static_cast<unsigned char>(__c)])
                return this->_M_narrow[static_cast<unsigned char>(__c)];
            const char __t = this->do_narrow(__c, __dfault);
            if (__t != __dfault)
                this->_M_narrow[static_cast<unsigned char>(__c)] = __t;
            return __t;
        }
        const char_type *narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const {
            if (__builtin_expect(this->_M_narrow_ok == 1, true)) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_narrow_ok)
                this->_M_narrow_init();
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
        const mask *table() const throw() {
            return this->_M_table;
        }
        static const mask *classic_table() throw();
    protected:
        virtual ~ctype<char>() noexcept;
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const {
            return __c;
        }
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
        virtual char do_narrow(char_type __c, char __dfault __attribute__((unused))) const {
            return __c;
        }
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault __attribute__((unused)), char *__to) const {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
    private:
        void _M_narrow_init() const;
        void _M_widen_init() const;
    };
    template<> class ctype<wchar_t> : public __ctype_abstract_base<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef wctype_t __wmask_type;
    protected:
        __c_locale _M_c_locale_ctype;
        bool _M_narrow_ok;
        char _M_narrow[128];
        wint_t _M_widen[256];
        mask _M_bit[16];
        __wmask_type _M_wmask[16];
    public:
        static locale::id id;
        explicit ctype(size_t __refs = 0);
        explicit ctype(__c_locale __cloc, size_t __refs = 0);
    protected:
        __wmask_type _M_convert_to_wmask(const mask __m) const throw();
        virtual ~ctype<wchar_t>() noexcept;
        virtual bool do_is(mask __m, char_type __c) const;
        virtual const char_type *do_is(const char_type *__lo, const char_type *__hi, mask *__vec) const;
        virtual const char_type *do_scan_is(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual const char_type *do_scan_not(mask __m, const char_type *__lo, const char_type *__hi) const;
        virtual char_type do_toupper(char_type __c) const;
        virtual const char_type *do_toupper(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_tolower(char_type __c) const;
        virtual const char_type *do_tolower(char_type *__lo, const char_type *__hi) const;
        virtual char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const;
        virtual char do_narrow(char_type __c, char __dfault) const;
        virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char __dfault, char *__to) const;
        void _M_initialize_ctype() throw();
    };
    template <typename _CharT> class ctype_byname : public ctype<_CharT> {
    public:
        typedef typename ctype<_CharT>::mask mask;
        explicit ctype_byname<_CharT>(const char *__s, size_t __refs = 0);
        explicit ctype_byname<_CharT>(const string &__s, size_t __refs = 0) : ctype_byname<_CharT>(__s.c_str(), __refs) {
        }
    protected:
        virtual ~ctype_byname<_CharT>() {
        }
    };
    template<> class ctype_byname<char> : public ctype<char> {
    public:
        explicit ctype_byname(const char *__s, size_t __refs = 0);
        explicit ctype_byname(const string &__s, size_t __refs = 0);
    protected:
        virtual ~ctype_byname<char>() noexcept;
    };
    template<> class ctype_byname<wchar_t> : public ctype<wchar_t> {
    public:
        explicit ctype_byname(const char *__s, size_t __refs = 0);
        explicit ctype_byname(const string &__s, size_t __refs = 0);
    protected:
        virtual ~ctype_byname<wchar_t>() noexcept;
    };
}
namespace std {
    bool ctype<char>::is(mask __m, char __c) const {
        return this->_M_table[static_cast<unsigned char>(__c)] & __m;
    }
    const char *ctype<char>::is(const char *__low, const char *__high, mask *__vec) const {
        while (__low < __high)
            *__vec++ = this->_M_table[static_cast<unsigned char>(*__low++)];
        return __high;
    }
    const char *ctype<char>::scan_is(mask __m, const char *__low, const char *__high) const {
        while (__low < __high && !(this->_M_table[static_cast<unsigned char>(*__low)] & __m))
            ++__low;
        return __low;
    }
    const char *ctype<char>::scan_not(mask __m, const char *__low, const char *__high) const {
        while (__low < __high && (this->_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
            ++__low;
        return __low;
    }
}
namespace std {
    class __num_base {
    public:
        enum {
            _S_ominus,
            _S_oplus,
            _S_ox,
            _S_oX,
            _S_odigits,
            _S_odigits_end = _S_odigits + 16,
            _S_oudigits = _S_odigits_end,
            _S_oudigits_end = _S_oudigits + 16,
            _S_oe = _S_odigits + 14,
            _S_oE = _S_oudigits + 14,
            _S_oend = _S_oudigits_end
        };
        static const char *_S_atoms_out;
        static const char *_S_atoms_in;
        enum {
            _S_iminus,
            _S_iplus,
            _S_ix,
            _S_iX,
            _S_izero,
            _S_ie = _S_izero + 14,
            _S_iE = _S_izero + 20,
            _S_iend = 26
        };
        static void _S_format_float(const ios_base &__io, char *__fptr, char __mod) throw();
    };
    template <typename _CharT> struct __numpunct_cache : public locale::facet {
        const char *_M_grouping;
        size_t _M_grouping_size;
        bool _M_use_grouping;
        const _CharT *_M_truename;
        size_t _M_truename_size;
        const _CharT *_M_falsename;
        size_t _M_falsename_size;
        _CharT _M_decimal_point;
        _CharT _M_thousands_sep;
        _CharT _M_atoms_out[36];
        _CharT _M_atoms_in[26];
        bool _M_allocated;
        __numpunct_cache<_CharT>(size_t __refs = 0) : facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false) {
        }
        ~__numpunct_cache<_CharT>();
        void _M_cache(const locale &__loc);
    private:
        __numpunct_cache<_CharT> &operator=(const __numpunct_cache<_CharT> &);
        explicit __numpunct_cache<_CharT>(const __numpunct_cache<_CharT> &);
    };
    template <typename _CharT> __numpunct_cache<_CharT>::~__numpunct_cache<_CharT>() {
        if (this->_M_allocated) {
            delete [] this->_M_grouping;
            delete [] this->_M_truename;
            delete [] this->_M_falsename;
        }
    }
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct : public locale::facet {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            typedef __numpunct_cache<_CharT> __cache_type;
        protected:
            __cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct<_CharT>(size_t __refs = 0) : facet(__refs), _M_data(0) {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(__cache_type *__cache, size_t __refs = 0) : facet(__refs), _M_data(__cache) {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(__c_locale __cloc, size_t __refs = 0) : facet(__refs), _M_data(0) {
                this->_M_initialize_numpunct(__cloc);
            }
            char_type decimal_point() const {
                return this->do_decimal_point();
            }
            char_type thousands_sep() const {
                return this->do_thousands_sep();
            }
            string grouping() const {
                return this->do_grouping();
            }
            string_type truename() const {
                return this->do_truename();
            }
            string_type falsename() const {
                return this->do_falsename();
            }
        protected:
            virtual ~numpunct<_CharT>();
            virtual char_type do_decimal_point() const {
                return this->_M_data->_M_decimal_point;
            }
            virtual char_type do_thousands_sep() const {
                return this->_M_data->_M_thousands_sep;
            }
            virtual string do_grouping() const {
                return this->_M_data->_M_grouping;
            }
            virtual string_type do_truename() const {
                return this->_M_data->_M_truename;
            }
            virtual string_type do_falsename() const {
                return this->_M_data->_M_falsename;
            }
            void _M_initialize_numpunct(__c_locale __cloc = 0);
        };
        locale::id id;
        template <> numpunct<char>::~numpunct<char>() noexcept;
        template <> void numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
        template <> numpunct<wchar_t>::~numpunct<wchar_t>() noexcept;
        template <> void numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);
        template <typename _CharT> class numpunct_byname : public numpunct<_CharT> {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            explicit numpunct_byname<_CharT>(const char *__s, size_t __refs = 0) : numpunct<_CharT>(__refs) {
                if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                    __c_locale __tmp;
                    this->_S_create_c_locale(__tmp, __s);
                    this->_M_initialize_numpunct(__tmp);
                    this->_S_destroy_c_locale(__tmp);
                }
            }
            explicit numpunct_byname<_CharT>(const string &__s, size_t __refs = 0) : numpunct_byname<_CharT>(__s.c_str(), __refs) {
            }
        protected:
            virtual ~numpunct_byname<_CharT>() {
            }
        };
    }
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _InIter iter_type;
        static locale::id id;
        explicit num_get<_CharT, _InIter>(size_t __refs = 0) : facet(__refs) {
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, bool &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long long &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, float &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, double &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long double &__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, void *&__v) const {
            return this->do_get(__in, __end, __io, __err, __v);
        }
    protected:
        virtual ~num_get<_CharT, _InIter>() {
        }
        iter_type _M_extract_float(iter_type, iter_type, ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const {
            int __ret = -1;
            if (__len <= 10) {
                if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
                    __ret = __c - _CharT2('0');
            } else {
                if (__c >= _CharT2('0') && __c <= _CharT2('9'))
                    __ret = __c - _CharT2('0');
                else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                    __ret = 10 + (__c - _CharT2('a'));
                else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                    __ret = 10 + (__c - _CharT2('A'));
            }
            return __ret;
        }
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const {
            int __ret = -1;
            const char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
            if (__q) {
                __ret = __q - __zero;
                if (__ret > 15)
                    __ret -= 6;
            }
            return __ret;
        }
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, long &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, long long &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, void *&) const;
    };
    locale::id id;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _OutIter iter_type;
        static locale::id id;
        explicit num_put<_CharT, _OutIter>(size_t __refs = 0) : facet(__refs) {
        }
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, double __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long double __v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, const void *__v) const {
            return this->do_put(__s, __io, __fill, __v);
        }
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~num_put<_CharT, _OutIter>() {
        }
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long __v) const {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long __v) const {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long __v) const {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual iter_type do_put(iter_type, ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, ios_base &, char_type, const void *) const;
    };
    locale::id id;
    template <typename _CharT> inline bool isspace(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::space, __c);
    }
    template <typename _CharT> inline bool isprint(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::print, __c);
    }
    template <typename _CharT> inline bool iscntrl(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::cntrl, __c);
    }
    template <typename _CharT> inline bool isupper(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::upper, __c);
    }
    template <typename _CharT> inline bool islower(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::lower, __c);
    }
    template <typename _CharT> inline bool isalpha(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alpha, __c);
    }
    template <typename _CharT> inline bool isdigit(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::digit, __c);
    }
    template <typename _CharT> inline bool ispunct(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::punct, __c);
    }
    template <typename _CharT> inline bool isxdigit(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::xdigit, __c);
    }
    template <typename _CharT> inline bool isalnum(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alnum, __c);
    }
    template <typename _CharT> inline bool isgraph(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::graph, __c);
    }
    template <typename _CharT> inline bool isblank(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::blank, __c);
    }
    template <typename _CharT> inline _CharT toupper(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).toupper(__c);
    }
    template <typename _CharT> inline _CharT tolower(_CharT __c, const locale &__loc) {
        return use_facet<ctype<_CharT>>(__loc).tolower(__c);
    }
}
namespace std {
    template <typename _Facet> struct __use_cache {
        const _Facet *operator()(const locale &__loc) const;
    };
    template <typename _CharT> struct __use_cache<__numpunct_cache<_CharT>> {
        const __numpunct_cache<_CharT> *operator()(const locale &__loc) const {
            const size_t __i = numpunct<_CharT>::id._M_id();
            const locale::facet **__caches = __loc._M_impl->_M_caches;
            if (!__caches[__i]) {
                __numpunct_cache<_CharT> *__tmp = 0;
                try {
                    __tmp = new __numpunct_cache<_CharT>;
                    __tmp->_M_cache(__loc);
                } catch (...) {
                    delete __tmp;
                    throw;
                }
                __loc._M_impl->_M_install_cache(__tmp, __i);
            }
            return static_cast<const __numpunct_cache<_CharT> *>(__caches[__i]);
        }
    };
    template <typename _CharT> void __numpunct_cache<_CharT>::_M_cache(const locale &__loc) {
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);
        char *__grouping = 0;
        _CharT *__truename = 0;
        _CharT *__falsename = 0;
        try {
            const string &__g = __np.grouping();
            this->_M_grouping_size = __g.size();
            __grouping = new char [this->_M_grouping_size];
            __g.copy(__grouping, this->_M_grouping_size);
            this->_M_use_grouping = (this->_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0 && (__grouping[0] != __gnu_cxx::__numeric_traits<char>::__max));
            const basic_string<_CharT> &__tn = __np.truename();
            this->_M_truename_size = __tn.size();
            __truename = new _CharT [this->_M_truename_size];
            __tn.copy(__truename, this->_M_truename_size);
            const basic_string<_CharT> &__fn = __np.falsename();
            this->_M_falsename_size = __fn.size();
            __falsename = new _CharT [this->_M_falsename_size];
            __fn.copy(__falsename, this->_M_falsename_size);
            this->_M_decimal_point = __np.decimal_point();
            this->_M_thousands_sep = __np.thousands_sep();
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
            __ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, this->_M_atoms_out);
            __ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, this->_M_atoms_in);
            this->_M_grouping = __grouping;
            this->_M_truename = __truename;
            this->_M_falsename = __falsename;
            this->_M_allocated = true;
        } catch (...) {
            delete [] __grouping;
            delete [] __truename;
            delete [] __falsename;
            throw;
        }
    }
    bool __verify_grouping(const char *__grouping, size_t __grouping_size, const string &__grouping_tmp) throw() __attribute__((pure));
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, ios_base &__io, ios_base::iostate &__err, string &__xtrc) const __attribute__((abi_tag("cxx11"))) {
        typedef char_traits<_CharT> __traits_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        char_type __c = char_type();
        bool __testeof = __beg == __end;
        if (!__testeof) {
            __c = *__beg;
            const bool __plus = __c == __lit[__num_base::_S_iplus];
            if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                __xtrc += __plus ? '+' : '-';
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_mantissa = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero]) {
                    if (!__found_mantissa) {
                        __xtrc += '0';
                        __found_mantissa = true;
                    }
                    ++__sep_pos;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                } else
                    break;
            }
        bool __found_dec = false;
        bool __found_sci = false;
        string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        const char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    const int __digit = _M_find(__lit_zero, 10, __c);
                    if (__digit != -1) {
                        __xtrc += '0' + __digit;
                        __found_mantissa = true;
                    } else if (__c == __lc->_M_decimal_point && !__found_dec && !__found_sci) {
                        __xtrc += '.';
                        __found_dec = true;
                    } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                        __xtrc += 'e';
                        __found_sci = true;
                        if (++__beg != __end) {
                            __c = *__beg;
                            const bool __plus = __c == __lit[__num_base::_S_iplus];
                            if (__plus || __c == __lit[__num_base::_S_iminus])
                                __xtrc += __plus ? '+' : '-';
                            else
                                continue;
                        } else {
                            __testeof = true;
                            break;
                        }
                    } else
                        break;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (!__found_dec && !__found_sci) {
                            if (__sep_pos) {
                                __found_grouping += static_cast<char>(__sep_pos);
                                __sep_pos = 0;
                            } else {
                                __xtrc.clear();
                                break;
                            }
                        } else
                            break;
                    } else if (__c == __lc->_M_decimal_point) {
                        if (!__found_dec && !__found_sci) {
                            if (__found_grouping.size())
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += '.';
                            __found_dec = true;
                        } else
                            break;
                    } else {
                        const char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                        if (__q) {
                            __xtrc += '0' + (__q - __lit_zero);
                            __found_mantissa = true;
                            ++__sep_pos;
                        } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                            if (__found_grouping.size() && !__found_dec)
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += 'e';
                            __found_sci = true;
                            if (++__beg != __end) {
                                __c = *__beg;
                                const bool __plus = __c == __lit[__num_base::_S_iplus];
                                if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
                                    __xtrc += __plus ? '+' : '-';
                                else
                                    continue;
                            } else {
                                __testeof = true;
                                break;
                            }
                        } else
                            break;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            if (!__found_dec && !__found_sci)
                __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> template <typename _ValueT> _InIter num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, ios_base &__io, ios_base::iostate &__err, _ValueT &__v) const __attribute__((abi_tag("cxx11"))) {
        typedef char_traits<_CharT> __traits_type;
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        char_type __c = char_type();
        const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
        const bool __oct = __basefield == ios_base::oct;
        int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
        bool __testeof = __beg == __end;
        bool __negative = false;
        if (!__testeof) {
            __c = *__beg;
            __negative = __c == __lit[__num_base::_S_iminus];
            if ((__negative || __c == __lit[__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_zero = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero] && (!__found_zero || __base == 10)) {
                    __found_zero = true;
                    ++__sep_pos;
                    if (__basefield == 0)
                        __base = 8;
                    if (__base == 8)
                        __sep_pos = 0;
                } else if (__found_zero && (__c == __lit[__num_base::_S_ix] || __c == __lit[__num_base::_S_iX])) {
                    if (__basefield == 0)
                        __base = 16;
                    if (__base == 16) {
                        __found_zero = false;
                        __sep_pos = 0;
                    } else
                        break;
                } else
                    break;
                if (++__beg != __end) {
                    __c = *__beg;
                    if (!__found_zero)
                        break;
                } else
                    __testeof = true;
            }
        const size_t __len = (__base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base);
        typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
        string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        bool __testfail = false;
        bool __testoverflow = false;
        const __unsigned_type __max = (__negative && __num_traits::__is_signed) ? - static_cast<__unsigned_type>(__num_traits::__min) : __num_traits::__max;
        const __unsigned_type __smax = __max / __base;
        __unsigned_type __result = 0;
        int __digit = 0;
        const char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    __digit = _M_find(__lit_zero, __len, __c);
                    if (__digit == -1)
                        break;
                    if (__result > __smax)
                        __testoverflow = true;
                    else {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                        ++__sep_pos;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (__sep_pos) {
                            __found_grouping += static_cast<char>(__sep_pos);
                            __sep_pos = 0;
                        } else {
                            __testfail = true;
                            break;
                        }
                    } else if (__c == __lc->_M_decimal_point)
                        break;
                    else {
                        const char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                        if (!__q)
                            break;
                        __digit = __q - __lit_zero;
                        if (__digit > 15)
                            __digit -= 6;
                        if (__result > __smax)
                            __testoverflow = true;
                        else {
                            __result *= __base;
                            __testoverflow |= __result > __max - __digit;
                            __result += __digit;
                            ++__sep_pos;
                        }
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        if ((!__sep_pos && !__found_zero && !__found_grouping.size()) || __testfail) {
            __v = 0;
            __err = ios_base::failbit;
        } else if (__testoverflow) {
            if (__negative && __num_traits::__is_signed)
                __v = __num_traits::__min;
            else
                __v = __num_traits::__max;
            __err = ios_base::failbit;
        } else
            __v = __negative ? - __result : __result;
        if (__testeof)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, bool &__v) const {
        if (!(__io.flags() & ios_base::boolalpha)) {
            long __l = -1;
            __beg = _M_extract_int(__beg, __end, __io, __err, __l);
            if (__l == 0 || __l == 1)
                __v = bool(__l);
            else {
                __v = true;
                __err = ios_base::failbit;
                if (__beg == __end)
                    __err |= ios_base::eofbit;
            }
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            bool __testf = true;
            bool __testt = true;
            bool __donef = __lc->_M_falsename_size == 0;
            bool __donet = __lc->_M_truename_size == 0;
            bool __testeof = false;
            size_t __n = 0;
            while (!__donef || !__donet)
                {
                    if (__beg == __end) {
                        __testeof = true;
                        break;
                    }
                    const char_type __c = *__beg;
                    if (!__donef)
                        __testf = __c == __lc->_M_falsename[__n];
                    if (!__testf && __donet)
                        break;
                    if (!__donet)
                        __testt = __c == __lc->_M_truename[__n];
                    if (!__testt && __donef)
                        break;
                    if (!__testt && !__testf)
                        break;
                    ++__n;
                    ++__beg;
                    __donef = !__testf || __n >= __lc->_M_falsename_size;
                    __donet = !__testt || __n >= __lc->_M_truename_size;
                }
            if (__testf && __n == __lc->_M_falsename_size && __n) {
                __v = false;
                if (__testt && __n == __lc->_M_truename_size)
                    __err = ios_base::failbit;
                else
                    __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else if (__testt && __n == __lc->_M_truename_size && __n) {
                __v = true;
                __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else {
                __v = false;
                __err = ios_base::failbit;
                if (__testeof)
                    __err |= ios_base::eofbit;
            }
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, float &__v) const {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, double &__v) const {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, long double &__v) const {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, void *&__v) const {
        typedef ios_base::fmtflags fmtflags;
        const fmtflags __fmt = __io.flags();
        __io.flags((__fmt & ~ ios_base::basefield) | ios_base::hex);
        typedef __gnu_cxx::__conditional_type<(sizeof(void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        _UIntPtrType __ul;
        __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
        __io.flags(__fmt);
        __v = reinterpret_cast<void *>(__ul);
        return __beg;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, streamsize __w, ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const {
        __pad<_CharT, char_traits<_CharT>>::_S_pad(__io, __fill, __new, __cs, __w, __len);
        __len = static_cast<int>(__w);
    }
    template <typename _CharT, typename _ValueT> int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags __flags, bool __dec) {
        _CharT *__buf = __bufend;
        if (__builtin_expect(__dec, true)) {
            do {
                *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
                __v /= 10;
            } while (__v != 0);
        } else if ((__flags & ios_base::basefield) == ios_base::oct) {
            do {
                *--__buf = __lit[(__v & 7) + __num_base::_S_odigits];
                __v >>= 3;
            } while (__v != 0);
        } else {
            const bool __uppercase = __flags & ios_base::uppercase;
            const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits;
            do {
                *--__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
            } while (__v != 0);
        }
        return __bufend - __buf;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, size_t __grouping_size, _CharT __sep, ios_base &, _CharT *__new, _CharT *__cs, int &__len) const {
        _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
        __len = __p - __new;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, ios_base &__io, _CharT __fill, _ValueT __v) const {
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_out;
        const ios_base::fmtflags __flags = __io.flags();
        const int __ilen = 5 * sizeof(_ValueT);
        _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
        const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
        const bool __dec = (__basefield != ios_base::oct && __basefield != ios_base::hex);
        const __unsigned_type __u = ((__v > 0 || !__dec) ? __unsigned_type(__v) : - __unsigned_type(__v));
        int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
        __cs += __ilen - __len;
        if (__lc->_M_use_grouping) {
            _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
            this->_M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
            __cs = __cs2 + 2;
        }
        if (__builtin_expect(__dec, true)) {
            if (__v >= 0) {
                if (bool(__flags & ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
                    *--__cs = __lit[__num_base::_S_oplus] , ++__len;
            } else
                *--__cs = __lit[__num_base::_S_ominus] , ++__len;
        } else if (bool(__flags & ios_base::showbase) && __v) {
            if (__basefield == ios_base::oct)
                *--__cs = __lit[__num_base::_S_odigits] , ++__len;
            else {
                const bool __uppercase = __flags & ios_base::uppercase;
                *--__cs = __lit[__num_base::_S_ox + __uppercase];
                *--__cs = __lit[__num_base::_S_odigits];
                __len += 2;
            }
        }
        const streamsize __w = __io.width();
        if (__w > static_cast<streamsize>(__len)) {
            _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
        }
        __io.width(0);
        return std::__write(__s, __cs, __len);
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const {
        const int __declen = __p ? __p - __cs : __len;
        _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
        int __newlen = __p2 - __new;
        if (__p) {
            char_traits<_CharT>::copy(__p2, __p, __len - __declen);
            __newlen += __len - __declen;
        }
        __len = __newlen;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const {
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
        const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
        int __len;
        char __fbuf[16];
        __num_base::_S_format_float(__io, __fbuf, __mod);
        const bool __use_prec = (__io.flags() & ios_base::floatfield) != ios_base::floatfield;
        int __cs_size = __max_digits * 3;
        char *__cs = static_cast<char *>(__builtin_alloca(__cs_size));
        if (__use_prec)
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
        else
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        if (__len >= __cs_size) {
            __cs_size = __len + 1;
            __cs = static_cast<char *>(__builtin_alloca(__cs_size));
            if (__use_prec)
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
            else
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        }
        const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
        _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
        __ctype.widen(__cs, __cs + __len, __ws);
        _CharT *__wp = 0;
        const char *__p = char_traits<char>::find(__cs, __len, '.');
        if (__p) {
            __wp = __ws + (__p - __cs);
            *__wp = __lc->_M_decimal_point;
        }
        if (__lc->_M_use_grouping && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9' && __cs[1] >= '0' && __cs[2] >= '0'))) {
            _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
            streamsize __off = 0;
            if (__cs[0] == '-' || __cs[0] == '+') {
                __off = 1;
                __ws2[0] = __ws[0];
                __len -= 1;
            }
            this->_M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
            __len += __off;
            __ws = __ws2;
        }
        const streamsize __w = __io.width();
        if (__w > static_cast<streamsize>(__len)) {
            _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __ws3, __ws, __len);
            __ws = __ws3;
        }
        __io.width(0);
        return std::__write(__s, __ws, __len);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const {
        const ios_base::fmtflags __flags = __io.flags();
        if ((__flags & ios_base::boolalpha) == 0) {
            const long __l = __v;
            __s = _M_insert_int(__s, __io, __fill, __l);
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
            int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
            const streamsize __w = __io.width();
            if (__w > static_cast<streamsize>(__len)) {
                const streamsize __plen = __w - __len;
                _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
                char_traits<_CharT>::assign(__ps, __plen, __fill);
                __io.width(0);
                if ((__flags & ios_base::adjustfield) == ios_base::left) {
                    __s = std::__write(__s, __name, __len);
                    __s = std::__write(__s, __ps, __plen);
                } else {
                    __s = std::__write(__s, __ps, __plen);
                    __s = std::__write(__s, __name, __len);
                }
                return __s;
            }
            __io.width(0);
            __s = std::__write(__s, __name, __len);
        }
        return __s;
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(iter_type __s, ios_base &__io, char_type __fill, double __v) const {
        return _M_insert_float(__s, __io, __fill, char(), __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(iter_type __s, ios_base &__io, char_type __fill, long double __v) const {
        return _M_insert_float(__s, __io, __fill, 'L', __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(iter_type __s, ios_base &__io, char_type __fill, const void *__v) const {
        const ios_base::fmtflags __flags = __io.flags();
        const ios_base::fmtflags __fmt = ~ (ios_base::basefield | ios_base::uppercase);
        __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
        typedef __gnu_cxx::__conditional_type<(sizeof(const void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
        __io.flags(__flags);
        return __s;
    }
    template <typename _CharT, typename _Traits> void __pad<_CharT, _Traits>::_S_pad(ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, streamsize __newlen, streamsize __oldlen) {
        const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
        const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
        if (__adjust == ios_base::left) {
            _Traits::copy(__news, __olds, __oldlen);
            _Traits::assign(__news + __oldlen, __plen, __fill);
            return;
        }
        size_t __mod = 0;
        if (__adjust == ios_base::internal) {
            const locale &__loc = __io._M_getloc();
            const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
            if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0]) {
                __news[0] = __olds[0];
                __mod = 1;
                ++__news;
            } else if (__ctype.widen('0') == __olds[0] && __oldlen > 1 && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1])) {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
            }
        }
        _Traits::assign(__news, __plen, __fill);
        _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, size_t __gsize, const _CharT *__first, const _CharT *__last) {
        size_t __idx = 0;
        size_t __ctr = 0;
        while (__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0 && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
            {
                __last -= __gbeg[__idx];
                __idx < __gsize - 1 ? ++__idx : ++__ctr;
            }
        while (__first != __last)
            *__s++ = *__first++;
        while (__ctr--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        while (__idx--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        return __s;
    }
    template<> class numpunct<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        typedef __numpunct_cache<char> __cache_type;
    protected:
        __cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(size_t __refs);
        explicit numpunct(__cache_type *__cache, size_t __refs);
        explicit numpunct(__c_locale __cloc, size_t __refs);
        char_type decimal_point() const;
        char_type thousands_sep() const;
        string grouping() const;
        string_type truename() const;
        string_type falsename() const;
    protected:
        virtual ~numpunct<char>() noexcept;
        virtual char_type do_decimal_point() const;
        virtual char_type do_thousands_sep() const;
        virtual string do_grouping() const;
        virtual string_type do_truename() const;
        virtual string_type do_falsename() const;
        void _M_initialize_numpunct(__c_locale __cloc);
    };
    template<> class numpunct_byname<char> : public numpunct<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit numpunct_byname(const char *__s, size_t __refs);
        explicit numpunct_byname(const string &__s, size_t __refs);
    protected:
        virtual ~numpunct_byname<char>() noexcept;
    };
    template<> class num_get<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::istreambuf_iterator<char> iter_type;
        static locale::id id;
        explicit num_get(size_t __refs);
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, float &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, double &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<char>() noexcept;
        iter_type _M_extract_float(iter_type, iter_type, ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::ostreambuf_iterator<char> iter_type;
        static locale::id id;
        explicit num_put(size_t __refs);
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, double __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long double __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~num_put<char>() noexcept;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long __v) const;
        virtual iter_type do_put(iter_type, ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, ios_base &, char_type, const void *) const;
    };
    template<> class ctype_byname<char>;
    template<> class numpunct<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        typedef __numpunct_cache<wchar_t> __cache_type;
    protected:
        __cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(size_t __refs);
        explicit numpunct(__cache_type *__cache, size_t __refs);
        explicit numpunct(__c_locale __cloc, size_t __refs);
        char_type decimal_point() const;
        char_type thousands_sep() const;
        string grouping() const;
        string_type truename() const;
        string_type falsename() const;
    protected:
        virtual ~numpunct<wchar_t>() noexcept;
        virtual char_type do_decimal_point() const;
        virtual char_type do_thousands_sep() const;
        virtual string do_grouping() const;
        virtual string_type do_truename() const;
        virtual string_type do_falsename() const;
        void _M_initialize_numpunct(__c_locale __cloc);
    };
    template<> class numpunct_byname<wchar_t> : public numpunct<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit numpunct_byname(const char *__s, size_t __refs);
        explicit numpunct_byname(const string &__s, size_t __refs);
    protected:
        virtual ~numpunct_byname<wchar_t>() noexcept;
    };
    template<> class num_get<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::istreambuf_iterator<wchar_t> iter_type;
        static locale::id id;
        explicit num_get(size_t __refs);
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, float &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, double &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<wchar_t>() noexcept;
        iter_type _M_extract_float(iter_type, iter_type, ios_base &, ios_base::iostate &, string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> iter_type _M_extract_int(iter_type, iter_type, ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, bool &) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, float &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, double &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, long double &) const;
        virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::ostreambuf_iterator<wchar_t> iter_type;
        static locale::id id;
        explicit num_put(size_t __refs);
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, double __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, long double __v) const;
        iter_type put(iter_type __s, ios_base &__io, char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> iter_type _M_insert_float(iter_type, ios_base &__io, char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, size_t __grouping_size, char_type __sep, const char_type *__p, char_type *__new, char_type *__cs, int &__len) const;
        template <typename _ValueT> iter_type _M_insert_int(iter_type, ios_base &__io, char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, size_t __grouping_size, char_type __sep, ios_base &__io, char_type *__new, char_type *__cs, int &__len) const;
        void _M_pad(char_type __fill, streamsize __w, ios_base &__io, char_type *__new, const char_type *__cs, int &__len) const;
        virtual ~num_put<wchar_t>() noexcept;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const;
        virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long __v) const;
        virtual iter_type do_put(iter_type, ios_base &, char_type, double) const;
        virtual iter_type do_put(iter_type, ios_base &, char_type, long double) const;
        virtual iter_type do_put(iter_type, ios_base &, char_type, const void *) const;
    };
    template<> class ctype_byname<wchar_t>;
}
namespace std {
    template <typename _Facet> inline const _Facet &__check_facet(const _Facet *__f) {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template<> inline const std::ctype<char> &__check_facet<std::ctype<char>>(const std::ctype<char> *__f) {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios : public ios_base {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef ctype<_CharT> __ctype_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> __num_put_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> __num_get_type;
    protected:
        basic_ostream<_CharT, _Traits> *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<_CharT, _Traits> *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        explicit operator bool() const {
            return !this->fail();
        }
        bool operator!() const {
            return this->fail();
        }
        iostate rdstate() const {
            return this->_M_streambuf_state;
        }
        void clear(iostate __state = goodbit);
        void setstate(iostate __state) {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(iostate __state) {
            this->_M_streambuf_state |= __state;
            if (this->exceptions() & __state)
                throw;
        }
        bool good() const {
            return this->rdstate() == 0;
        }
        bool eof() const {
            return (this->rdstate() & eofbit) != 0;
        }
        bool fail() const {
            return (this->rdstate() & (badbit | failbit)) != 0;
        }
        bool bad() const {
            return (this->rdstate() & badbit) != 0;
        }
        iostate exceptions() const {
            return this->_M_exception;
        }
        void exceptions(iostate __except) {
            this->_M_exception = __except;
            this->clear(this->_M_streambuf_state);
        }
        explicit basic_ios<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) {
            this->init(__sb);
        }
        virtual ~basic_ios<_CharT, _Traits>() {
        }
        basic_ostream<_CharT, _Traits> *tie() const {
            return this->_M_tie;
        }
        basic_ostream<_CharT, _Traits> *tie(basic_ostream<_CharT, _Traits> *__tiestr) {
            basic_ostream<_CharT, _Traits> *__old = this->_M_tie;
            this->_M_tie = __tiestr;
            return __old;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf() const {
            return this->_M_streambuf;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs);
        char_type fill() const {
            if (!this->_M_fill_init) {
                this->_M_fill = this->widen(' ');
                this->_M_fill_init = true;
            }
            return this->_M_fill;
        }
        char_type fill(char_type __ch) {
            char_type __old = this->fill();
            this->_M_fill = __ch;
            return __old;
        }
        locale imbue(const locale &__loc);
        char narrow(char_type __c, char __dfault) const {
            return __check_facet(this->_M_ctype).narrow(__c, __dfault);
        }
        char_type widen(char __c) const {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios<_CharT, _Traits>() : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) {
        }
        void init(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits>(const basic_ios<_CharT, _Traits> &) = delete
        basic_ios<_CharT, _Traits> &operator=(const basic_ios<_CharT, _Traits> &) = delete
        void move(basic_ios<_CharT, _Traits> &__rhs) {
            this->ios_base::_M_move(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            this->tie(__rhs.tie(nullptr));
            this->_M_fill = __rhs._M_fill;
            this->_M_fill_init = __rhs._M_fill_init;
            this->_M_streambuf = nullptr;
        }
        void move(basic_ios<_CharT, _Traits> &&__rhs) {
            this->move(__rhs);
        }
        void swap(basic_ios<_CharT, _Traits> &__rhs) noexcept {
            this->ios_base::_M_swap(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            __rhs._M_cache_locale(__rhs._M_ios_locale);
            std::swap(this->_M_tie, __rhs._M_tie);
            std::swap(this->_M_fill, __rhs._M_fill);
            std::swap(this->_M_fill_init, __rhs._M_fill_init);
        }
        void set_rdbuf(basic_streambuf<_CharT, _Traits> *__sb) {
            this->_M_streambuf = __sb;
        }
        void _M_cache_locale(const locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::clear(iostate __state = goodbit) {
        if (this->rdbuf())
            this->_M_streambuf_state = __state;
        else
            this->_M_streambuf_state = __state | badbit;
        if (this->exceptions() & this->rdstate())
            __throw_ios_failure(("basic_ios::clear"));
    }
    template <typename _CharT, typename _Traits> basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits> *__sb) {
        basic_streambuf<_CharT, _Traits> *__old = this->_M_streambuf;
        this->_M_streambuf = __sb;
        this->clear();
        return __old;
    }
    template <typename _CharT, typename _Traits> basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits> &__rhs) {
        if (this != std::__addressof(__rhs)) {
            _Words *__words = (__rhs._M_word_size <= _S_local_word_size) ? this->_M_local_word : new _Words [__rhs._M_word_size];
            _Callback_list *__cb = __rhs._M_callbacks;
            if (__cb)
                __cb->_M_add_reference();
            this->_M_call_callbacks(erase_event);
            if (this->_M_word != this->_M_local_word) {
                delete [] this->_M_word;
                this->_M_word = 0;
            }
            this->_M_dispose_callbacks();
            this->_M_callbacks = __cb;
            for (int __i = 0; __i < __rhs._M_word_size; ++__i)
                __words[__i] = __rhs._M_word[__i];
            this->_M_word = __words;
            this->_M_word_size = __rhs._M_word_size;
            this->flags(__rhs.flags());
            this->width(__rhs.width());
            this->precision(__rhs.precision());
            this->tie(__rhs.tie());
            this->fill(__rhs.fill());
            this->_M_ios_locale = __rhs.getloc();
            this->_M_cache_locale(this->_M_ios_locale);
            this->_M_call_callbacks(copyfmt_event);
            this->exceptions(__rhs.exceptions());
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> locale basic_ios<_CharT, _Traits>::imbue(const locale &__loc) {
        locale __old(this->getloc());
        this->ios_base::imbue(__loc);
        this->_M_cache_locale(__loc);
        if (this->rdbuf() != 0)
            this->rdbuf()->pubimbue(__loc);
        return __old;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits> *__sb) {
        this->ios_base::_M_init();
        this->_M_cache_locale(this->_M_ios_locale);
        this->_M_fill = _CharT();
        this->_M_fill_init = false;
        this->_M_tie = 0;
        this->_M_exception = goodbit;
        this->_M_streambuf = __sb;
        this->_M_streambuf_state = __sb ? goodbit : badbit;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::_M_cache_locale(const locale &__loc) {
        this->_M_ctype = std::__try_use_facet<__ctype_type>(__loc);
        this->_M_num_put = std::__try_use_facet<__num_put_type>(__loc);
        this->_M_num_get = std::__try_use_facet<__num_get_type>(__loc);
    }
    template<> class basic_ios<char> : public ios_base {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef ctype<char> __ctype_type;
        typedef num_put<char, ostreambuf_iterator<char, char_traits<char>>> __num_put_type;
        typedef num_get<char, istreambuf_iterator<char, char_traits<char>>> __num_get_type;
    protected:
        basic_ostream<char, char_traits<char>> *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<char, char_traits<char>> *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        iostate rdstate() const {
            return this->_M_streambuf_state;
        }
        void clear(iostate __state);
        void setstate(iostate __state) {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        iostate exceptions() const;
        void exceptions(iostate __except);
        explicit basic_ios(basic_streambuf<char, char_traits<char>> *__sb);
        virtual ~basic_ios<char>() throw();
        basic_ostream<char, char_traits<char>> *tie() const;
        basic_ostream<char, char_traits<char>> *tie(basic_ostream<char, char_traits<char>> *__tiestr);
        basic_streambuf<char, char_traits<char>> *rdbuf() const;
        basic_streambuf<char, char_traits<char>> *rdbuf(basic_streambuf<char, char_traits<char>> *__sb);
        basic_ios<char> &copyfmt(const basic_ios<char> &__rhs);
        char_type fill() const;
        char_type fill(char_type __ch);
        locale imbue(const locale &__loc);
        char narrow(char_type __c, char __dfault) const;
        char_type widen(char __c) const {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios();
        void init(basic_streambuf<char, char_traits<char>> *__sb);
        basic_ios(const basic_ios<char> &) = delete
        basic_ios<char> &operator=(const basic_ios<char> &) = delete
        void move(basic_ios<char> &__rhs);
        void move(basic_ios<char> &&__rhs);
        void swap(basic_ios<char> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<char, char_traits<char>> *__sb);
        void _M_cache_locale(const locale &__loc);
    };
    template<> class basic_ios<wchar_t> : public ios_base {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef ctype<wchar_t> __ctype_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> __num_put_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> __num_get_type;
    protected:
        basic_ostream<wchar_t, char_traits<wchar_t>> *_M_tie;
        mutable char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<wchar_t, char_traits<wchar_t>> *_M_streambuf;
        const __ctype_type *_M_ctype;
        const __num_put_type *_M_num_put;
        const __num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        iostate rdstate() const;
        void clear(iostate __state);
        void setstate(iostate __state);
        void _M_setstate(iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        iostate exceptions() const;
        void exceptions(iostate __except);
        explicit basic_ios(basic_streambuf<wchar_t, char_traits<wchar_t>> *__sb);
        virtual ~basic_ios<wchar_t>() throw();
        basic_ostream<wchar_t, char_traits<wchar_t>> *tie() const;
        basic_ostream<wchar_t, char_traits<wchar_t>> *tie(basic_ostream<wchar_t, char_traits<wchar_t>> *__tiestr);
        basic_streambuf<wchar_t, char_traits<wchar_t>> *rdbuf() const;
        basic_streambuf<wchar_t, char_traits<wchar_t>> *rdbuf(basic_streambuf<wchar_t, char_traits<wchar_t>> *__sb);
        basic_ios<wchar_t> &copyfmt(const basic_ios<wchar_t> &__rhs);
        char_type fill() const;
        char_type fill(char_type __ch);
        locale imbue(const locale &__loc);
        char narrow(char_type __c, char __dfault) const;
        char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<wchar_t, char_traits<wchar_t>> *__sb);
        basic_ios(const basic_ios<wchar_t> &) = delete
        basic_ios<wchar_t> &operator=(const basic_ios<wchar_t> &) = delete
        void move(basic_ios<wchar_t> &__rhs);
        void move(basic_ios<wchar_t> &&__rhs);
        void swap(basic_ios<wchar_t> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<wchar_t, char_traits<wchar_t>> *__sb);
        void _M_cache_locale(const locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> __num_put_type;
        typedef ctype<_CharT> __ctype_type;
        explicit basic_ostream<_CharT, _Traits>(__streambuf_type *__sb) {
            this->init(__sb);
        }
        virtual ~basic_ostream<_CharT, _Traits>() {
        }
        class sentry;
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &)) {
            return __pf(*this);
        }
        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &)) {
            __pf(*this);
            return *this;
        }
        __ostream_type &operator<<(ios_base &(*__pf)(ios_base &)) {
            __pf(*this);
            return *this;
        }
        __ostream_type &operator<<(long __n) {
            return _M_insert(__n);
        }
        __ostream_type &operator<<(unsigned long __n) {
            return _M_insert(__n);
        }
        __ostream_type &operator<<(bool __n) {
            return _M_insert(__n);
        }
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n) {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n) {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        __ostream_type &operator<<(long long __n) {
            return _M_insert(__n);
        }
        __ostream_type &operator<<(unsigned long long __n) {
            return _M_insert(__n);
        }
        __ostream_type &operator<<(double __f) {
            return _M_insert(__f);
        }
        __ostream_type &operator<<(float __f) {
            return _M_insert(static_cast<double>(__f));
        }
        __ostream_type &operator<<(long double __f) {
            return _M_insert(__f);
        }
        __ostream_type &operator<<(const void *__p) {
            return _M_insert(__p);
        }
        __ostream_type &operator<<(nullptr_t) {
            return *this << "nullptr";
        }
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream<_CharT, _Traits>() {
            this->init(0);
        }
        basic_ostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &) {
        }
        basic_ostream<_CharT, _Traits>(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits>(basic_ostream<_CharT, _Traits> &&__rhs) : __ios_type() {
            __ios_type::move(__rhs);
        }
        basic_ostream<_CharT, _Traits> &operator=(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits> &operator=(basic_ostream<_CharT, _Traits> &&__rhs) {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_ostream<_CharT, _Traits> &__rhs) {
            __ios_type::swap(__rhs);
        }
        template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const char_type *__s, streamsize __n) {
            std::__ostream_insert(*this, __s, __n);
        }
    };
    class sentry {
        bool _M_ok;
        basic_ostream<_CharT, _Traits> &_M_os;
    public:
        explicit sentry(basic_ostream<_CharT, _Traits> &__os);
        ~sentry() {
            if (bool(this->_M_os.flags() & ios_base::unitbuf) && !uncaught_exception()) {
                if (this->_M_os.rdbuf() && this->_M_os.rdbuf()->pubsync() == -1)
                    this->_M_os.setstate(ios_base::badbit);
            }
        }
        explicit operator bool() const {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, _CharT __c) {
        if (__out.width() != 0)
            return __ostream_insert(__out, & __c, 1);
        __out.put(__c);
        return __out;
    }
    template<> inline basic_ostream<char, char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, char_traits<char>> &__out, char __c)    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, char __c) {
        return (__out << __out.widen(__c));
    }
    template<> inline basic_ostream<char, char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, char_traits<char>> &__out, char __c)    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, char __c) {
        if (__out.width() != 0)
            return __ostream_insert(__out, &__c, 1);
        __out.put(__c);
        return __out;
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, signed char __c) {
        return (__out << static_cast<char>(__c));
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, unsigned char __c) {
        return (__out << static_cast<char>(__c));
    }
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, wchar_t) = delete    template<> basic_ostream<char, char_traits<char>> &operator<<<std::char_traits<char>>(basic_ostream<char, char_traits<char>> &, wchar_t) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, char8_t) = delete    template<> basic_ostream<char, char_traits<char>> &operator<<<std::char_traits<char>>(basic_ostream<char, char_traits<char>> &, char8_t) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, char16_t) = delete    template<> basic_ostream<char, char_traits<char>> &operator<<<std::char_traits<char>>(basic_ostream<char, char_traits<char>> &, char16_t) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, char32_t) = delete    template<> basic_ostream<char, char_traits<char>> &operator<<<std::char_traits<char>>(basic_ostream<char, char_traits<char>> &, char32_t) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, char8_t) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, char16_t) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, char32_t) = delete
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s) {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<streamsize>(_Traits::length(__s)));
        return __out;
    }
    template<> inline basic_ostream<char, char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, char_traits<char>> &__out, const char *__s)    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s);
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const char *__s) {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<streamsize>(_Traits::length(__s)));
        return __out;
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const signed char *__s) {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const unsigned char *__s) {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, const wchar_t *) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, const char8_t *) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, const char16_t *) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, const char32_t *) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, const char8_t *) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, const char16_t *) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, const char32_t *) = delete
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &__os) {
        return flush(__os.put(__os.widen('\n')));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &__os) {
        return __os.put(_CharT());
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &__os) {
        return __os.flush();
    }
    template <typename _Tp> concept __derived_from_ios_base = is_class_v<_Tp> && (!is_same_v<_Tp, ios_base>) && requires (_Tp *__t, ios_base *__b) { __b = __t; };
    template <typename _Os, typename _Tp> using __rvalue_stream_insertion_t = _Os &&;
    template <typename _Ostream, typename _Tp> inline __rvalue_stream_insertion_t<_Ostream, _Tp> operator<<(_Ostream &&__os, const _Tp &__x) {
        __os << __x;
        return std::move(__os);
    }
    template <typename _CharT, typename _Traits> class __syncbuf_base : public basic_streambuf<_CharT, _Traits> {
    public:
        static bool *_S_get(basic_streambuf<_CharT, _Traits> *__buf [[maybe_unused]]) noexcept {
            if (auto __p = dynamic_cast<__syncbuf_base<_CharT, _Traits> *>(__buf))
                return & __p->_M_emit_on_sync;
            return nullptr;
        }
    protected:
        __syncbuf_base<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__w = nullptr) : _M_wrapped(__w) {
        }
        basic_streambuf<_CharT, _Traits> *_M_wrapped = nullptr;
        bool _M_emit_on_sync = false;
        bool _M_needs_sync = false;
    };
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &emit_on_flush(basic_ostream<_CharT, _Traits> &__os) {
        if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
            *__flag = true;
        return __os;
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &noemit_on_flush(basic_ostream<_CharT, _Traits> &__os) {
        if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
            *__flag = false;
        return __os;
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &flush_emit(basic_ostream<_CharT, _Traits> &__os) {
        struct _Restore {
            ~_Restore() {
                *this->_M_flag = this->_M_prev;
            }
            bool _M_prev = false;
            bool *_M_flag = &this->_M_prev;
        } __restore;
        if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf())) {
            __restore._M_prev = *__flag;
            __restore._M_flag = __flag;
            *__flag = true;
        }
        __os.flush();
        return __os;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits> &__os) : _M_ok(false), _M_os(__os) {
        if (__os.tie() && __os.good())
            __os.tie()->flush();
        if (__os.good())
            this->_M_ok = true;
        else if (__os.bad())
            __os.setstate(ios_base::failbit);
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v) {
        sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __num_put_type &__np = __check_facet(this->_M_num_put);
                if (__np.put(*this, *this, this->fill(), __v).failed())
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(short __n) {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(int __n) {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(__streambuf_type *__sbin) {
        ios_base::iostate __err = ios_base::goodbit;
        sentry __cerb(*this);
        if (__cerb && __sbin) {
            try {
                if (!__copy_streambufs(__sbin, this->rdbuf()))
                    __err |= ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbin)
            __err |= ios_base::badbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::put(char_type __c) {
        sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __put = this->rdbuf()->sputc(__c);
                if (traits_type::eq_int_type(__put, traits_type::eof()))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, streamsize __n) {
        sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (this->rdbuf()->sputn(__s, __n) != __n)
                    __err = ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(ios_base::badbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::flush() {
        if (__streambuf_type *__buf = this->rdbuf()) {
            sentry __cerb(*this);
            if (__cerb) {
                ios_base::iostate __err = ios_base::goodbit;
                try {
                    if (this->rdbuf()->pubsync() == -1)
                        __err |= ios_base::badbit;
                } catch (__cxxabiv1::__forced_unwind &) {
                    this->_M_setstate(ios_base::badbit);
                    throw;
                } catch (...) {
                    this->_M_setstate(ios_base::badbit);
                }
                if (__err)
                    this->setstate(__err);
            }
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp() {
        sentry __cerb(*this);
        pos_type __ret = pos_type(-1);
        if (!this->fail())
            __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(pos_type __pos) {
        sentry __cerb(*this);
        if (!this->fail()) {
            const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
            if (__p == pos_type(off_type(-1)))
                this->setstate(ios_base::failbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir) {
        sentry __cerb(*this);
        if (!this->fail()) {
            const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
            if (__p == pos_type(off_type(-1)))
                this->setstate(ios_base::failbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s) {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else {
            const size_t __clen = char_traits<char>::length(__s);
            try {
                struct __ptr_guard {
                    _CharT *__p;
                    __ptr_guard(_CharT *__ip) : __p(__ip) {
                    }
                    ~__ptr_guard() {
                        delete [] this->__p;
                    }
                    _CharT *__get() {
                        return this->__p;
                    }
                } __pg(new _CharT [__clen]);
                _CharT *__ws = __pg.__get();
                for (size_t __i = 0; __i < __clen; ++__i)
                    __ws[__i] = __out.widen(__s[__i]);
                __ostream_insert(__out, __ws, __clen);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(ios_base::badbit);
            }
        }
        return __out;
    }
    template<> basic_ostream<char, char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, char_traits<char>> &__out, const char *__s)    template<> class basic_ostream<char> : virtual public basic_ios<char, char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, char_traits<char>> __streambuf_type;
        typedef basic_ios<char, char_traits<char>> __ios_type;
        typedef basic_ostream<char, char_traits<char>> __ostream_type;
        typedef num_put<char, ostreambuf_iterator<char, char_traits<char>>> __num_put_type;
        typedef ctype<char> __ctype_type;
        explicit basic_ostream(__streambuf_type *__sb);
        virtual ~basic_ostream<char>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<char, char_traits<char>> &_M_os;
        public:
            explicit sentry(basic_ostream<char, char_traits<char>> &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &)) {
            return __pf(*this);
        }
        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &));
        __ostream_type &operator<<(ios_base &(*__pf)(ios_base &));
        __ostream_type &operator<<(long __n);
        __ostream_type &operator<<(unsigned long __n);
        __ostream_type &operator<<(bool __n);
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n);
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n);
        __ostream_type &operator<<(long long __n);
        __ostream_type &operator<<(unsigned long long __n);
        __ostream_type &operator<<(double __f);
        __ostream_type &operator<<(float __f) {
            return this->_M_insert(static_cast<double>(__f));
        }
        __ostream_type &operator<<(long double __f);
        __ostream_type &operator<<(const void *__p);
        __ostream_type &operator<<(nullptr_t);
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<char, char_traits<char>> &);
        basic_ostream(const basic_ostream<char> &) = delete
        basic_ostream(basic_ostream<char> &&__rhs);
        basic_ostream<char> &operator=(const basic_ostream<char> &) = delete
        basic_ostream<char> &operator=(basic_ostream<char> &&__rhs);
        void swap(basic_ostream<char> &__rhs);
        template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const char_type *__s, streamsize __n);
    };
    template<> class basic_ostream<wchar_t> : virtual public basic_ios<wchar_t, char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, char_traits<wchar_t>> __streambuf_type;
        typedef basic_ios<wchar_t, char_traits<wchar_t>> __ios_type;
        typedef basic_ostream<wchar_t, char_traits<wchar_t>> __ostream_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>> __num_put_type;
        typedef ctype<wchar_t> __ctype_type;
        explicit basic_ostream(__streambuf_type *__sb);
        virtual ~basic_ostream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<wchar_t, char_traits<wchar_t>> &_M_os;
        public:
            explicit sentry(basic_ostream<wchar_t, char_traits<wchar_t>> &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &));
        __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &));
        __ostream_type &operator<<(ios_base &(*__pf)(ios_base &));
        __ostream_type &operator<<(long __n);
        __ostream_type &operator<<(unsigned long __n);
        __ostream_type &operator<<(bool __n);
        __ostream_type &operator<<(short __n);
        __ostream_type &operator<<(unsigned short __n);
        __ostream_type &operator<<(int __n);
        __ostream_type &operator<<(unsigned int __n);
        __ostream_type &operator<<(long long __n);
        __ostream_type &operator<<(unsigned long long __n);
        __ostream_type &operator<<(double __f);
        __ostream_type &operator<<(float __f);
        __ostream_type &operator<<(long double __f);
        __ostream_type &operator<<(const void *__p);
        __ostream_type &operator<<(nullptr_t);
        __ostream_type &operator<<(__streambuf_type *__sb);
        __ostream_type &put(char_type __c);
        __ostream_type &write(const char_type *__s, streamsize __n);
        __ostream_type &flush();
        pos_type tellp();
        __ostream_type &seekp(pos_type);
        __ostream_type &seekp(off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<wchar_t, char_traits<wchar_t>> &);
        basic_ostream(const basic_ostream<wchar_t> &) = delete
        basic_ostream(basic_ostream<wchar_t> &&__rhs);
        basic_ostream<wchar_t> &operator=(const basic_ostream<wchar_t> &) = delete
        basic_ostream<wchar_t> &operator=(basic_ostream<wchar_t> &&__rhs);
        void swap(basic_ostream<wchar_t> &__rhs);
        template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const char_type *__s, streamsize __n);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> __num_get_type;
        typedef ctype<_CharT> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream<_CharT, _Traits>(__streambuf_type *__sb) : _M_gcount(streamsize(0)) {
            this->init(__sb);
        }
        virtual ~basic_istream<_CharT, _Traits>() {
            this->_M_gcount = streamsize(0);
        }
        class sentry;
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &)) {
            return __pf(*this);
        }
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &)) {
            __pf(*this);
            return *this;
        }
        __istream_type &operator>>(ios_base &(*__pf)(ios_base &)) {
            __pf(*this);
            return *this;
        }
        __istream_type &operator>>(bool &__n) {
            return _M_extract(__n);
        }
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n) {
            return _M_extract(__n);
        }
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n) {
            return _M_extract(__n);
        }
        __istream_type &operator>>(long &__n) {
            return _M_extract(__n);
        }
        __istream_type &operator>>(unsigned long &__n) {
            return _M_extract(__n);
        }
        __istream_type &operator>>(long long &__n) {
            return _M_extract(__n);
        }
        __istream_type &operator>>(unsigned long long &__n) {
            return _M_extract(__n);
        }
        __istream_type &operator>>(float &__f) {
            return _M_extract(__f);
        }
        __istream_type &operator>>(double &__f) {
            return _M_extract(__f);
        }
        __istream_type &operator>>(long double &__f) {
            return _M_extract(__f);
        }
        __istream_type &operator>>(void *&__p) {
            return _M_extract(__p);
        }
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const {
            return this->_M_gcount;
        }
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n) {
            return this->get(__s, __n, this->widen('\n'));
        }
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb) {
            return this->get(__sb, this->widen('\n'));
        }
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n) {
            return this->getline(__s, __n, this->widen('\n'));
        }
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream<_CharT, _Traits>() : _M_gcount(streamsize(0)) {
            this->init(0);
        }
        basic_istream<_CharT, _Traits>(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits>(basic_istream<_CharT, _Traits> &&__rhs) : __ios_type(), _M_gcount(__rhs._M_gcount) {
            __ios_type::move(__rhs);
            __rhs._M_gcount = 0;
        }
        basic_istream<_CharT, _Traits> &operator=(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits> &operator=(basic_istream<_CharT, _Traits> &&__rhs) {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_istream<_CharT, _Traits> &__rhs) {
            __ios_type::swap(__rhs);
            std::swap(this->_M_gcount, __rhs._M_gcount);
        }
        template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    };
    template <> basic_istream<char> &basic_istream<char>::getline(char_type *__s, streamsize __n, char_type __delim);
    template <> basic_istream<char> &basic_istream<char>::ignore(streamsize __n);
    template <> basic_istream<char> &basic_istream<char>::ignore(streamsize __n, int_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::getline(char_type *__s, streamsize __n, char_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(streamsize __n);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(streamsize __n, int_type __delim);
    class sentry {
        bool _M_ok;
    public:
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::__ctype_type __ctype_type;
        typedef typename _Traits::int_type __int_type;
        explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);
        explicit operator bool() const {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c);
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char &__c) {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char &__c) {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <typename _CharT, typename _Traits> void __istream_extract(basic_istream<_CharT, _Traits> &, _CharT *, streamsize);
    void __istream_extract(istream &, char *, streamsize);
    template <typename _CharT, typename _Traits, size_t _Num> inline basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT (&__s)[_Num]) {
        static_assert(_Num <= __gnu_cxx::__numeric_traits<streamsize>::__max);
        std::__istream_extract(__in, __s, _Num);
        return __in;
    }
    template <class _Traits, size_t _Num> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char (&__s)[_Num]) {
        return __in >> reinterpret_cast<char (&)[_Num]>(__s);
    }
    template <class _Traits, size_t _Num> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char (&__s)[_Num]) {
        return __in >> reinterpret_cast<char (&)[_Num]>(__s);
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream : public basic_istream<_CharT, _Traits>, public basic_ostream<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        explicit basic_iostream<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : __istream_type(__sb), __ostream_type(__sb) {
        }
        virtual ~basic_iostream<_CharT, _Traits>() {
        }
    protected:
        basic_iostream<_CharT, _Traits>() : __istream_type(), __ostream_type() {
        }
        basic_iostream<_CharT, _Traits>(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &&__rhs) : __istream_type(std::move(__rhs)), __ostream_type(*this) {
        }
        basic_iostream<_CharT, _Traits> &operator=(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits> &operator=(basic_iostream<_CharT, _Traits> &&__rhs) {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_iostream<_CharT, _Traits> &__rhs) {
            __istream_type::swap(__rhs);
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is);
    template <typename _Is, typename _Tp> using __rvalue_stream_extraction_t = _Is &&;
    template <typename _Istream, typename _Tp> inline __rvalue_stream_extraction_t<_Istream, _Tp> operator>>(_Istream &&__is, _Tp &&__x) {
        __is >> std::forward<_Tp>(__x);
        return std::move(__is);
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits> &__in, bool __noskip = false) : _M_ok(false) {
        ios_base::iostate __err = ios_base::goodbit;
        if (__in.good()) {
            try {
                if (__in.tie())
                    __in.tie()->flush();
                if (!__noskip && bool(__in.flags() & ios_base::skipws)) {
                    const __int_type __eof = traits_type::eof();
                    __streambuf_type *__sb = __in.rdbuf();
                    __int_type __c = __sb->sgetc();
                    const __ctype_type &__ct = __check_facet(__in._M_ctype);
                    while (!traits_type::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, traits_type::to_char_type(__c)))
                        __c = __sb->snextc();
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (__in.good() && __err == ios_base::goodbit)
            this->_M_ok = true;
        else {
            __err |= ios_base::failbit;
            __in.setstate(__err);
        }
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v) {
        sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __v);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(short &__n) {
        sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const __num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<short>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<short>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__max;
                } else
                    __n = short(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(int &__n) {
        sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const __num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<int>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<int>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__max;
                } else
                    __n = int(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(__streambuf_type *__sbout) {
        ios_base::iostate __err = ios_base::goodbit;
        sentry __cerb(*this, false);
        if (__cerb && __sbout) {
            try {
                bool __ineof;
                if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
                    __err |= ios_base::failbit;
                if (__ineof)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::failbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbout)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get() {
        const int_type __eof = traits_type::eof();
        int_type __c = __eof;
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        sentry __cerb(*this, true);
        if (__cerb) {
            try {
                __c = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__c, __eof))
                    this->_M_gcount = 1;
                else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(char_type &__c) {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const int_type __cb = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__cb, traits_type::eof())) {
                    this->_M_gcount = 1;
                    __c = traits_type::to_char_type(__cb);
                } else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(char_type *__s, streamsize __n, char_type __delim) {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        ++this->_M_gcount;
                        __c = __sb->snextc();
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(__streambuf_type &__sb, char_type __delim) {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type *__this_sb = this->rdbuf();
                int_type __c = __this_sb->sgetc();
                char_type __c2 = traits_type::to_char_type(__c);
                unsigned long long __gcount = 0;
                while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                    {
                        ++__gcount;
                        __c = __this_sb->snextc();
                        __c2 = traits_type::to_char_type(__c);
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                if (__gcount <= __gnu_cxx::__numeric_traits<streamsize>::__max)
                    this->_M_gcount = __gcount;
                else
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::getline(char_type *__s, streamsize __n, char_type __delim) {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                        ++this->_M_gcount;
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else {
                    if (traits_type::eq_int_type(__c, __idelim)) {
                        __sb->sbumpc();
                        ++this->_M_gcount;
                    } else
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore() {
        this->_M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
                    __err |= ios_base::eofbit;
                else
                    this->_M_gcount = 1;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(streamsize __n) {
        this->_M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max) {
                    if (__large_ignore)
                        this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                } else if (this->_M_gcount < __n) {
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __delim) {
        this->_M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max) {
                    if (__large_ignore)
                        this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                    else {
                        if (this->_M_gcount != __n)
                            ++this->_M_gcount;
                        __sb->sbumpc();
                    }
                } else if (this->_M_gcount < __n) {
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                    else {
                        ++this->_M_gcount;
                        __sb->sbumpc();
                    }
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek() {
        int_type __c = traits_type::eof();
        this->_M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                __c = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__c, traits_type::eof()))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::read(char_type *__s, streamsize __n) {
        this->_M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                this->_M_gcount = this->rdbuf()->sgetn(__s, __n);
                if (this->_M_gcount != __n)
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> streamsize basic_istream<_CharT, _Traits>::readsome(char_type *__s, streamsize __n) {
        this->_M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const streamsize __num = this->rdbuf()->in_avail();
                if (__num > 0)
                    this->_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
                else if (__num == -1)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return this->_M_gcount;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::putback(char_type __c) {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::unget() {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const int_type __eof = traits_type::eof();
                __streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> int basic_istream<_CharT, _Traits>::sync() {
        int __ret = -1;
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                __streambuf_type *__sb = this->rdbuf();
                if (__sb) {
                    if (__sb->pubsync() == -1)
                        __err |= ios_base::badbit;
                    else
                        __ret = 0;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg() {
        pos_type __ret = pos_type(-1);
        sentry __cerb(*this, true);
        if (__cerb) {
            try {
                if (!this->fail())
                    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);
                    if (__p == pos_type(off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir) {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);
                    if (__p == pos_type(off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::int_type __int_type;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __int_type __cb = __in.rdbuf()->sbumpc();
                if (!_Traits::eq_int_type(__cb, _Traits::eof()))
                    __c = _Traits::to_char_type(__cb);
                else
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template <typename _CharT, typename _Traits> void __istream_extract(basic_istream<_CharT, _Traits> &__in, _CharT *__s, streamsize __num) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename _Traits::int_type int_type;
        typedef _CharT char_type;
        typedef ctype<_CharT> __ctype_type;
        streamsize __extracted = 0;
        ios_base::iostate __err = ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                streamsize __width = __in.width();
                if (0 < __width && __width < __num)
                    __num = __width;
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                int_type __c = __sb->sgetc();
                while (__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof) && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        *__s++ = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __sb->snextc();
                    }
                if (__extracted < __num - 1 && _Traits::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                *__s = char_type();
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= ios_base::failbit;
        if (__err)
            __in.setstate(__err);
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__in) {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename __istream_type::int_type __int_type;
        typedef ctype<_CharT> __ctype_type;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                __int_type __c = __sb->sgetc();
                while (true)
                    {
                        if (_Traits::eq_int_type(__c, __eof)) {
                            __err = ios_base::eofbit;
                            break;
                        }
                        if (!__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                            break;
                        __c = __sb->snextc();
                    }
            } catch (const __cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template<> class basic_istream<char> : virtual public basic_ios<char, char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, char_traits<char>> __streambuf_type;
        typedef basic_ios<char, char_traits<char>> __ios_type;
        typedef basic_istream<char, char_traits<char>> __istream_type;
        typedef num_get<char, istreambuf_iterator<char, char_traits<char>>> __num_get_type;
        typedef ctype<char> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream(__streambuf_type *__sb);
        virtual ~basic_istream<char>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<char> traits_type;
            typedef basic_streambuf<char, char_traits<char>> __streambuf_type;
            typedef basic_istream<char, char_traits<char>> __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<char>::int_type __int_type;
            explicit sentry(basic_istream<char, char_traits<char>> &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &));
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &));
        __istream_type &operator>>(ios_base &(*__pf)(ios_base &));
        __istream_type &operator>>(bool &__n);
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n);
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n);
        __istream_type &operator>>(long &__n);
        __istream_type &operator>>(unsigned long &__n);
        __istream_type &operator>>(long long &__n);
        __istream_type &operator>>(unsigned long long &__n);
        __istream_type &operator>>(float &__f);
        __istream_type &operator>>(double &__f);
        __istream_type &operator>>(long double &__f);
        __istream_type &operator>>(void *&__p);
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const;
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n);
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb);
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n);
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const basic_istream<char> &) = delete
        basic_istream(basic_istream<char> &&__rhs);
        basic_istream<char> &operator=(const basic_istream<char> &) = delete
        basic_istream<char> &operator=(basic_istream<char> &&__rhs);
        void swap(basic_istream<char> &__rhs);
        template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<char> : public basic_istream<char, char_traits<char>>, public basic_ostream<char, char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_istream<char, char_traits<char>> __istream_type;
        typedef basic_ostream<char, char_traits<char>> __ostream_type;
        explicit basic_iostream(basic_streambuf<char, char_traits<char>> *__sb);
        virtual ~basic_iostream<char>() throw();
    protected:
        basic_iostream();
        basic_iostream(const basic_iostream<char> &) = delete
        basic_iostream(basic_iostream<char> &&__rhs);
        basic_iostream<char> &operator=(const basic_iostream<char> &) = delete
        basic_iostream<char> &operator=(basic_iostream<char> &&__rhs);
        void swap(basic_iostream<char> &__rhs);
    };
    template<> class basic_istream<wchar_t> : virtual public basic_ios<wchar_t, char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, char_traits<wchar_t>> __streambuf_type;
        typedef basic_ios<wchar_t, char_traits<wchar_t>> __ios_type;
        typedef basic_istream<wchar_t, char_traits<wchar_t>> __istream_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>> __num_get_type;
        typedef ctype<wchar_t> __ctype_type;
    protected:
        streamsize _M_gcount;
    public:
        explicit basic_istream(__streambuf_type *__sb);
        virtual ~basic_istream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef basic_streambuf<wchar_t, char_traits<wchar_t>> __streambuf_type;
            typedef basic_istream<wchar_t, char_traits<wchar_t>> __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<wchar_t>::int_type __int_type;
            explicit sentry(basic_istream<wchar_t, char_traits<wchar_t>> &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &));
        __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &));
        __istream_type &operator>>(ios_base &(*__pf)(ios_base &));
        __istream_type &operator>>(bool &__n);
        __istream_type &operator>>(short &__n);
        __istream_type &operator>>(unsigned short &__n);
        __istream_type &operator>>(int &__n);
        __istream_type &operator>>(unsigned int &__n);
        __istream_type &operator>>(long &__n);
        __istream_type &operator>>(unsigned long &__n);
        __istream_type &operator>>(long long &__n);
        __istream_type &operator>>(unsigned long long &__n);
        __istream_type &operator>>(float &__f);
        __istream_type &operator>>(double &__f);
        __istream_type &operator>>(long double &__f);
        __istream_type &operator>>(void *&__p);
        __istream_type &operator>>(__streambuf_type *__sb);
        streamsize gcount() const;
        int_type get();
        __istream_type &get(char_type &__c);
        __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &get(char_type *__s, streamsize __n);
        __istream_type &get(__streambuf_type &__sb, char_type __delim);
        __istream_type &get(__streambuf_type &__sb);
        __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
        __istream_type &getline(char_type *__s, streamsize __n);
        __istream_type &ignore(streamsize __n, int_type __delim);
        __istream_type &ignore(streamsize __n);
        __istream_type &ignore();
        int_type peek();
        __istream_type &read(char_type *__s, streamsize __n);
        streamsize readsome(char_type *__s, streamsize __n);
        __istream_type &putback(char_type __c);
        __istream_type &unget();
        int sync();
        pos_type tellg();
        __istream_type &seekg(pos_type);
        __istream_type &seekg(off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const basic_istream<wchar_t> &) = delete
        basic_istream(basic_istream<wchar_t> &&__rhs);
        basic_istream<wchar_t> &operator=(const basic_istream<wchar_t> &) = delete
        basic_istream<wchar_t> &operator=(basic_istream<wchar_t> &&__rhs);
        void swap(basic_istream<wchar_t> &__rhs);
        template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<wchar_t> : public basic_istream<wchar_t, char_traits<wchar_t>>, public basic_ostream<wchar_t, char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_istream<wchar_t, char_traits<wchar_t>> __istream_type;
        typedef basic_ostream<wchar_t, char_traits<wchar_t>> __ostream_type;
        explicit basic_iostream(basic_streambuf<wchar_t, char_traits<wchar_t>> *__sb);
        virtual ~basic_iostream<wchar_t>() throw();
    protected:
        basic_iostream();
        basic_iostream(const basic_iostream<wchar_t> &) = delete
        basic_iostream(basic_iostream<wchar_t> &&__rhs);
        basic_iostream<wchar_t> &operator=(const basic_iostream<wchar_t> &) = delete
        basic_iostream<wchar_t> &operator=(basic_iostream<wchar_t> &&__rhs);
        void swap(basic_iostream<wchar_t> &__rhs);
    };
}
namespace std {
    extern istream cin;
    extern ostream cout;
    extern ostream cerr;
    extern ostream clog;
    extern wistream wcin;
    extern wostream wcout;
    extern wostream wcerr;
    extern wostream wclog;
    __asm (".globl _ZSt21ios_base_library_initv");
}
namespace std {
    template <typename _ValueType, typename _Tp> constexpr bool __check_constructible() {
        static_assert(is_constructible<_ValueType, _Tp>::value, "result type must be constructible from input type");
        return true;
    }
    template<> constexpr bool __check_constructible<int, const int &>() {
        static_assert(is_constructible<int, const int &>::value, "result type must be constructible from input type");
        return true;
    }
    template<> constexpr bool __check_constructible<Base<ChildA, ChildB, ChildC> *, Base<ChildA, ChildB, ChildC> *const &>() {
        static_assert(is_constructible<Base<ChildA, ChildB, ChildC> *, Base<ChildA, ChildB, ChildC> *const &>::value, "result type must be constructible from input type");
        return true;
    }
    template <typename _InputIterator, typename _ForwardIterator> constexpr _ForwardIterator __do_uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
        _ForwardIterator __cur = __result;
        try {
            for (; __first != __last; ++__first , (void)++__cur)
                std::_Construct(std::__addressof(*__cur), *__first);
            return __cur;
        } catch (...) {
            std::_Destroy(__result, __cur);
            throw;
        }
    }
    template<> constexpr int *__do_uninit_copy<const int *, int *>(const int *__first, const int *__last, int *__result) {
        int *__cur = __result;
        try {
            for (; __first != __last; ++__first , (void)++__cur)
                std::_Construct(std::__addressof(*__cur), *__first);
            return __cur;
        } catch (...) {
            std::_Destroy(__result, __cur);
            throw;
        }
    }
    template<> constexpr Base<ChildA, ChildB, ChildC> **__do_uninit_copy<Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
        Base<ChildA, ChildB, ChildC> **__cur = __result;
        try {
            for (; __first != __last; ++__first , (void)++__cur)
                std::_Construct(std::__addressof(*__cur), *__first);
            return __cur;
        } catch (...) {
            std::_Destroy(__result, __cur);
            throw;
        }
    }
    template <bool _TrivialValueTypes> struct __uninitialized_copy {
        template <typename _InputIterator, typename _ForwardIterator> static _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
            return std::__do_uninit_copy(__first, __last, __result);
        }
    };
    template<> struct __uninitialized_copy<true> {
        template <typename _InputIterator, typename _ForwardIterator> static _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
            return std::copy(__first, __last, __result);
        }
        template<> static int *__uninit_copy<const int *, int *>(const int *__first, const int *__last, int *__result) {
            return std::copy(__first, __last, __result);
        }
        template<> static Base<ChildA, ChildB, ChildC> **__uninit_copy<Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
            return std::copy(__first, __last, __result);
        }
    };
    template <typename _InputIterator, typename _ForwardIterator> inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
        typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
        const bool __can_memmove = __is_trivial(_ValueType1);
        using _From = decltype(*__first);
        const bool __assignable = __is_trivial(_ValueType2) && __is_assignable(_ValueType2 &, _From) && std::__check_constructible<_ValueType2, _From>();
        return std::__uninitialized_copy<__can_memmove && __assignable>::__uninit_copy(__first, __last, __result);
    }
    template<> inline int *uninitialized_copy<const int *, int *>(const int *__first, const int *__last, int *__result) {
        typedef typename iterator_traits<const int *>::value_type _ValueType1;
        typedef typename iterator_traits<int *>::value_type _ValueType2;
        const bool __can_memmove = __is_trivial(_ValueType1);
        using _From = decltype(*__first);
        const bool __assignable = __is_trivial(_ValueType2) && __is_assignable(_ValueType2 &, _From) && std::__check_constructible<_ValueType2, _From>();
        return std::__uninitialized_copy<__can_memmove && __assignable>::__uninit_copy(__first, __last, __result);
    }
    template<> inline Base<ChildA, ChildB, ChildC> **uninitialized_copy<Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result) {
        typedef typename iterator_traits<Base<ChildA, ChildB, ChildC> *const *>::value_type _ValueType1;
        typedef typename iterator_traits<Base<ChildA, ChildB, ChildC> **>::value_type _ValueType2;
        const bool __can_memmove = __is_trivial(_ValueType1);
        using _From = decltype(*__first);
        const bool __assignable = __is_trivial(_ValueType2) && __is_assignable(_ValueType2 &, _From) && std::__check_constructible<_ValueType2, _From>();
        return std::__uninitialized_copy<__can_memmove && __assignable>::__uninit_copy(__first, __last, __result);
    }
    template <typename _ForwardIterator, typename _Tp> constexpr void __do_uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x) {
        _ForwardIterator __cur = __first;
        try {
            for (; __cur != __last; ++__cur)
                std::_Construct(std::__addressof(*__cur), __x);
        } catch (...) {
            std::_Destroy(__first, __cur);
            throw;
        }
    }
    template <bool _TrivialValueType> struct __uninitialized_fill {
        template <typename _ForwardIterator, typename _Tp> static void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x) {
            std::__do_uninit_fill(__first, __last, __x);
        }
    };
    template<> struct __uninitialized_fill<true> {
        template <typename _ForwardIterator, typename _Tp> static void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x) {
            std::fill(__first, __last, __x);
        }
    };
    template <typename _ForwardIterator, typename _Tp> inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        const bool __can_fill = __is_trivial(_ValueType) && __is_assignable(_ValueType &, const _Tp &) && std::__check_constructible<_ValueType, const _Tp &>();
        std::__uninitialized_fill<__can_fill>::__uninit_fill(__first, __last, __x);
    }
    template <typename _ForwardIterator, typename _Size, typename _Tp> constexpr _ForwardIterator __do_uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) {
        _ForwardIterator __cur = __first;
        try {
            for (; __n > 0; --__n , (void)++__cur)
                std::_Construct(std::__addressof(*__cur), __x);
            return __cur;
        } catch (...) {
            std::_Destroy(__first, __cur);
            throw;
        }
    }
    template <bool _TrivialValueType> struct __uninitialized_fill_n {
        template <typename _ForwardIterator, typename _Size, typename _Tp> static _ForwardIterator __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) {
            return std::__do_uninit_fill_n(__first, __n, __x);
        }
    };
    template<> struct __uninitialized_fill_n<true> {
        template <typename _ForwardIterator, typename _Size, typename _Tp> static _ForwardIterator __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) {
            return std::fill_n(__first, __n, __x);
        }
    };
    template <typename _ForwardIterator, typename _Size, typename _Tp> inline _ForwardIterator uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        const bool __can_fill = __is_trivial(_ValueType) && __is_assignable(_ValueType &, const _Tp &) && std::__check_constructible<_ValueType, const _Tp &>() && __is_integer<_Size>::__value;
        return __uninitialized_fill_n<__can_fill>::__uninit_fill_n(__first, __n, __x);
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> constexpr _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) {
        _ForwardIterator __cur = __result;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __first != __last; ++__first , (void)++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur), *__first);
            return __cur;
        } catch (...) {
            std::_Destroy(__result, __cur, __alloc);
            throw;
        }
    }
    template<> constexpr int *__uninitialized_copy_a<const int *, int *, std::allocator<int>>(const int *__first, const int *__last, int *__result, std::allocator<int> &__alloc)    template<> constexpr Base<ChildA, ChildB, ChildC> **__uninitialized_copy_a<Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **, std::allocator<Base<ChildA, ChildB, ChildC> *>>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result, std::allocator<Base<ChildA, ChildB, ChildC> *> &__alloc)    template <typename _InputIterator, typename _ForwardIterator, typename _Tp> inline constexpr _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, allocator<_Tp> &) {
        if (std::is_constant_evaluated())
            return std::__do_uninit_copy(__first, __last, __result);
        return std::uninitialized_copy(__first, __last, __result);
    }
    template<> inline constexpr int *__uninitialized_copy_a<const int *, int *, int>(const int *__first, const int *__last, int *__result, allocator<int> &) {
        if (std::is_constant_evaluated())
            return std::__do_uninit_copy(__first, __last, __result);
        return std::uninitialized_copy(__first, __last, __result);
    }
    template<> inline constexpr Base<ChildA, ChildB, ChildC> **__uninitialized_copy_a<Base<ChildA, ChildB, ChildC> *const *, Base<ChildA, ChildB, ChildC> **, Base<ChildA, ChildB, ChildC> *>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, Base<ChildA, ChildB, ChildC> **__result, allocator<Base<ChildA, ChildB, ChildC> *> &) {
        if (std::is_constant_evaluated())
            return std::__do_uninit_copy(__first, __last, __result);
        return std::uninitialized_copy(__first, __last, __result);
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> inline constexpr _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) {
        return std::__uninitialized_copy_a(std::make_move_iterator(__first), std::make_move_iterator(__last), __result, __alloc);
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> inline constexpr _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) {
        return std::__uninitialized_copy_a(std::__make_move_if_noexcept_iterator(__first), std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }
    template <typename _ForwardIterator, typename _Tp, typename _Allocator> constexpr void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc) {
        _ForwardIterator __cur = __first;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __cur != __last; ++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur), __x);
        } catch (...) {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Tp, typename _Tp2> inline constexpr void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, allocator<_Tp2> &) {
        if (std::is_constant_evaluated())
            return std::__do_uninit_fill(__first, __last, __x);
        std::uninitialized_fill(__first, __last, __x);
    }
    template <typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator> constexpr _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc) {
        _ForwardIterator __cur = __first;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __n > 0; --__n , (void)++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur), __x);
            return __cur;
        } catch (...) {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2> inline constexpr _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, allocator<_Tp2> &) {
        if (std::is_constant_evaluated())
            return std::__do_uninit_fill_n(__first, __n, __x);
        return std::uninitialized_fill_n(__first, __n, __x);
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator> inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc) {
        _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc);
        try {
            return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
        } catch (...) {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator> inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc) {
        _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc);
        try {
            return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
        } catch (...) {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator> inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc) {
        std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
        try {
            return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
        } catch (...) {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator> inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc) {
        _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc);
        try {
            std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
        } catch (...) {
            std::_Destroy(__first2, __mid2, __alloc);
            throw;
        }
    }
    template <bool _TrivialValueType> struct __uninitialized_default_1 {
        template <typename _ForwardIterator> static void __uninit_default(_ForwardIterator __first, _ForwardIterator __last) {
            _ForwardIterator __cur = __first;
            try {
                for (; __cur != __last; ++__cur)
                    std::_Construct(std::__addressof(*__cur));
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_default_1<true> {
        template <typename _ForwardIterator> static void __uninit_default(_ForwardIterator __first, _ForwardIterator __last) {
            if (__first == __last)
                return;
            typename iterator_traits<_ForwardIterator>::value_type *__val = std::__addressof(*__first);
            std::_Construct(__val);
            if (++__first != __last)
                std::fill(__first, __last, *__val);
        }
    };
    template <bool _TrivialValueType> struct __uninitialized_default_n_1 {
        template <typename _ForwardIterator, typename _Size> static constexpr _ForwardIterator __uninit_default_n(_ForwardIterator __first, _Size __n) {
            _ForwardIterator __cur = __first;
            try {
                for (; __n > 0; --__n , (void)++__cur)
                    std::_Construct(std::__addressof(*__cur));
                return __cur;
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_default_n_1<false> {
        template <typename _ForwardIterator, typename _Size> static constexpr _ForwardIterator __uninit_default_n(_ForwardIterator __first, _Size __n);
    };
    template<> struct __uninitialized_default_n_1<true> {
        template <typename _ForwardIterator, typename _Size> static constexpr _ForwardIterator __uninit_default_n(_ForwardIterator __first, _Size __n) {
            if (__n > 0) {
                typename iterator_traits<_ForwardIterator>::value_type *__val = std::__addressof(*__first);
                std::_Construct(__val);
                ++__first;
                __first = std::fill_n(__first, __n - 1, *__val);
            }
            return __first;
        }
    };
    template <typename _ForwardIterator> inline void __uninitialized_default(_ForwardIterator __first, _ForwardIterator __last) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        const bool __assignable = is_copy_assignable<_ValueType>::value;
        std::__uninitialized_default_1<__is_trivial(_ValueType) && __assignable>::__uninit_default(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline constexpr _ForwardIterator __uninitialized_default_n(_ForwardIterator __first, _Size __n) {
        if (std::is_constant_evaluated())
            return __uninitialized_default_n_1<false>::__uninit_default_n(__first, __n);
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        constexpr bool __can_fill = __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
        return __uninitialized_default_n_1<__is_trivial(_ValueType) && __can_fill>::__uninit_default_n(__first, __n);
    }
    template <typename _ForwardIterator, typename _Allocator> void __uninitialized_default_a(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc) {
        _ForwardIterator __cur = __first;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __cur != __last; ++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur));
        } catch (...) {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Tp> inline void __uninitialized_default_a(_ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &) {
        std::__uninitialized_default(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size, typename _Allocator> constexpr _ForwardIterator __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, _Allocator &__alloc) {
        _ForwardIterator __cur = __first;
        try {
            typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
            for (; __n > 0; --__n , (void)++__cur)
                __traits::construct(__alloc, std::__addressof(*__cur));
            return __cur;
        } catch (...) {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template <typename _ForwardIterator, typename _Size, typename _Tp> inline constexpr _ForwardIterator __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, allocator<_Tp> &) {
        return std::__uninitialized_default_n(__first, __n);
    }
    template <bool _TrivialValueType> struct __uninitialized_default_novalue_1 {
        template <typename _ForwardIterator> static void __uninit_default_novalue(_ForwardIterator __first, _ForwardIterator __last) {
            _ForwardIterator __cur = __first;
            try {
                for (; __cur != __last; ++__cur)
                    std::_Construct_novalue(std::__addressof(*__cur));
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_default_novalue_1<true> {
        template <typename _ForwardIterator> static void __uninit_default_novalue(_ForwardIterator __first, _ForwardIterator __last) {
        }
    };
    template <bool _TrivialValueType> struct __uninitialized_default_novalue_n_1 {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __uninit_default_novalue_n(_ForwardIterator __first, _Size __n) {
            _ForwardIterator __cur = __first;
            try {
                for (; __n > 0; --__n , (void)++__cur)
                    std::_Construct_novalue(std::__addressof(*__cur));
                return __cur;
            } catch (...) {
                std::_Destroy(__first, __cur);
                throw;
            }
        }
    };
    template<> struct __uninitialized_default_novalue_n_1<true> {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __uninit_default_novalue_n(_ForwardIterator __first, _Size __n) {
            return std::next(__first, __n);
        }
    };
    template <typename _ForwardIterator> inline void __uninitialized_default_novalue(_ForwardIterator __first, _ForwardIterator __last) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        std::__uninitialized_default_novalue_1<is_trivially_default_constructible<_ValueType>::value>::__uninit_default_novalue(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline _ForwardIterator __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n) {
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
        return __uninitialized_default_novalue_n_1<is_trivially_default_constructible<_ValueType>::value>::__uninit_default_novalue_n(__first, __n);
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> _ForwardIterator __uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator __result, input_iterator_tag) {
        _ForwardIterator __cur = __result;
        try {
            for (; __n > 0; --__n , (void)++__first , ++__cur)
                std::_Construct(std::__addressof(*__cur), *__first);
            return __cur;
        } catch (...) {
            std::_Destroy(__result, __cur);
            throw;
        }
    }
    template <typename _RandomAccessIterator, typename _Size, typename _ForwardIterator> inline _ForwardIterator __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n, _ForwardIterator __result, random_access_iterator_tag) {
        return std::uninitialized_copy(__first, __first + __n, __result);
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> pair<_InputIterator, _ForwardIterator> __uninitialized_copy_n_pair(_InputIterator __first, _Size __n, _ForwardIterator __result, input_iterator_tag) {
        _ForwardIterator __cur = __result;
        try {
            for (; __n > 0; --__n , (void)++__first , ++__cur)
                std::_Construct(std::__addressof(*__cur), *__first);
            return {__first, __cur};
        } catch (...) {
            std::_Destroy(__result, __cur);
            throw;
        }
    }
    template <typename _RandomAccessIterator, typename _Size, typename _ForwardIterator> inline pair<_RandomAccessIterator, _ForwardIterator> __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n, _ForwardIterator __result, random_access_iterator_tag) {
        auto __second_res = uninitialized_copy(__first, __first + __n, __result);
        auto __first_res = std::next(__first, __n);
        return {__first_res, __second_res};
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> inline _ForwardIterator uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator __result) {
        return std::__uninitialized_copy_n(__first, __n, __result, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> inline pair<_InputIterator, _ForwardIterator> __uninitialized_copy_n_pair(_InputIterator __first, _Size __n, _ForwardIterator __result) {
        return std::__uninitialized_copy_n_pair(__first, __n, __result, std::__iterator_category(__first));
    }
    template <typename _ForwardIterator> inline void uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {
        __uninitialized_default_novalue(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline _ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __count) {
        return __uninitialized_default_novalue_n(__first, __count);
    }
    template <typename _ForwardIterator> inline void uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {
        return __uninitialized_default(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline _ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __count) {
        return __uninitialized_default_n(__first, __count);
    }
    template <typename _InputIterator, typename _ForwardIterator> inline _ForwardIterator uninitialized_move(_InputIterator __first, _InputIterator __last, _ForwardIterator __result) {
        return std::uninitialized_copy(std::make_move_iterator(__first), std::make_move_iterator(__last), __result);
    }
    template <typename _InputIterator, typename _Size, typename _ForwardIterator> inline pair<_InputIterator, _ForwardIterator> uninitialized_move_n(_InputIterator __first, _Size __count, _ForwardIterator __result) {
        auto __res = std::__uninitialized_copy_n_pair(std::make_move_iterator(__first), __count, __result);
        return {__res.first.base(), __res.second};
    }
    template <typename _Tp, typename _Up, typename _Allocator> inline constexpr void __relocate_object_a(_Tp *__restrict __dest, _Up *__restrict __orig, _Allocator &__alloc) noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc, __dest, std::move(*__orig))) && noexcept(std::allocator_traits<_Allocator>::destroy(__alloc, std::__addressof(*__orig)))) {
        typedef std::allocator_traits<_Allocator> __traits;
        __traits::construct(__alloc, __dest, std::move(*__orig));
        __traits::destroy(__alloc, std::__addressof(*__orig));
    }
    template <typename _Tp, typename = void> struct __is_bitwise_relocatable : is_trivial<_Tp> {
    };
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> inline constexpr _ForwardIterator __relocate_a_1(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result), std::addressof(*__first), __alloc))) {
        typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
        typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
        static_assert(std::is_same<_ValueType, _ValueType2>::value, "relocation is only possible for values of the same type");
        _ForwardIterator __cur = __result;
        for (; __first != __last; ++__first , (void)++__cur)
            std::__relocate_object_a(std::__addressof(*__cur), std::__addressof(*__first), __alloc);
        return __cur;
    }
    template <typename _Tp, typename _Up> inline constexpr __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp *> __relocate_a_1(_Tp *__first, _Tp *__last, _Tp *__result, allocator<_Up> &__alloc [[maybe_unused]]) noexcept {
        ptrdiff_t __count = __last - __first;
        if (__count > 0) {
            if (std::is_constant_evaluated()) {
                __gnu_cxx::__normal_iterator<_Tp *, void> __out(__result);
                __out = std::__relocate_a_1(__first, __last, __out, __alloc);
                return __out.base();
            }
            __builtin_memmove(__result, __first, __count * sizeof(_Tp));
        }
        return __result + __count;
    }
    template <typename _InputIterator, typename _ForwardIterator, typename _Allocator> inline constexpr _ForwardIterator __relocate_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc) noexcept(noexcept(__relocate_a_1(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result), __alloc))) {
        return std::__relocate_a_1(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result), __alloc);
    }
}
namespace std {
    template <typename _Tp, typename _Alloc> struct _Vector_base {
        typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;
        typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer pointer;
        struct _Vector_impl_data {
            pointer _M_start;
            pointer _M_finish;
            pointer _M_end_of_storage;
            constexpr _Vector_impl_data() noexcept : _M_start(), _M_finish(), _M_end_of_storage() {
            }
            constexpr _Vector_impl_data(_Vector_impl_data &&__x) noexcept : _M_start(__x._M_start), _M_finish(__x._M_finish), _M_end_of_storage(__x._M_end_of_storage) {
                __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer();
            }
            constexpr void _M_copy_data(const _Vector_impl_data &__x) noexcept {
                this->_M_start = __x._M_start;
                this->_M_finish = __x._M_finish;
                this->_M_end_of_storage = __x._M_end_of_storage;
            }
            constexpr void _M_swap_data(_Vector_impl_data &__x) noexcept {
                _Vector_impl_data __tmp;
                __tmp._M_copy_data(*this);
                this->_M_copy_data(__x);
                __x._M_copy_data(__tmp);
            }
        };
        struct _Vector_impl : public _Tp_alloc_type, public _Vector_impl_data {
            constexpr _Vector_impl() noexcept(is_nothrow_default_constructible<_Tp_alloc_type>::value) : _Tp_alloc_type() {
            }
            constexpr _Vector_impl(const _Tp_alloc_type &__a) noexcept : _Tp_alloc_type(__a) {
            }
            constexpr _Vector_impl(_Vector_impl &&__x) noexcept : _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x)) {
            }
            constexpr _Vector_impl(_Tp_alloc_type &&__a) noexcept : _Tp_alloc_type(std::move(__a)) {
            }
            constexpr _Vector_impl(_Tp_alloc_type &&__a, _Vector_impl &&__rv) noexcept : _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv)) {
            }
        };
    public:
        typedef _Alloc allocator_type;
        constexpr _Tp_alloc_type &_M_get_Tp_allocator() noexcept {
            return this->_M_impl;
        }
        constexpr const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept {
            return this->_M_impl;
        }
        constexpr allocator_type get_allocator() const noexcept {
            return allocator_type(_M_get_Tp_allocator());
        }
        _Vector_base<_Tp, _Alloc>() = default
        constexpr _Vector_base<_Tp, _Alloc>(const allocator_type &__a) noexcept : _M_impl(__a) {
        }
        constexpr _Vector_base<_Tp, _Alloc>(size_t __n) : _M_impl() {
            this->_M_create_storage(__n);
        }
        constexpr _Vector_base<_Tp, _Alloc>(size_t __n, const allocator_type &__a) : _M_impl(__a) {
            this->_M_create_storage(__n);
        }
        _Vector_base<_Tp, _Alloc>(_Vector_base<_Tp, _Alloc> &&) = default
        constexpr _Vector_base<_Tp, _Alloc>(_Tp_alloc_type &&__a) noexcept : _M_impl(std::move(__a)) {
        }
        constexpr _Vector_base<_Tp, _Alloc>(_Vector_base<_Tp, _Alloc> &&__x, const allocator_type &__a) : _M_impl(__a) {
            if (__x.get_allocator() == __a)
                this->_M_impl._M_swap_data(__x._M_impl);
            else {
                size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                this->_M_create_storage(__n);
            }
        }
        constexpr _Vector_base<_Tp, _Alloc>(const allocator_type &__a, _Vector_base<_Tp, _Alloc> &&__x) : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl)) {
        }
        constexpr ~_Vector_base<_Tp, _Alloc>() noexcept {
            this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        }
    public:
        _Vector_impl _M_impl;
        constexpr pointer _M_allocate(size_t __n) {
            typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
            return __n != 0 ? _Tr::allocate(this->_M_impl, __n) : pointer();
        }
        constexpr void _M_deallocate(pointer __p, size_t __n) {
            typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
            if (__p)
                _Tr::deallocate(this->_M_impl, __p, __n);
        }
    protected:
        constexpr void _M_create_storage(size_t __n) {
            this->_M_impl._M_start = this->_M_allocate(__n);
            this->_M_impl._M_finish = this->_M_impl._M_start;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
        }
    };
    template<> struct _Vector_base<int, std::allocator<int>> {
        typedef typename __gnu_cxx::__alloc_traits<allocator<int>>::rebind<int>::other _Tp_alloc_type;
        typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer pointer;
        struct _Vector_impl_data {
            pointer _M_start;
            pointer _M_finish;
            pointer _M_end_of_storage;
        };
        struct _Vector_impl : public _Tp_alloc_type, public _Vector_impl_data {
        };
    public:
        typedef std::allocator<int> allocator_type;
        constexpr _Tp_alloc_type &_M_get_Tp_allocator() noexcept {
            return this->_M_impl;
        }
        constexpr const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept {
            return this->_M_impl;
        }
        constexpr allocator_type get_allocator() const noexcept {
            return allocator_type(this->_M_get_Tp_allocator());
        }
        _Vector_base() noexcept : _M_impl() = default        constexpr _Vector_base(const allocator_type &__a) noexcept : _M_impl(__a) {
        }
        constexpr _Vector_base(size_t __n);
        constexpr _Vector_base(size_t __n, const allocator_type &__a);
        _Vector_base(_Vector_base<int, allocator<int>> &&) noexcept : _M_impl(static_cast<_Vector_base<int, allocator<int>> &&>()._M_impl) = default        constexpr _Vector_base(_Tp_alloc_type &&__a) noexcept;
        constexpr _Vector_base(_Vector_base<int, allocator<int>> &&__x, const allocator_type &__a);
        constexpr _Vector_base(const allocator_type &__a, _Vector_base<int, allocator<int>> &&__x);
        constexpr ~_Vector_base<int, allocator<int>>() noexcept {
            this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        }
    public:
        _Vector_impl _M_impl;
        constexpr pointer _M_allocate(size_t __n) {
            typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
            return __n != 0 ? _Tr::allocate(this->_M_impl, __n) : pointer();
        }
        constexpr void _M_deallocate(pointer __p, size_t __n) {
            typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
            if (__p)
                _Tr::deallocate(this->_M_impl, __p, __n);
        }
    protected:
        constexpr void _M_create_storage(size_t __n);
    };
    template<> struct _Vector_base<Base<ChildA, ChildB, ChildC> *, std::allocator<Base<ChildA, ChildB, ChildC> *>> {
        typedef typename __gnu_cxx::__alloc_traits<allocator<Base<ChildA, ChildB, ChildC> *>>::rebind<Base<ChildA, ChildB, ChildC> *>::other _Tp_alloc_type;
        typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer pointer;
        struct _Vector_impl_data {
            pointer _M_start;
            pointer _M_finish;
            pointer _M_end_of_storage;
        };
        struct _Vector_impl : public _Tp_alloc_type, public _Vector_impl_data {
        };
    public:
        typedef std::allocator<Base<ChildA, ChildB, ChildC> *> allocator_type;
        constexpr _Tp_alloc_type &_M_get_Tp_allocator() noexcept {
            return this->_M_impl;
        }
        constexpr const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept;
        constexpr allocator_type get_allocator() const noexcept;
        _Vector_base() = default
        constexpr _Vector_base(const allocator_type &__a) noexcept : _M_impl(__a) {
        }
        constexpr _Vector_base(size_t __n);
        constexpr _Vector_base(size_t __n, const allocator_type &__a);
        _Vector_base(_Vector_base<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>> &&) = default
        constexpr _Vector_base(_Tp_alloc_type &&__a) noexcept;
        constexpr _Vector_base(_Vector_base<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>> &&__x, const allocator_type &__a);
        constexpr _Vector_base(const allocator_type &__a, _Vector_base<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>> &&__x);
        constexpr ~_Vector_base<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>>() noexcept {
            this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        }
    public:
        _Vector_impl _M_impl;
        constexpr pointer _M_allocate(size_t __n) {
            typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
            return __n != 0 ? _Tr::allocate(this->_M_impl, __n) : pointer();
        }
        constexpr void _M_deallocate(pointer __p, size_t __n) {
            typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
            if (__p)
                _Tr::deallocate(this->_M_impl, __p, __n);
        }
    protected:
        constexpr void _M_create_storage(size_t __n);
    };
    template <typename _Tp, typename _Alloc = std::allocator<_Tp>> class vector : protected _Vector_base<_Tp, _Alloc> {
        static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value, "std::vector must have a non-const, non-volatile value_type");
        static_assert(is_same<typename _Alloc::value_type, _Tp>::value, "std::vector must have the same value_type as its allocator");
        typedef _Vector_base<_Tp, _Alloc> _Base;
        typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;
    public:
        typedef _Tp value_type;
        typedef typename _Base::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef __gnu_cxx::__normal_iterator<pointer, vector<_Tp, _Alloc>> iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, vector<_Tp, _Alloc>> const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef _Alloc allocator_type;
    private:
        static constexpr bool _S_nothrow_relocate(true_type) {
            return noexcept(std::__relocate_a(std::declval<pointer>(), std::declval<pointer>(), std::declval<pointer>(), std::declval<_Tp_alloc_type &>()));
        }
        static constexpr bool _S_nothrow_relocate(false_type) {
            return false;
        }
        static constexpr bool _S_use_relocate() {
            return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
        }
        static pointer _S_do_relocate(pointer __first, pointer __last, pointer __result, _Tp_alloc_type &__alloc, true_type) noexcept {
            return std::__relocate_a(__first, __last, __result, __alloc);
        }
        static pointer _S_do_relocate(pointer, pointer, pointer __result, _Tp_alloc_type &, false_type) noexcept {
            return __result;
        }
        static constexpr pointer _S_relocate(pointer __first, pointer __last, pointer __result, _Tp_alloc_type &__alloc) noexcept {
            return std::__relocate_a(__first, __last, __result, __alloc);
        }
    protected:
        using _Base::_M_allocate;
        using _Base::_M_deallocate;
        using _Base::_M_impl;
        using _Base::_M_get_Tp_allocator;
    public:
        vector<_Tp, _Alloc>() = default
        constexpr explicit vector<_Tp, _Alloc>(const allocator_type &__a) noexcept : _Base(__a) {
        }
        constexpr explicit vector<_Tp, _Alloc>(size_type __n, const allocator_type &__a = allocator_type()) : _Base(_S_check_init_len(__n, __a), __a) {
            this->_M_default_initialize(__n);
        }
        constexpr vector<_Tp, _Alloc>(size_type __n, const value_type &__value, const allocator_type &__a = allocator_type()) : _Base(_S_check_init_len(__n, __a), __a) {
            this->_M_fill_initialize(__n, __value);
        }
        constexpr vector<_Tp, _Alloc>(const vector<_Tp, _Alloc> &__x) : _Base(__x.size(), _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator())) {
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
        }
        vector<_Tp, _Alloc>(vector<_Tp, _Alloc> &&) noexcept = default
        constexpr vector<_Tp, _Alloc>(const vector<_Tp, _Alloc> &__x, const __type_identity_t<allocator_type> &__a) : _Base(__x.size(), __a) {
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
        }
    private:
        constexpr vector<_Tp, _Alloc>(vector<_Tp, _Alloc> &&__rv, const allocator_type &__m, true_type) noexcept : _Base(__m, std::move(__rv)) {
        }
        constexpr vector<_Tp, _Alloc>(vector<_Tp, _Alloc> &&__rv, const allocator_type &__m, false_type) : _Base(__m) {
            if (__rv.get_allocator() == __m)
                this->_M_impl._M_swap_data(__rv._M_impl);
            else if (!__rv.empty()) {
                this->_M_create_storage(__rv.size());
                this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
                __rv.clear();
            }
        }
    public:
        constexpr vector<_Tp, _Alloc>(vector<_Tp, _Alloc> &&__rv, const __type_identity_t<allocator_type> &__m) noexcept(noexcept(vector<_Tp, _Alloc>(std::declval<vector<_Tp, _Alloc> &&>(), std::declval<const allocator_type &>(), std::declval<typename _Alloc_traits::is_always_equal>()))) : vector<_Tp, _Alloc>(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{}) {
        }
        constexpr vector<_Tp, _Alloc>(initializer_list<value_type> __l, const allocator_type &__a = allocator_type()) : _Base(__a) {
            _M_range_initialize(__l.begin(), __l.end(), random_access_iterator_tag());
        }
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr vector<_Tp, _Alloc>(_InputIterator __first, _InputIterator __last, const allocator_type &__a = allocator_type()) : _Base(__a) {
            _M_range_initialize(__first, __last, std::__iterator_category(__first));
        }
        constexpr ~vector<_Tp, _Alloc>() noexcept {
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            ;
        }
        constexpr vector<_Tp, _Alloc> &operator=(const vector<_Tp, _Alloc> &__x);
        constexpr vector<_Tp, _Alloc> &operator=(vector<_Tp, _Alloc> &&__x) noexcept(_Alloc_traits::_S_nothrow_move()) {
            constexpr bool __move_storage = _Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal();
            _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
            return *this;
        }
        constexpr vector<_Tp, _Alloc> &operator=(initializer_list<value_type> __l) {
            this->_M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag());
            return *this;
        }
        constexpr void assign(size_type __n, const value_type &__val) {
            this->_M_fill_assign(__n, __val);
        }
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr void assign(_InputIterator __first, _InputIterator __last) {
            _M_assign_aux(__first, __last, std::__iterator_category(__first));
        }
        constexpr void assign(initializer_list<value_type> __l) {
            this->_M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag());
        }
        using _Base::get_allocator;
        constexpr iterator begin() noexcept [[nodiscard("")]] {
            return iterator(this->_M_impl._M_start);
        }
        constexpr const_iterator begin() const noexcept [[nodiscard("")]] {
            return const_iterator(this->_M_impl._M_start);
        }
        constexpr iterator end() noexcept [[nodiscard("")]] {
            return iterator(this->_M_impl._M_finish);
        }
        constexpr const_iterator end() const noexcept [[nodiscard("")]] {
            return const_iterator(this->_M_impl._M_finish);
        }
        constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]] {
            return reverse_iterator(end());
        }
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(end());
        }
        constexpr reverse_iterator rend() noexcept [[nodiscard("")]] {
            return reverse_iterator(begin());
        }
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(begin());
        }
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]] {
            return const_iterator(this->_M_impl._M_start);
        }
        constexpr const_iterator cend() const noexcept [[nodiscard("")]] {
            return const_iterator(this->_M_impl._M_finish);
        }
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(end());
        }
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(begin());
        }
        constexpr size_type size() const noexcept [[nodiscard("")]] {
            return size_type(this->_M_impl._M_finish - this->_M_impl._M_start);
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]] {
            return _S_max_size(_M_get_Tp_allocator());
        }
        constexpr void resize(size_type __new_size) {
            if (__new_size > this->size())
                this->_M_default_append(__new_size - this->size());
            else if (__new_size < this->size())
                this->_M_erase_at_end(this->_M_impl._M_start + __new_size);
        }
        constexpr void resize(size_type __new_size, const value_type &__x) {
            if (__new_size > this->size())
                this->_M_fill_insert(end(), __new_size - this->size(), __x);
            else if (__new_size < this->size())
                this->_M_erase_at_end(this->_M_impl._M_start + __new_size);
        }
        constexpr void shrink_to_fit() {
            this->_M_shrink_to_fit();
        }
        constexpr size_type capacity() const noexcept [[nodiscard("")]] {
            return size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        }
        constexpr bool empty() const noexcept [[nodiscard("")]] {
            return begin() == end();
        }
        constexpr void reserve(size_type __n);
        constexpr reference operator[](size_type __n) noexcept [[nodiscard("")]] {
            ;
            return *(this->_M_impl._M_start + __n);
        }
        constexpr const_reference operator[](size_type __n) const noexcept [[nodiscard("")]] {
            ;
            return *(this->_M_impl._M_start + __n);
        }
    protected:
        constexpr void _M_range_check(size_type __n) const {
            if (__n >= this->size())
                __throw_out_of_range_fmt(("vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
        }
    public:
        constexpr reference at(size_type __n) {
            this->_M_range_check(__n);
            return (*this)[__n];
        }
        constexpr const_reference at(size_type __n) const {
            this->_M_range_check(__n);
            return (*this)[__n];
        }
        constexpr reference front() noexcept [[nodiscard("")]] {
            ;
            return *begin();
        }
        constexpr const_reference front() const noexcept [[nodiscard("")]] {
            ;
            return *begin();
        }
        constexpr reference back() noexcept [[nodiscard("")]] {
            ;
            return *(end() - 1);
        }
        constexpr const_reference back() const noexcept [[nodiscard("")]] {
            ;
            return *(end() - 1);
        }
        constexpr _Tp *data() noexcept [[nodiscard("")]] {
            return _M_data_ptr(this->_M_impl._M_start);
        }
        constexpr const _Tp *data() const noexcept [[nodiscard("")]] {
            return _M_data_ptr(this->_M_impl._M_start);
        }
        constexpr void push_back(const value_type &__x) {
            if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {
                ;
                _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
                ++this->_M_impl._M_finish;
                ;
            } else
                _M_realloc_insert(end(), __x);
        }
        constexpr void push_back(value_type &&__x) {
            emplace_back(std::move(__x));
        }
        template <typename ..._Args> constexpr reference emplace_back(_Args &&...__args);
        constexpr void pop_back() noexcept {
            ;
            --this->_M_impl._M_finish;
            _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
            ;
        }
        template <typename ..._Args> constexpr iterator emplace(const_iterator __position, _Args &&...__args) {
            return _M_emplace_aux(__position, std::forward<_Args>(__args)...);
        }
        constexpr iterator insert(const_iterator __position, const value_type &__x);
        constexpr iterator insert(const_iterator __position, value_type &&__x) {
            return this->_M_insert_rval(__position, std::move(__x));
        }
        constexpr iterator insert(const_iterator __position, initializer_list<value_type> __l) {
            auto __offset = __position - this->cbegin();
            _M_range_insert(begin() + __offset, __l.begin(), __l.end(), std::random_access_iterator_tag());
            return begin() + __offset;
        }
        constexpr iterator insert(const_iterator __position, size_type __n, const value_type &__x) {
            difference_type __offset = __position - this->cbegin();
            this->_M_fill_insert(begin() + __offset, __n, __x);
            return begin() + __offset;
        }
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __position, _InputIterator __first, _InputIterator __last) {
            difference_type __offset = __position - this->cbegin();
            _M_range_insert(begin() + __offset, __first, __last, std::__iterator_category(__first));
            return begin() + __offset;
        }
        constexpr iterator erase(const_iterator __position) {
            return _M_erase(begin() + (__position - this->cbegin()));
        }
        constexpr iterator erase(const_iterator __first, const_iterator __last) {
            const auto __beg = begin();
            const auto __cbeg = this->cbegin();
            return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
        }
        constexpr void swap(vector<_Tp, _Alloc> &__x) noexcept {
            do {
                if (std::__is_constant_evaluated() && !bool(_Alloc_traits::propagate_on_container_swap::value || _M_get_Tp_allocator() == __x._M_get_Tp_allocator()))
                    __builtin_unreachable();
            } while (false);
            this->_M_impl._M_swap_data(__x._M_impl);
            _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
        }
        constexpr void clear() noexcept {
            this->_M_erase_at_end(this->_M_impl._M_start);
        }
    protected:
        template <typename _ForwardIterator> constexpr pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first, _ForwardIterator __last) {
            pointer __result = this->_M_allocate(__n);
            try {
                std::__uninitialized_copy_a(__first, __last, __result, _M_get_Tp_allocator());
                return __result;
            } catch (...) {
                _M_deallocate(__result, __n);
                throw;
            }
        }
        template <typename _InputIterator> constexpr void _M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
            try {
                for (; __first != __last; ++__first)
                    emplace_back(*__first);
            } catch (...) {
                this->clear();
                throw;
            }
        }
        template <typename _ForwardIterator> constexpr void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) {
            const size_type __n = std::distance(__first, __last);
            this->_M_impl._M_start = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
        }
        constexpr void _M_fill_initialize(size_type __n, const value_type &__value) {
            this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
        }
        constexpr void _M_default_initialize(size_type __n) {
            this->_M_impl._M_finish = std::__uninitialized_default_n_a(this->_M_impl._M_start, __n, _M_get_Tp_allocator());
        }
        template <typename _Integer> constexpr void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type) {
            this->_M_fill_assign(__n, __val);
        }
        template <typename _InputIterator> constexpr void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type) {
            _M_assign_aux(__first, __last, std::__iterator_category(__first));
        }
        template <typename _InputIterator> constexpr void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag);
        template <typename _ForwardIterator> constexpr void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        constexpr void _M_fill_assign(size_type __n, const value_type &__val);
        template <typename _Integer> constexpr void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, __true_type) {
            this->_M_fill_insert(__pos, __n, __val);
        }
        template <typename _InputIterator> constexpr void _M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator __last, __false_type) {
            _M_range_insert(__pos, __first, __last, std::__iterator_category(__first));
        }
        template <typename _InputIterator> constexpr void _M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag);
        template <typename _ForwardIterator> constexpr void _M_range_insert(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        constexpr void _M_fill_insert(iterator __pos, size_type __n, const value_type &__x);
        constexpr void _M_default_append(size_type __n);
        constexpr bool _M_shrink_to_fit();
        struct _Temporary_value {
            template <typename ..._Args> constexpr explicit _Temporary_value(vector<_Tp, _Alloc> *__vec, _Args &&...__args) : _M_this(__vec) {
                _Alloc_traits::construct(this->_M_this->_M_impl, this->_M_ptr(), std::forward<_Args>(__args)...);
            }
            constexpr ~_Temporary_value() {
                _Alloc_traits::destroy(this->_M_this->_M_impl, this->_M_ptr());
            }
            constexpr value_type &_M_val() noexcept {
                return this->_M_storage._M_val;
            }
        private:
            constexpr _Tp *_M_ptr() noexcept {
                return std::__addressof(this->_M_storage._M_val);
            }
            union _Storage {
                constexpr _Storage() : _M_byte(/*implicit*/(unsigned char)0) {
                }
                constexpr ~_Storage() {
                }
                _Storage &operator=(const _Storage &) = delete
                unsigned char _M_byte;
                _Tp _M_val;
            };
            vector<_Tp, _Alloc> *_M_this;
            _Storage _M_storage;
        };
        template <typename _Arg> constexpr void _M_insert_aux(iterator __position, _Arg &&__arg);
        template <typename ..._Args> constexpr void _M_realloc_insert(iterator __position, _Args &&...__args);
        constexpr iterator _M_insert_rval(const_iterator __position, value_type &&__v);
        template <typename ..._Args> constexpr iterator _M_emplace_aux(const_iterator __position, _Args &&...__args);
        constexpr iterator _M_emplace_aux(const_iterator __position, value_type &&__v) {
            return this->_M_insert_rval(__position, std::move(__v));
        }
        constexpr size_type _M_check_len(size_type __n, const char *__s) const {
            if (this->max_size() - this->size() < __n)
                __throw_length_error((__s));
            const size_type __len = this->size() + (std::max)(this->size(), __n);
            return (__len < this->size() || __len > this->max_size()) ? this->max_size() : __len;
        }
        static constexpr size_type _S_check_init_len(size_type __n, const allocator_type &__a) {
            if (__n > _S_max_size(_Tp_alloc_type(__a)))
                __throw_length_error(("cannot create std::vector larger than max_size()"));
            return __n;
        }
        static constexpr size_type _S_max_size(const _Tp_alloc_type &__a) noexcept {
            const size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
            const size_t __allocmax = _Alloc_traits::max_size(__a);
            return (std::min)(__diffmax, __allocmax);
        }
        constexpr void _M_erase_at_end(pointer __pos) noexcept {
            if (size_type __n = this->_M_impl._M_finish - __pos) {
                std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                this->_M_impl._M_finish = __pos;
                ;
            }
        }
        constexpr iterator _M_erase(iterator __position);
        constexpr iterator _M_erase(iterator __first, iterator __last);
    private:
        constexpr void _M_move_assign(vector<_Tp, _Alloc> &&__x, true_type) noexcept {
            vector<_Tp, _Alloc> __tmp(get_allocator());
            this->_M_impl._M_swap_data(__x._M_impl);
            __tmp._M_impl._M_swap_data(__x._M_impl);
            std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
        }
        constexpr void _M_move_assign(vector<_Tp, _Alloc> &&__x, false_type) {
            if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                _M_move_assign(std::move(__x), true_type());
            else {
                this->_M_assign_aux(std::make_move_iterator(__x.begin()), std::make_move_iterator(__x.end()), std::random_access_iterator_tag());
                __x.clear();
            }
        }
        template <typename _Up> constexpr _Up *_M_data_ptr(_Up *__ptr) const noexcept {
            return __ptr;
        }
        template <typename _Ptr> constexpr typename std::pointer_traits<_Ptr>::element_type *_M_data_ptr(_Ptr __ptr) const {
            return this->empty() ? nullptr : std::__to_address(__ptr);
        }
    };
    template<> class vector<int, std::allocator<int>> : protected _Vector_base<int, allocator<int>> {
        static_assert(is_same<typename remove_cv<int>::type, int>::value, "std::vector must have a non-const, non-volatile value_type");
        static_assert(is_same<typename allocator<int>::value_type, int>::value, "std::vector must have the same value_type as its allocator");
        typedef _Vector_base<int, allocator<int>> _Base;
        typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;
    public:
        typedef int value_type;
        typedef typename _Base::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef __gnu_cxx::__normal_iterator<pointer, vector<int, allocator<int>>> iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, vector<int, allocator<int>>> const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef std::allocator<int> allocator_type;
    private:
        static constexpr bool _S_nothrow_relocate(true_type);
        static constexpr bool _S_nothrow_relocate(false_type);
        static constexpr bool _S_use_relocate();
        static pointer _S_do_relocate(pointer __first, pointer __last, pointer __result, _Tp_alloc_type &__alloc, true_type) noexcept;
        static pointer _S_do_relocate(pointer, pointer, pointer __result, _Tp_alloc_type &, false_type) noexcept;
        static constexpr pointer _S_relocate(pointer __first, pointer __last, pointer __result, _Tp_alloc_type &__alloc) noexcept;
    protected:
        using _Base::_M_allocate;
        using _Base::_M_deallocate;
        using _Base::_M_impl;
        using _Base::_M_get_Tp_allocator;
    public:
        vector() noexcept : _Vector_base<int, allocator<int>>() = default        constexpr explicit vector(const allocator_type &__a) noexcept : _Base(__a) {
        }
        constexpr explicit vector(size_type __n, const allocator_type &__a);
        constexpr vector(size_type __n, const value_type &__value, const allocator_type &__a);
        constexpr vector(const vector<int> &__x);
        vector(vector<int> &&) noexcept : _Vector_base<int, allocator<int>>(static_cast<vector<int> &&>()) = default        constexpr vector(const vector<int> &__x, const __type_identity_t<allocator_type> &__a);
    private:
        constexpr vector(vector<int> &&__rv, const allocator_type &__m, true_type) noexcept;
        constexpr vector(vector<int> &&__rv, const allocator_type &__m, false_type);
    public:
        constexpr vector(vector<int> &&__rv, const __type_identity_t<allocator_type> &__m);
        constexpr vector(initializer_list<value_type> __l, const allocator_type &__a = allocator_type()) : _Base(__a) {
            this->_M_range_initialize(__l.begin(), __l.end(), random_access_iterator_tag());
        }
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr vector(_InputIterator __first, _InputIterator __last, const allocator_type &__a);
        constexpr ~vector<int>() noexcept {
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, this->_M_get_Tp_allocator());
            ;
        }
        constexpr vector<int> &operator=(const vector<int> &__x);
        constexpr vector<int> &operator=(vector<int> &&__x) noexcept(_Alloc_traits::_S_nothrow_move()) {
            constexpr bool __move_storage = _Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal();
            this->_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
            return *this;
        }
        constexpr vector<int> &operator=(initializer_list<value_type> __l);
        constexpr void assign(size_type __n, const value_type &__val);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr void assign(_InputIterator __first, _InputIterator __last);
        constexpr void assign(initializer_list<value_type> __l);
        using _Base::get_allocator;
        constexpr iterator begin() noexcept [[nodiscard("")]] {
            return iterator(this->_M_impl._M_start);
        }
        constexpr const_iterator begin() const noexcept [[nodiscard("")]];
        constexpr iterator end() noexcept [[nodiscard("")]] {
            return iterator(this->_M_impl._M_finish);
        }
        constexpr const_iterator end() const noexcept [[nodiscard("")]];
        constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
        constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
        constexpr const_iterator cend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        constexpr size_type size() const noexcept [[nodiscard("")]];
        constexpr size_type max_size() const noexcept [[nodiscard("")]];
        constexpr void resize(size_type __new_size);
        constexpr void resize(size_type __new_size, const value_type &__x);
        constexpr void shrink_to_fit();
        constexpr size_type capacity() const noexcept [[nodiscard("")]];
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr void reserve(size_type __n);
        constexpr reference operator[](size_type __n) noexcept [[nodiscard("")]];
        constexpr const_reference operator[](size_type __n) const noexcept [[nodiscard("")]];
    protected:
        constexpr void _M_range_check(size_type __n) const;
    public:
        constexpr reference at(size_type __n);
        constexpr const_reference at(size_type __n) const;
        constexpr reference front() noexcept [[nodiscard("")]];
        constexpr const_reference front() const noexcept [[nodiscard("")]];
        constexpr reference back() noexcept [[nodiscard("")]];
        constexpr const_reference back() const noexcept [[nodiscard("")]];
        constexpr int *data() noexcept [[nodiscard("")]];
        constexpr const int *data() const noexcept [[nodiscard("")]];
        constexpr void push_back(const value_type &__x);
        constexpr void push_back(value_type &&__x);
        template <typename ..._Args> constexpr reference emplace_back(_Args &&...__args);
        constexpr void pop_back() noexcept;
        template <typename ..._Args> constexpr iterator emplace(const_iterator __position, _Args &&...__args);
        constexpr iterator insert(const_iterator __position, const value_type &__x);
        constexpr iterator insert(const_iterator __position, value_type &&__x);
        constexpr iterator insert(const_iterator __position, initializer_list<value_type> __l);
        constexpr iterator insert(const_iterator __position, size_type __n, const value_type &__x);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
        constexpr iterator erase(const_iterator __position);
        constexpr iterator erase(const_iterator __first, const_iterator __last);
        constexpr void swap(vector<int> &__x) noexcept;
        constexpr void clear() noexcept;
    protected:
        template <typename _ForwardIterator> constexpr pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first, _ForwardIterator __last);
        template <typename _InputIterator> constexpr void _M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag);
        template<> constexpr void _M_range_initialize<const int *>(const int *__first, const int *__last, std::input_iterator_tag);
        template <typename _ForwardIterator> constexpr void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        template<> constexpr void _M_range_initialize<const int *>(const int *__first, const int *__last, std::forward_iterator_tag) {
            const size_type __n = std::distance(__first, __last);
            this->_M_impl._M_start = this->_M_allocate(_S_check_init_len(__n, this->_M_get_Tp_allocator()));
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, this->_M_get_Tp_allocator());
        }
;
        constexpr void _M_fill_initialize(size_type __n, const value_type &__value);
        constexpr void _M_default_initialize(size_type __n);
        template <typename _Integer> constexpr void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type);
        template <typename _InputIterator> constexpr void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type);
        template <typename _InputIterator> constexpr void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag);
        template <typename _ForwardIterator> constexpr void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        constexpr void _M_fill_assign(size_type __n, const value_type &__val);
        template <typename _Integer> constexpr void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, __true_type);
        template <typename _InputIterator> constexpr void _M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator __last, __false_type);
        template <typename _InputIterator> constexpr void _M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag);
        template <typename _ForwardIterator> constexpr void _M_range_insert(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        constexpr void _M_fill_insert(iterator __pos, size_type __n, const value_type &__x);
        constexpr void _M_default_append(size_type __n);
        constexpr bool _M_shrink_to_fit();
        struct _Temporary_value;
        template <typename _Arg> constexpr void _M_insert_aux(iterator __position, _Arg &&__arg);
        template <typename ..._Args> constexpr void _M_realloc_insert(iterator __position, _Args &&...__args);
        constexpr iterator _M_insert_rval(const_iterator __position, value_type &&__v);
        template <typename ..._Args> constexpr iterator _M_emplace_aux(const_iterator __position, _Args &&...__args);
        constexpr iterator _M_emplace_aux(const_iterator __position, value_type &&__v);
        constexpr size_type _M_check_len(size_type __n, const char *__s) const;
        static constexpr size_type _S_check_init_len(size_type __n, const allocator_type &__a) {
            if (__n > _S_max_size(_Tp_alloc_type(__a)))
                __throw_length_error(("cannot create std::vector larger than max_size()"));
            return __n;
        }
        static constexpr size_type _S_max_size(const _Tp_alloc_type &__a) noexcept {
            const size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(int);
            const size_t __allocmax = _Alloc_traits::max_size(__a);
            return (std::min)(__diffmax, __allocmax);
        }
        constexpr void _M_erase_at_end(pointer __pos) noexcept;
        constexpr iterator _M_erase(iterator __position);
        constexpr iterator _M_erase(iterator __first, iterator __last);
    private:
        constexpr void _M_move_assign(vector<int> &&__x, true_type) noexcept {
            vector<int> __tmp(this->get_allocator());
            this->_M_impl._M_swap_data(__x._M_impl);
            __tmp._M_impl._M_swap_data(__x._M_impl);
            std::__alloc_on_move(this->_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
        }
        constexpr void _M_move_assign(vector<int> &&__x, false_type);
        template <typename _Up> constexpr _Up *_M_data_ptr(_Up *__ptr) const noexcept;
        template <typename _Ptr> constexpr typename std::pointer_traits<_Ptr>::element_type *_M_data_ptr(_Ptr __ptr) const;
    };
    template<> class vector<Base<ChildA, ChildB, ChildC> *, std::allocator<Base<ChildA, ChildB, ChildC> *>> : protected _Vector_base<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>> {
        static_assert(is_same<typename remove_cv<Base<ChildA, ChildB, ChildC> *>::type, Base<ChildA, ChildB, ChildC> *>::value, "std::vector must have a non-const, non-volatile value_type");
        static_assert(is_same<typename allocator<Base<ChildA, ChildB, ChildC> *>::value_type, Base<ChildA, ChildB, ChildC> *>::value, "std::vector must have the same value_type as its allocator");
        typedef _Vector_base<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>> _Base;
        typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;
    public:
        typedef Base<ChildA, ChildB, ChildC> *value_type;
        typedef typename _Base::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef __gnu_cxx::__normal_iterator<pointer, vector<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>>> iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, vector<Base<ChildA, ChildB, ChildC> *, allocator<Base<ChildA, ChildB, ChildC> *>>> const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef std::allocator<Base<ChildA, ChildB, ChildC> *> allocator_type;
    private:
        static constexpr bool _S_nothrow_relocate(true_type);
        static constexpr bool _S_nothrow_relocate(false_type);
        static constexpr bool _S_use_relocate();
        static pointer _S_do_relocate(pointer __first, pointer __last, pointer __result, _Tp_alloc_type &__alloc, true_type) noexcept;
        static pointer _S_do_relocate(pointer, pointer, pointer __result, _Tp_alloc_type &, false_type) noexcept;
        static constexpr pointer _S_relocate(pointer __first, pointer __last, pointer __result, _Tp_alloc_type &__alloc) noexcept;
    protected:
        using _Base::_M_allocate;
        using _Base::_M_deallocate;
        using _Base::_M_impl;
        using _Base::_M_get_Tp_allocator;
    public:
        vector() = default
        constexpr explicit vector(const allocator_type &__a) noexcept;
        constexpr explicit vector(size_type __n, const allocator_type &__a);
        constexpr vector(size_type __n, const value_type &__value, const allocator_type &__a);
        constexpr vector(const vector<Base<ChildA, ChildB, ChildC> *> &__x);
        vector(vector<Base<ChildA, ChildB, ChildC> *> &&) noexcept = default
        constexpr vector(const vector<Base<ChildA, ChildB, ChildC> *> &__x, const __type_identity_t<allocator_type> &__a);
    private:
        constexpr vector(vector<Base<ChildA, ChildB, ChildC> *> &&__rv, const allocator_type &__m, true_type) noexcept;
        constexpr vector(vector<Base<ChildA, ChildB, ChildC> *> &&__rv, const allocator_type &__m, false_type);
    public:
        constexpr vector(vector<Base<ChildA, ChildB, ChildC> *> &&__rv, const __type_identity_t<allocator_type> &__m);
        constexpr vector(initializer_list<value_type> __l, const allocator_type &__a = allocator_type()) : _Base(__a) {
            this->_M_range_initialize(__l.begin(), __l.end(), random_access_iterator_tag());
        }
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr vector(_InputIterator __first, _InputIterator __last, const allocator_type &__a);
        constexpr ~vector<Base<ChildA, ChildB, ChildC> *>() noexcept {
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, this->_M_get_Tp_allocator());
            ;
        }
        constexpr vector<Base<ChildA, ChildB, ChildC> *> &operator=(const vector<Base<ChildA, ChildB, ChildC> *> &__x);
        constexpr vector<Base<ChildA, ChildB, ChildC> *> &operator=(vector<Base<ChildA, ChildB, ChildC> *> &&__x);
        constexpr vector<Base<ChildA, ChildB, ChildC> *> &operator=(initializer_list<value_type> __l);
        constexpr void assign(size_type __n, const value_type &__val);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr void assign(_InputIterator __first, _InputIterator __last);
        constexpr void assign(initializer_list<value_type> __l);
        using _Base::get_allocator;
        constexpr iterator begin() noexcept [[nodiscard("")]] {
            return iterator(this->_M_impl._M_start);
        }
        constexpr const_iterator begin() const noexcept [[nodiscard("")]];
        constexpr iterator end() noexcept [[nodiscard("")]] {
            return iterator(this->_M_impl._M_finish);
        }
        constexpr const_iterator end() const noexcept [[nodiscard("")]];
        constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]];
        constexpr reverse_iterator rend() noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]];
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]];
        constexpr const_iterator cend() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]];
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]];
        constexpr size_type size() const noexcept [[nodiscard("")]] {
            return size_type(this->_M_impl._M_finish - this->_M_impl._M_start);
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]];
        constexpr void resize(size_type __new_size);
        constexpr void resize(size_type __new_size, const value_type &__x);
        constexpr void shrink_to_fit();
        constexpr size_type capacity() const noexcept [[nodiscard("")]];
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr void reserve(size_type __n);
        constexpr reference operator[](size_type __n) noexcept [[nodiscard("")]] {
            ;
            return *(this->_M_impl._M_start + __n);
        }
        constexpr const_reference operator[](size_type __n) const noexcept [[nodiscard("")]];
    protected:
        constexpr void _M_range_check(size_type __n) const;
    public:
        constexpr reference at(size_type __n);
        constexpr const_reference at(size_type __n) const;
        constexpr reference front() noexcept [[nodiscard("")]];
        constexpr const_reference front() const noexcept [[nodiscard("")]];
        constexpr reference back() noexcept [[nodiscard("")]];
        constexpr const_reference back() const noexcept [[nodiscard("")]];
        constexpr Base<ChildA, ChildB, ChildC> **data() noexcept [[nodiscard("")]];
        constexpr Base<ChildA, ChildB, ChildC> *const *data() const noexcept [[nodiscard("")]];
        constexpr void push_back(const value_type &__x);
        constexpr void push_back(value_type &&__x);
        template <typename ..._Args> constexpr reference emplace_back(_Args &&...__args);
        constexpr void pop_back() noexcept;
        template <typename ..._Args> constexpr iterator emplace(const_iterator __position, _Args &&...__args);
        constexpr iterator insert(const_iterator __position, const value_type &__x);
        constexpr iterator insert(const_iterator __position, value_type &&__x);
        constexpr iterator insert(const_iterator __position, initializer_list<value_type> __l);
        constexpr iterator insert(const_iterator __position, size_type __n, const value_type &__x);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
        constexpr iterator erase(const_iterator __position);
        constexpr iterator erase(const_iterator __first, const_iterator __last);
        constexpr void swap(vector<Base<ChildA, ChildB, ChildC> *> &__x) noexcept;
        constexpr void clear() noexcept;
    protected:
        template <typename _ForwardIterator> constexpr pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first, _ForwardIterator __last);
        template <typename _InputIterator> constexpr void _M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag);
        template<> constexpr void _M_range_initialize<Base<ChildA, ChildB, ChildC> *const *>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, std::input_iterator_tag);
        template <typename _ForwardIterator> constexpr void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        template<> constexpr void _M_range_initialize<Base<ChildA, ChildB, ChildC> *const *>(Base<ChildA, ChildB, ChildC> *const *__first, Base<ChildA, ChildB, ChildC> *const *__last, std::forward_iterator_tag) {
            const size_type __n = std::distance(__first, __last);
            this->_M_impl._M_start = this->_M_allocate(_S_check_init_len(__n, this->_M_get_Tp_allocator()));
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, this->_M_get_Tp_allocator());
        }
;
        constexpr void _M_fill_initialize(size_type __n, const value_type &__value);
        constexpr void _M_default_initialize(size_type __n);
        template <typename _Integer> constexpr void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type);
        template <typename _InputIterator> constexpr void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type);
        template <typename _InputIterator> constexpr void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag);
        template <typename _ForwardIterator> constexpr void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        constexpr void _M_fill_assign(size_type __n, const value_type &__val);
        template <typename _Integer> constexpr void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, __true_type);
        template <typename _InputIterator> constexpr void _M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator __last, __false_type);
        template <typename _InputIterator> constexpr void _M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag);
        template <typename _ForwardIterator> constexpr void _M_range_insert(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        constexpr void _M_fill_insert(iterator __pos, size_type __n, const value_type &__x);
        constexpr void _M_default_append(size_type __n);
        constexpr bool _M_shrink_to_fit();
        struct _Temporary_value;
        template <typename _Arg> constexpr void _M_insert_aux(iterator __position, _Arg &&__arg);
        template <typename ..._Args> constexpr void _M_realloc_insert(iterator __position, _Args &&...__args);
        constexpr iterator _M_insert_rval(const_iterator __position, value_type &&__v);
        template <typename ..._Args> constexpr iterator _M_emplace_aux(const_iterator __position, _Args &&...__args);
        constexpr iterator _M_emplace_aux(const_iterator __position, value_type &&__v);
        constexpr size_type _M_check_len(size_type __n, const char *__s) const;
        static constexpr size_type _S_check_init_len(size_type __n, const allocator_type &__a) {
            if (__n > _S_max_size(_Tp_alloc_type(__a)))
                __throw_length_error(("cannot create std::vector larger than max_size()"));
            return __n;
        }
        static constexpr size_type _S_max_size(const _Tp_alloc_type &__a) noexcept {
            const size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(Base<ChildA, ChildB, ChildC> *);
            const size_t __allocmax = _Alloc_traits::max_size(__a);
            return (std::min)(__diffmax, __allocmax);
        }
        constexpr void _M_erase_at_end(pointer __pos) noexcept;
        constexpr iterator _M_erase(iterator __position);
        constexpr iterator _M_erase(iterator __first, iterator __last);
    private:
        constexpr void _M_move_assign(vector<Base<ChildA, ChildB, ChildC> *> &&__x, true_type) noexcept;
        constexpr void _M_move_assign(vector<Base<ChildA, ChildB, ChildC> *> &&__x, false_type);
        template <typename _Up> constexpr _Up *_M_data_ptr(_Up *__ptr) const noexcept;
        template <typename _Ptr> constexpr typename std::pointer_traits<_Ptr>::element_type *_M_data_ptr(_Ptr __ptr) const;
    };
    template <typename _InputIterator, typename _ValT = typename iterator_traits<_InputIterator>::value_type, typename _Allocator = allocator<_ValT>, typename = _RequireInputIter<_InputIterator>, typename = _RequireAllocator<_Allocator>> vector(_InputIterator, _InputIterator, _Allocator = _Allocator()) -> vector<_ValT, _Allocator>;
    template <typename _Tp, typename _Alloc> inline constexpr bool operator==(const vector<_Tp, _Alloc> &__x, const vector<_Tp, _Alloc> &__y) {
        return (__x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin()));
    }
    template <typename _Tp, typename _Alloc> inline constexpr __detail::__synth3way_t<_Tp> operator<=>(const vector<_Tp, _Alloc> &__x, const vector<_Tp, _Alloc> &__y) {
        return std::lexicographical_compare_three_way(__x.begin(), __x.end(), __y.begin(), __y.end(), __detail::__synth3way);
    }
    template <typename _Tp, typename _Alloc> inline constexpr void swap(vector<_Tp, _Alloc> &__x, vector<_Tp, _Alloc> &__y) noexcept(noexcept(__x.swap(__y))) {
        __x.swap(__y);
    }
    namespace __detail {
        namespace __variant {
            template <typename> struct _Never_valueless_alt;
            template <typename _Tp, typename _Alloc> struct _Never_valueless_alt<std::vector<_Tp, _Alloc>> : std::is_nothrow_move_assignable<std::vector<_Tp, _Alloc>> {
            };
        }
    }
}
namespace std {
    typedef unsigned long _Bit_type;
    enum {
        _S_word_bit = int(8 * sizeof(_Bit_type))
    };
    constexpr void __fill_bvector_n(_Bit_type *, size_t, bool) noexcept __attribute__((nonnull));
    struct _Bit_reference {
        _Bit_type *_M_p;
        _Bit_type _M_mask;
        constexpr _Bit_reference(_Bit_type *__x, _Bit_type __y) : _M_p(__x), _M_mask(__y) {
        }
        constexpr _Bit_reference() noexcept : _M_p(0), _M_mask(0) {
        }
        _Bit_reference(const _Bit_reference &) = default
        constexpr operator bool() const noexcept [[nodiscard("")]] {
            return !!(*this->_M_p & this->_M_mask);
        }
        constexpr _Bit_reference &operator=(bool __x) noexcept {
            if (__x)
                *this->_M_p |= this->_M_mask;
            else
                *this->_M_p &= ~this->_M_mask;
            return *this;
        }
        constexpr _Bit_reference &operator=(const _Bit_reference &__x) noexcept {
            return *this = bool(__x);
        }
        constexpr bool operator==(const _Bit_reference &__x) const [[nodiscard("")]] {
            return bool(*this) == bool(__x);
        }
        constexpr bool operator<(const _Bit_reference &__x) const [[nodiscard("")]] {
            return !bool(*this) && bool(__x);
        }
        constexpr void flip() noexcept {
            *this->_M_p ^= this->_M_mask;
        }
        friend constexpr void swap(_Bit_reference __x, _Bit_reference __y) noexcept {
            bool __tmp = __x;
            __x = __y;
            __y = __tmp;
        }
;
        friend constexpr void swap(_Bit_reference __x, bool &__y) noexcept {
            bool __tmp = __x;
            __x = __y;
            __y = __tmp;
        }
;
        friend constexpr void swap(bool &__x, _Bit_reference __y) noexcept {
            bool __tmp = __x;
            __x = __y;
            __y = __tmp;
        }
;
    };
    struct _Bit_iterator_base : public std::iterator<std::random_access_iterator_tag, bool> {
        _Bit_type *_M_p;
        unsigned int _M_offset;
        constexpr _Bit_iterator_base(_Bit_type *__x, unsigned int __y) : std::iterator<std::random_access_iterator_tag, bool>(), _M_p(__x), _M_offset(__y) {
        }
        constexpr void _M_bump_up() {
            if (this->_M_offset++ == int(_S_word_bit) - 1) {
                this->_M_offset = 0;
                ++this->_M_p;
            }
        }
        constexpr void _M_bump_down() {
            if (this->_M_offset-- == 0) {
                this->_M_offset = int(_S_word_bit) - 1;
                --this->_M_p;
            }
        }
        constexpr void _M_incr(ptrdiff_t __i) {
            difference_type __n = __i + this->_M_offset;
            this->_M_p += __n / int(_S_word_bit);
            __n = __n % int(_S_word_bit);
            if (__n < 0) {
                __n += int(_S_word_bit);
                --this->_M_p;
            }
            this->_M_offset = static_cast<unsigned int>(__n);
        }
        friend constexpr bool operator==(const _Bit_iterator_base &__x, const _Bit_iterator_base &__y) [[nodiscard("")]] {
            return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset;
        }
;
        friend constexpr strong_ordering operator<=>(const _Bit_iterator_base &__x, const _Bit_iterator_base &__y) noexcept [[nodiscard("")]] {
            if (const auto __cmp = __x._M_p <=> __y._M_p; __cmp != 0)
                return __cmp;
            return __x._M_offset <=> __y._M_offset;
        }
;
        friend constexpr ptrdiff_t operator-(const _Bit_iterator_base &__x, const _Bit_iterator_base &__y) {
            return (int(_S_word_bit) * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset);
        }
;
    };
    struct _Bit_iterator : public _Bit_iterator_base {
        typedef _Bit_reference reference;
        typedef void pointer;
        typedef _Bit_iterator iterator;
        constexpr _Bit_iterator() : _Bit_iterator_base(0, 0) {
        }
        constexpr _Bit_iterator(_Bit_type *__x, unsigned int __y) : _Bit_iterator_base(__x, __y) {
        }
        constexpr iterator _M_const_cast() const {
            return *this;
        }
        constexpr reference operator*() const [[nodiscard("")]] {
            return reference(this->_M_p, 1UL << this->_M_offset);
        }
        constexpr iterator &operator++() {
            this->_M_bump_up();
            return *this;
        }
        constexpr iterator operator++(int) {
            iterator __tmp = *this;
            this->_M_bump_up();
            return __tmp;
        }
        constexpr iterator &operator--() {
            this->_M_bump_down();
            return *this;
        }
        constexpr iterator operator--(int) {
            iterator __tmp = *this;
            this->_M_bump_down();
            return __tmp;
        }
        constexpr iterator &operator+=(difference_type __i) {
            this->_M_incr(__i);
            return *this;
        }
        constexpr iterator &operator-=(difference_type __i) {
            *this += -__i;
            return *this;
        }
        constexpr reference operator[](difference_type __i) const [[nodiscard("")]] {
            return * (*this + __i);
        }
        friend constexpr iterator operator+(const iterator &__x, difference_type __n) [[nodiscard("")]] {
            iterator __tmp = __x;
            __tmp += __n;
            return __tmp;
        }
;
        friend constexpr iterator operator+(difference_type __n, const iterator &__x) [[nodiscard("")]] {
            return __x + __n;
        }
;
        friend constexpr iterator operator-(const iterator &__x, difference_type __n) [[nodiscard("")]] {
            iterator __tmp = __x;
            __tmp -= __n;
            return __tmp;
        }
;
    };
    struct _Bit_const_iterator : public _Bit_iterator_base {
        typedef bool reference;
        typedef bool const_reference;
        typedef void pointer;
        typedef _Bit_const_iterator const_iterator;
        constexpr _Bit_const_iterator() : _Bit_iterator_base(0, 0) {
        }
        constexpr _Bit_const_iterator(_Bit_type *__x, unsigned int __y) : _Bit_iterator_base(__x, __y) {
        }
        constexpr _Bit_const_iterator(const _Bit_iterator &__x) : _Bit_iterator_base(__x._M_p, __x._M_offset) {
        }
        constexpr _Bit_iterator _M_const_cast() const {
            return _Bit_iterator(this->_M_p, this->_M_offset);
        }
        constexpr const_reference operator*() const [[nodiscard("")]] {
            return _Bit_reference(this->_M_p, 1UL << this->_M_offset);
        }
        constexpr const_iterator &operator++() {
            this->_M_bump_up();
            return *this;
        }
        constexpr const_iterator operator++(int) {
            const_iterator __tmp = *this;
            this->_M_bump_up();
            return __tmp;
        }
        constexpr const_iterator &operator--() {
            this->_M_bump_down();
            return *this;
        }
        constexpr const_iterator operator--(int) {
            const_iterator __tmp = *this;
            this->_M_bump_down();
            return __tmp;
        }
        constexpr const_iterator &operator+=(difference_type __i) {
            this->_M_incr(__i);
            return *this;
        }
        constexpr const_iterator &operator-=(difference_type __i) {
            *this += -__i;
            return *this;
        }
        constexpr const_reference operator[](difference_type __i) const [[nodiscard("")]] {
            return * (*this + __i);
        }
        friend constexpr const_iterator operator+(const const_iterator &__x, difference_type __n) [[nodiscard("")]] {
            const_iterator __tmp = __x;
            __tmp += __n;
            return __tmp;
        }
;
        friend constexpr const_iterator operator-(const const_iterator &__x, difference_type __n) [[nodiscard("")]] {
            const_iterator __tmp = __x;
            __tmp -= __n;
            return __tmp;
        }
;
        friend constexpr const_iterator operator+(difference_type __n, const const_iterator &__x) [[nodiscard("")]] {
            return __x + __n;
        }
;
    };
    template <typename _Alloc> struct _Bvector_base {
        typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_Bit_type>::other _Bit_alloc_type;
        typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type> _Bit_alloc_traits;
        typedef typename _Bit_alloc_traits::pointer _Bit_pointer;
        struct _Bvector_impl_data {
            _Bit_iterator _M_start;
            _Bit_iterator _M_finish;
            _Bit_pointer _M_end_of_storage;
            constexpr _Bvector_impl_data() noexcept : _M_start(), _M_finish(), _M_end_of_storage() {
            }
            _Bvector_impl_data(const _Bvector_impl_data &) = default
            _Bvector_impl_data &operator=(const _Bvector_impl_data &) = default
            constexpr _Bvector_impl_data(_Bvector_impl_data &&__x) noexcept : _Bvector_impl_data(__x) {
                __x._M_reset();
            }
            constexpr void _M_move_data(_Bvector_impl_data &&__x) noexcept {
                *this = __x;
                __x._M_reset();
            }
            constexpr void _M_reset() noexcept {
                *this = _Bvector_impl_data();
            }
            constexpr void _M_swap_data(_Bvector_impl_data &__x) noexcept {
                std::swap(*this, __x);
            }
        };
        struct _Bvector_impl : public _Bit_alloc_type, public _Bvector_impl_data {
            constexpr _Bvector_impl() noexcept(is_nothrow_default_constructible<_Bit_alloc_type>::value) : _Bit_alloc_type() {
            }
            constexpr _Bvector_impl(const _Bit_alloc_type &__a) noexcept : _Bit_alloc_type(__a) {
            }
            constexpr _Bvector_impl(_Bvector_impl &&__x) noexcept : _Bit_alloc_type(std::move(__x)), _Bvector_impl_data(std::move(__x)) {
            }
            constexpr _Bvector_impl(_Bit_alloc_type &&__a, _Bvector_impl &&__x) noexcept : _Bit_alloc_type(std::move(__a)), _Bvector_impl_data(std::move(__x)) {
            }
            constexpr _Bit_type *_M_end_addr() const noexcept {
                if (this->_M_end_of_storage)
                    return std::__addressof(this->_M_end_of_storage[-1]) + 1;
                return 0;
            }
        };
    public:
        typedef _Alloc allocator_type;
        constexpr _Bit_alloc_type &_M_get_Bit_allocator() noexcept {
            return this->_M_impl;
        }
        constexpr const _Bit_alloc_type &_M_get_Bit_allocator() const noexcept {
            return this->_M_impl;
        }
        constexpr allocator_type get_allocator() const noexcept {
            return allocator_type(_M_get_Bit_allocator());
        }
        _Bvector_base<_Alloc>() = default
        constexpr _Bvector_base<_Alloc>(const allocator_type &__a) : _M_impl(__a) {
        }
        _Bvector_base<_Alloc>(_Bvector_base<_Alloc> &&) = default
        constexpr _Bvector_base<_Alloc>(_Bvector_base<_Alloc> &&__x, const allocator_type &__a) noexcept : _M_impl(_Bit_alloc_type(__a), std::move(__x._M_impl)) {
        }
        constexpr ~_Bvector_base<_Alloc>() {
            this->_M_deallocate();
        }
    protected:
        _Bvector_impl _M_impl;
        constexpr _Bit_pointer _M_allocate(size_t __n) {
            _Bit_pointer __p = _Bit_alloc_traits::allocate(this->_M_impl, _S_nword(__n));
            if (std::is_constant_evaluated()) {
                __n = _S_nword(__n);
                for (size_t __i = 0; __i < __n; ++__i)
                    __p[__i] = 0UL;
            }
            return __p;
        }
        constexpr void _M_deallocate() {
            if (this->_M_impl._M_start._M_p) {
                const size_t __n = this->_M_impl._M_end_addr() - this->_M_impl._M_start._M_p;
                _Bit_alloc_traits::deallocate(this->_M_impl, this->_M_impl._M_end_of_storage - __n, __n);
                this->_M_impl._M_reset();
            }
        }
        constexpr void _M_move_data(_Bvector_base<_Alloc> &&__x) noexcept {
            this->_M_impl._M_move_data(std::move(__x._M_impl));
        }
        static constexpr size_t _S_nword(size_t __n) {
            return (__n + int(_S_word_bit) - 1) / int(_S_word_bit);
        }
    };
    template <typename _Alloc> class vector<bool, _Alloc> : protected _Bvector_base<_Alloc> {
        typedef _Bvector_base<_Alloc> _Base;
        typedef typename _Base::_Bit_pointer _Bit_pointer;
        typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;
        friend  struct std::hash<vector<bool, type-parameter-0-0>>;
    public:
        typedef bool value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef _Bit_reference reference;
        typedef bool const_reference;
        typedef _Bit_reference *pointer;
        typedef const bool *const_pointer;
        typedef _Bit_iterator iterator;
        typedef _Bit_const_iterator const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef _Alloc allocator_type;
        constexpr allocator_type get_allocator() const {
            return _Base::get_allocator();
        }
    protected:
        using _Base::_M_allocate;
        using _Base::_M_deallocate;
        using _Base::_S_nword;
        using _Base::_M_get_Bit_allocator;
    public:
        vector<bool, type-parameter-0-0>() = default
        constexpr explicit vector<bool, type-parameter-0-0>(const allocator_type &__a) : _Base(__a) {
        }
        constexpr explicit vector<bool, type-parameter-0-0>(size_type __n, const allocator_type &__a = allocator_type()) : vector<bool, type-parameter-0-0>(__n, false, __a) {
        }
        constexpr vector<bool, type-parameter-0-0>(size_type __n, const bool &__value, const allocator_type &__a = allocator_type()) : _Base(__a) {
            this->_M_initialize(__n);
            this->_M_initialize_value(__value);
        }
        constexpr vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &__x) : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator())) {
            const_iterator __xbegin = __x.begin(), __xend = __x.end();
            this->_M_initialize(__x.size());
            this->_M_copy_aligned(__xbegin, __xend, begin());
        }
        vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&) = default
    private:
        constexpr vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&__x, const allocator_type &__a, true_type) noexcept : _Base(std::move(__x), __a) {
        }
        constexpr vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&__x, const allocator_type &__a, false_type) : _Base(__a) {
            if (__x.get_allocator() == __a)
                this->_M_move_data(std::move(__x));
            else {
                this->_M_initialize(__x.size());
                this->_M_copy_aligned(__x.begin(), __x.end(), begin());
                __x.clear();
            }
        }
    public:
        constexpr vector<bool, type-parameter-0-0>(vector<bool, type-parameter-0-0> &&__x, const __type_identity_t<allocator_type> &__a) noexcept(_Bit_alloc_traits::_S_always_equal()) : vector<bool, type-parameter-0-0>(std::move(__x), __a, typename _Bit_alloc_traits::is_always_equal{}) {
        }
        constexpr vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &__x, const __type_identity_t<allocator_type> &__a) : _Base(__a) {
            this->_M_initialize(__x.size());
            this->_M_copy_aligned(__x.begin(), __x.end(), begin());
        }
        constexpr vector<bool, type-parameter-0-0>(initializer_list<bool> __l, const allocator_type &__a = allocator_type()) : _Base(__a) {
            _M_initialize_range(__l.begin(), __l.end(), random_access_iterator_tag());
        }
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr vector<bool, type-parameter-0-0>(_InputIterator __first, _InputIterator __last, const allocator_type &__a = allocator_type()) : _Base(__a) {
            _M_initialize_range(__first, __last, std::__iterator_category(__first));
        }
        constexpr ~vector<bool, type-parameter-0-0>() noexcept {
        }
        constexpr vector<bool, type-parameter-0-0> &operator=(const vector<bool, type-parameter-0-0> &__x) {
            if (& __x == this)
                return *this;
            if (_Bit_alloc_traits::_S_propagate_on_copy_assign()) {
                if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator()) {
                    this->_M_deallocate();
                    std::__alloc_on_copy(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
                    this->_M_initialize(__x.size());
                } else
                    std::__alloc_on_copy(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
            }
            if (__x.size() > this->capacity()) {
                this->_M_deallocate();
                this->_M_initialize(__x.size());
            }
            this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
            return *this;
        }
        constexpr vector<bool, type-parameter-0-0> &operator=(vector<bool, type-parameter-0-0> &&__x) noexcept(_Bit_alloc_traits::_S_nothrow_move()) {
            if (_Bit_alloc_traits::_S_propagate_on_move_assign() || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator()) {
                this->_M_deallocate();
                this->_M_move_data(std::move(__x));
                std::__alloc_on_move(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
            } else {
                if (__x.size() > this->capacity()) {
                    this->_M_deallocate();
                    this->_M_initialize(__x.size());
                }
                this->_M_impl._M_finish = this->_M_copy_aligned(__x.begin(), __x.end(), begin());
                __x.clear();
            }
            return *this;
        }
        constexpr vector<bool, type-parameter-0-0> &operator=(initializer_list<bool> __l) {
            this->assign(__l.begin(), __l.end());
            return *this;
        }
        constexpr void assign(size_type __n, const bool &__x) {
            this->_M_fill_assign(__n, __x);
        }
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr void assign(_InputIterator __first, _InputIterator __last) {
            _M_assign_aux(__first, __last, std::__iterator_category(__first));
        }
        constexpr void assign(initializer_list<bool> __l) {
            _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag());
        }
        constexpr iterator begin() noexcept [[nodiscard("")]] {
            return iterator(this->_M_impl._M_start._M_p, 0);
        }
        constexpr const_iterator begin() const noexcept [[nodiscard("")]] {
            return const_iterator(this->_M_impl._M_start._M_p, 0);
        }
        constexpr iterator end() noexcept [[nodiscard("")]] {
            return this->_M_impl._M_finish;
        }
        constexpr const_iterator end() const noexcept [[nodiscard("")]] {
            return this->_M_impl._M_finish;
        }
        constexpr reverse_iterator rbegin() noexcept [[nodiscard("")]] {
            return reverse_iterator(end());
        }
        constexpr const_reverse_iterator rbegin() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(end());
        }
        constexpr reverse_iterator rend() noexcept [[nodiscard("")]] {
            return reverse_iterator(begin());
        }
        constexpr const_reverse_iterator rend() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(begin());
        }
        constexpr const_iterator cbegin() const noexcept [[nodiscard("")]] {
            return const_iterator(this->_M_impl._M_start._M_p, 0);
        }
        constexpr const_iterator cend() const noexcept [[nodiscard("")]] {
            return this->_M_impl._M_finish;
        }
        constexpr const_reverse_iterator crbegin() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(end());
        }
        constexpr const_reverse_iterator crend() const noexcept [[nodiscard("")]] {
            return const_reverse_iterator(begin());
        }
        constexpr size_type size() const noexcept [[nodiscard("")]] {
            return size_type(end() - begin());
        }
        constexpr size_type max_size() const noexcept [[nodiscard("")]] {
            const size_type __isize = __gnu_cxx::__numeric_traits<difference_type>::__max - int(_S_word_bit) + 1;
            const size_type __asize = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
            return (__asize <= __isize / int(_S_word_bit) ? __asize * int(_S_word_bit) : __isize);
        }
        constexpr size_type capacity() const noexcept [[nodiscard("")]] {
            return size_type(const_iterator(this->_M_impl._M_end_addr(), 0) - begin());
        }
        constexpr bool empty() const noexcept [[nodiscard("")]] {
            return begin() == end();
        }
        constexpr reference operator[](size_type __n) [[nodiscard("")]] {
            return begin()[__n];
        }
        constexpr const_reference operator[](size_type __n) const [[nodiscard("")]] {
            return begin()[__n];
        }
    protected:
        constexpr void _M_range_check(size_type __n) const {
            if (__n >= this->size())
                __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
        }
    public:
        constexpr reference at(size_type __n) {
            this->_M_range_check(__n);
            return (*this)[__n];
        }
        constexpr const_reference at(size_type __n) const {
            this->_M_range_check(__n);
            return (*this)[__n];
        }
        constexpr void reserve(size_type __n) {
            if (__n > this->max_size())
                __throw_length_error(("vector::reserve"));
            if (this->capacity() < __n)
                this->_M_reallocate(__n);
        }
        constexpr reference front() [[nodiscard("")]] {
            return *begin();
        }
        constexpr const_reference front() const [[nodiscard("")]] {
            return *begin();
        }
        constexpr reference back() [[nodiscard("")]] {
            return *(end() - 1);
        }
        constexpr const_reference back() const [[nodiscard("")]] {
            return *(end() - 1);
        }
        constexpr void push_back(bool __x) {
            if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
                *this->_M_impl._M_finish++ = __x;
            else
                this->_M_insert_aux(end(), __x);
        }
        constexpr void swap(vector<bool, type-parameter-0-0> &__x) noexcept {
            do {
                if (std::__is_constant_evaluated() && !bool(_Bit_alloc_traits::propagate_on_container_swap::value || _M_get_Bit_allocator() == __x._M_get_Bit_allocator()))
                    __builtin_unreachable();
            } while (false);
            this->_M_impl._M_swap_data(__x._M_impl);
            _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
        }
        static constexpr void swap(reference __x, reference __y) noexcept {
            bool __tmp = __x;
            __x = __y;
            __y = __tmp;
        }
        constexpr iterator insert(const_iterator __position, const bool &__x) {
            const difference_type __n = __position - begin();
            if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr() && __position == end())
                *this->_M_impl._M_finish++ = __x;
            else
                this->_M_insert_aux(__position._M_const_cast(), __x);
            return begin() + __n;
        }
        iterator insert(const_iterator __position) __attribute__((deprecated("use 'insert(position, false)' instead"))) {
            return this->insert(__position._M_const_cast(), false);
        }
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr iterator insert(const_iterator __position, _InputIterator __first, _InputIterator __last) {
            difference_type __offset = __position - this->cbegin();
            _M_insert_range(__position._M_const_cast(), __first, __last, std::__iterator_category(__first));
            return begin() + __offset;
        }
        constexpr iterator insert(const_iterator __position, size_type __n, const bool &__x) {
            difference_type __offset = __position - this->cbegin();
            this->_M_fill_insert(__position._M_const_cast(), __n, __x);
            return begin() + __offset;
        }
        constexpr iterator insert(const_iterator __p, initializer_list<bool> __l) {
            return this->insert(__p, __l.begin(), __l.end());
        }
        constexpr void pop_back() {
            --this->_M_impl._M_finish;
        }
        constexpr iterator erase(const_iterator __position) {
            return _M_erase(__position._M_const_cast());
        }
        constexpr iterator erase(const_iterator __first, const_iterator __last) {
            return _M_erase(__first._M_const_cast(), __last._M_const_cast());
        }
        constexpr void resize(size_type __new_size, bool __x = bool()) {
            if (__new_size < this->size())
                this->_M_erase_at_end(begin() + difference_type(__new_size));
            else
                insert(end(), __new_size - this->size(), __x);
        }
        constexpr void shrink_to_fit() {
            this->_M_shrink_to_fit();
        }
        constexpr void flip() noexcept {
            _Bit_type *const __end = this->_M_impl._M_end_addr();
            for (_Bit_type *__p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
                *__p = ~*__p;
        }
        constexpr void clear() noexcept {
            this->_M_erase_at_end(begin());
        }
        template <typename ..._Args> constexpr reference emplace_back(_Args &&...__args) {
            this->push_back(bool(__args...));
            return back();
        }
        template <typename ..._Args> constexpr iterator emplace(const_iterator __pos, _Args &&...__args) {
            return insert(__pos, bool(__args...));
        }
    protected:
        constexpr iterator _M_copy_aligned(const_iterator __first, const_iterator __last, iterator __result) {
            _Bit_type *__q = std::copy(__first._M_p, __last._M_p, __result._M_p);
            return std::copy(const_iterator(__last._M_p, 0), __last, iterator(__q, 0));
        }
        constexpr void _M_initialize(size_type __n) {
            if (__n) {
                _Bit_pointer __q = this->_M_allocate(__n);
                this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                iterator __start = iterator(std::__addressof(*__q), 0);
                this->_M_impl._M_start = __start;
                this->_M_impl._M_finish = __start + difference_type(__n);
            }
        }
        constexpr void _M_initialize_value(bool __x) noexcept {
            if (_Bit_type *__p = this->_M_impl._M_start._M_p)
                __fill_bvector_n(__p, this->_M_impl._M_end_addr() - __p, __x);
        }
        constexpr void _M_reallocate(size_type __n);
        constexpr bool _M_shrink_to_fit();
        template <typename _InputIterator> constexpr void _M_initialize_range(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
            for (; __first != __last; ++__first)
                this->push_back(*__first);
        }
        template <typename _ForwardIterator> constexpr void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) {
            const size_type __n = std::distance(__first, __last);
            this->_M_initialize(__n);
            std::copy(__first, __last, begin());
        }
        constexpr void _M_fill_assign(size_t __n, bool __x) {
            if (__n > this->size()) {
                this->_M_initialize_value(__x);
                insert(end(), __n - this->size(), __x);
            } else {
                this->_M_erase_at_end(begin() + __n);
                this->_M_initialize_value(__x);
            }
        }
        template <typename _InputIterator> constexpr void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
            iterator __cur = begin();
            for (; __first != __last && __cur != end(); ++ __cur , (void)++__first)
                * __cur = *__first;
            if (__first == __last)
                this->_M_erase_at_end(__cur);
            else
                insert(end(), __first, __last);
        }
        template <typename _ForwardIterator> constexpr void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) {
            const size_type __len = std::distance(__first, __last);
            if (__len < this->size())
                this->_M_erase_at_end(std::copy(__first, __last, begin()));
            else {
                _ForwardIterator __mid = __first;
                std::advance(__mid, this->size());
                std::copy(__first, __mid, begin());
                insert(end(), __mid, __last);
            }
        }
        constexpr void _M_fill_insert(iterator __position, size_type __n, bool __x);
        template <typename _InputIterator> constexpr void _M_insert_range(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
            for (; __first != __last; ++__first) {
                __pos = insert(__pos, *__first);
                ++ __pos;
            }
        }
        template <typename _ForwardIterator> constexpr void _M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
        constexpr void _M_insert_aux(iterator __position, bool __x);
        constexpr size_type _M_check_len(size_type __n, const char *__s) const {
            if (this->max_size() - this->size() < __n)
                __throw_length_error((__s));
            const size_type __len = this->size() + std::max(this->size(), __n);
            return (__len < this->size() || __len > this->max_size()) ? this->max_size() : __len;
        }
        constexpr void _M_erase_at_end(iterator __pos) {
            this->_M_impl._M_finish = __pos;
        }
        constexpr iterator _M_erase(iterator __pos);
        constexpr iterator _M_erase(iterator __first, iterator __last);
    protected:
        void data() = delete
    };
    inline constexpr void __fill_bvector(_Bit_type *__v, unsigned int __first, unsigned int __last, bool __x) noexcept {
        const _Bit_type __fmask = ~0UL << __first;
        const _Bit_type __lmask = ~0UL >> (_S_word_bit - __last);
        const _Bit_type __mask = __fmask & __lmask;
        if (__x)
            *__v |= __mask;
        else
            *__v &= ~__mask;
    }
    inline constexpr void __fill_bvector_n(_Bit_type *__p, size_t __n, bool __x) noexcept __attribute__((nonnull)) {
        if (std::is_constant_evaluated()) {
            for (size_t __i = 0; __i < __n; ++__i)
                __p[__i] = __x ? ~0UL : 0UL;
            return;
        }
        __builtin_memset(__p, __x ? ~0 : 0, __n * sizeof(_Bit_type));
    }
    inline constexpr void __fill_a1(std::_Bit_iterator __first, std::_Bit_iterator __last, const bool &__x) {
        if (__first._M_p != __last._M_p) {
            _Bit_type *__first_p = __first._M_p;
            if (__first._M_offset != 0)
                __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);
            __fill_bvector_n(__first_p, __last._M_p - __first_p, __x);
            if (__last._M_offset != 0)
                __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
        } else if (__first._M_offset != __last._M_offset)
            __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
    }
    template <typename _Alloc> struct hash<std::vector<bool, _Alloc>> : public __hash_base<size_t, std::vector<bool, _Alloc>> {
        size_t operator()(const std::vector<bool, _Alloc> &) const noexcept;
    };
}
namespace std {
    template <typename _Tp, typename _Alloc> constexpr void vector<_Tp, _Alloc>::reserve(size_type __n) {
        if (__n > this->max_size())
            __throw_length_error(("vector::reserve"));
        if (this->capacity() < __n) {
            const size_type __old_size = this->size();
            pointer __tmp;
            if (_S_use_relocate()) {
                __tmp = this->_M_allocate(__n);
                _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish, __tmp, _M_get_Tp_allocator());
            } else {
                __tmp = _M_allocate_and_copy(__n, std::__make_move_if_noexcept_iterator(this->_M_impl._M_start), std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
                std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            }
            ;
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __tmp;
            this->_M_impl._M_finish = __tmp + __old_size;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
        }
    }
    template <typename _Tp, typename _Alloc> template <typename ..._Args> constexpr typename vector<_Tp, _Alloc>::reference vector<_Tp, _Alloc>::emplace_back(_Args &&...__args) {
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {
            ;
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::forward<_Args>(__args)...);
            ++this->_M_impl._M_finish;
            ;
        } else
            _M_realloc_insert(end(), std::forward<_Args>(__args)...);
        return back();
    }
    template <typename _Tp, typename _Alloc> constexpr typename vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::insert(const_iterator __position, const value_type &__x) {
        const size_type __n = __position - begin();
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {
            do {
                if (std::__is_constant_evaluated() && !bool(__position != const_iterator()))
                    __builtin_unreachable();
            } while (false);
            if (!(__position != const_iterator()))
                __builtin_unreachable();
            if (__position == end()) {
                ;
                _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
                ++this->_M_impl._M_finish;
                ;
            } else {
                const auto __pos = begin() + (__position - this->cbegin());
                _Temporary_value __x_copy(this, __x);
                _M_insert_aux(__pos, std::move(__x_copy._M_val()));
            }
        } else
            _M_realloc_insert(begin() + (__position - this->cbegin()), __x);
        return iterator(this->_M_impl._M_start + __n);
    }
    template <typename _Tp, typename _Alloc> constexpr typename vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::_M_erase(iterator __position) {
        if (__position + 1 != end())
            std::move(__position + 1, end(), __position);
        --this->_M_impl._M_finish;
        _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
        ;
        return __position;
    }
    template <typename _Tp, typename _Alloc> constexpr typename vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::_M_erase(iterator __first, iterator __last) {
        if (__first != __last) {
            if (__last != end())
                std::move(__last, end(), __first);
            this->_M_erase_at_end(__first.base() + (end() - __last));
        }
        return __first;
    }
    template <typename _Tp, typename _Alloc> constexpr vector<_Tp, _Alloc> &vector<_Tp, _Alloc>::operator=(const vector<_Tp, _Alloc> &__x) {
        if (std::__addressof(__x) != this) {
            ;
            if (_Alloc_traits::_S_propagate_on_copy_assign()) {
                if (!_Alloc_traits::_S_always_equal() && _M_get_Tp_allocator() != __x._M_get_Tp_allocator()) {
                    this->clear();
                    _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
                    this->_M_impl._M_start = nullptr;
                    this->_M_impl._M_finish = nullptr;
                    this->_M_impl._M_end_of_storage = nullptr;
                }
                std::__alloc_on_copy(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
            }
            const size_type __xlen = __x.size();
            if (__xlen > this->capacity()) {
                pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
                std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
                _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
                this->_M_impl._M_start = __tmp;
                this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
            } else if (this->size() >= __xlen) {
                std::_Destroy(std::copy(__x.begin(), __x.end(), begin()), end(), _M_get_Tp_allocator());
            } else {
                std::copy(__x._M_impl._M_start, __x._M_impl._M_start + this->size(), this->_M_impl._M_start);
                std::__uninitialized_copy_a(__x._M_impl._M_start + this->size(), __x._M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
            }
            this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
        }
        return *this;
    }
    template <typename _Tp, typename _Alloc> constexpr void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type &__val) {
        if (__n > this->capacity()) {
            vector<_Tp, _Alloc> __tmp(__n, __val, _M_get_Tp_allocator());
            __tmp._M_impl._M_swap_data(this->_M_impl);
        } else if (__n > this->size()) {
            std::fill(begin(), end(), __val);
            const size_type __add = __n - this->size();
            ;
            this->_M_impl._M_finish = std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __add, __val, _M_get_Tp_allocator());
            ;
        } else
            this->_M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }
    template <typename _Tp, typename _Alloc> template <typename _InputIterator> constexpr void vector<_Tp, _Alloc>::_M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
        pointer __cur(this->_M_impl._M_start);
        for (; __first != __last && __cur != this->_M_impl._M_finish; ++__cur , (void)++__first)
            *__cur = *__first;
        if (__first == __last)
            this->_M_erase_at_end(__cur);
        else
            _M_range_insert(end(), __first, __last, std::__iterator_category(__first));
    }
    template <typename _Tp, typename _Alloc> template <typename _ForwardIterator> constexpr void vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) {
        const size_type __len = std::distance(__first, __last);
        if (__len > this->capacity()) {
            _S_check_init_len(__len, _M_get_Tp_allocator());
            pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            ;
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __tmp;
            this->_M_impl._M_finish = this->_M_impl._M_start + __len;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
        } else if (this->size() >= __len)
            this->_M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
        else {
            _ForwardIterator __mid = __first;
            std::advance(__mid, this->size());
            std::copy(__first, __mid, this->_M_impl._M_start);
            const size_type __n = __len - this->size() __attribute__((unused));
            ;
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
            ;
        }
    }
    template <typename _Tp, typename _Alloc> constexpr auto vector<_Tp, _Alloc>::_M_insert_rval(const_iterator __position, value_type &&__v) -> iterator {
        const auto __n = __position - this->cbegin();
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
            if (__position == this->cend()) {
                ;
                _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(__v));
                ++this->_M_impl._M_finish;
                ;
            } else
                _M_insert_aux(begin() + __n, std::move(__v));
        else
            _M_realloc_insert(begin() + __n, std::move(__v));
        return iterator(this->_M_impl._M_start + __n);
    }
    template <typename _Tp, typename _Alloc> template <typename ..._Args> constexpr auto vector<_Tp, _Alloc>::_M_emplace_aux(const_iterator __position, _Args &&...__args) -> iterator {
        const auto __n = __position - this->cbegin();
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
            if (__position == this->cend()) {
                ;
                _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::forward<_Args>(__args)...);
                ++this->_M_impl._M_finish;
                ;
            } else {
                _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
                _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
            }
        else
            _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);
        return iterator(this->_M_impl._M_start + __n);
    }
    template <typename _Tp, typename _Alloc> template <typename _Arg> constexpr void vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, _Arg &&__arg) {
        ;
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
        ++this->_M_impl._M_finish;
        ;
        std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);
        *__position = std::forward<_Arg>(__arg);
    }
    template <typename _Tp, typename _Alloc> template <typename ..._Args> constexpr void vector<_Tp, _Alloc>::_M_realloc_insert(iterator __position, _Args &&...__args) {
        const size_type __len = this->_M_check_len(size_type(1), "vector::_M_realloc_insert");
        pointer __old_start = this->_M_impl._M_start;
        pointer __old_finish = this->_M_impl._M_finish;
        const size_type __elems_before = __position - begin();
        pointer __new_start(this->_M_allocate(__len));
        pointer __new_finish(__new_start);
        try {
            _Alloc_traits::construct(this->_M_impl, __new_start + __elems_before, std::forward<_Args>(__args)...);
            __new_finish = pointer();
            if (_S_use_relocate()) {
                __new_finish = _S_relocate(__old_start, __position.base(), __new_start, _M_get_Tp_allocator());
                ++__new_finish;
                __new_finish = _S_relocate(__position.base(), __old_finish, __new_finish, _M_get_Tp_allocator());
            } else {
                __new_finish = std::__uninitialized_move_if_noexcept_a(__old_start, __position.base(), __new_start, _M_get_Tp_allocator());
                ++__new_finish;
                __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), __old_finish, __new_finish, _M_get_Tp_allocator());
            }
        } catch (...) {
            if (!__new_finish)
                _Alloc_traits::destroy(this->_M_impl, __new_start + __elems_before);
            else
                std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
            _M_deallocate(__new_start, __len);
            throw;
        }
        if (!_S_use_relocate())
            std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
        ;
        _M_deallocate(__old_start, this->_M_impl._M_end_of_storage - __old_start);
        this->_M_impl._M_start = __new_start;
        this->_M_impl._M_finish = __new_finish;
        this->_M_impl._M_end_of_storage = __new_start + __len;
    }
    template <typename _Tp, typename _Alloc> constexpr void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n, const value_type &__x) {
        if (__n != 0) {
            if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n) {
                _Temporary_value __tmp(this, __x);
                value_type &__x_copy = __tmp._M_val();
                const size_type __elems_after = end() - __position;
                pointer __old_finish(this->_M_impl._M_finish);
                if (__elems_after > __n) {
                    ;
                    std::__uninitialized_move_a(__old_finish - __n, __old_finish, __old_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __n;
                    ;
                    std::move_backward(__position.base(), __old_finish - __n, __old_finish);
                    std::fill(__position.base(), __position.base() + __n, __x_copy);
                } else {
                    ;
                    this->_M_impl._M_finish = std::__uninitialized_fill_n_a(__old_finish, __n - __elems_after, __x_copy, _M_get_Tp_allocator());
                    ;
                    std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __elems_after;
                    ;
                    std::fill(__position.base(), __old_finish, __x_copy);
                }
            } else {
                pointer __old_start = this->_M_impl._M_start;
                pointer __old_finish = this->_M_impl._M_finish;
                const pointer __pos = __position.base();
                const size_type __len = this->_M_check_len(__n, "vector::_M_fill_insert");
                const size_type __elems_before = __pos - __old_start;
                pointer __new_start(this->_M_allocate(__len));
                pointer __new_finish(__new_start);
                try {
                    std::__uninitialized_fill_n_a(__new_start + __elems_before, __n, __x, _M_get_Tp_allocator());
                    __new_finish = pointer();
                    __new_finish = std::__uninitialized_move_if_noexcept_a(__old_start, __pos, __new_start, _M_get_Tp_allocator());
                    __new_finish += __n;
                    __new_finish = std::__uninitialized_move_if_noexcept_a(__pos, __old_finish, __new_finish, _M_get_Tp_allocator());
                } catch (...) {
                    if (!__new_finish)
                        std::_Destroy(__new_start + __elems_before, __new_start + __elems_before + __n, _M_get_Tp_allocator());
                    else
                        std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                    _M_deallocate(__new_start, __len);
                    throw;
                }
                std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
                ;
                _M_deallocate(__old_start, this->_M_impl._M_end_of_storage - __old_start);
                this->_M_impl._M_start = __new_start;
                this->_M_impl._M_finish = __new_finish;
                this->_M_impl._M_end_of_storage = __new_start + __len;
            }
        }
    }
    template <typename _Tp, typename _Alloc> constexpr void vector<_Tp, _Alloc>::_M_default_append(size_type __n) {
        if (__n != 0) {
            const size_type __size = this->size();
            size_type __navail = size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish);
            if (__size > this->max_size() || __navail > this->max_size() - __size)
                __builtin_unreachable();
            if (__navail >= __n) {
                ;
                this->_M_impl._M_finish = std::__uninitialized_default_n_a(this->_M_impl._M_finish, __n, _M_get_Tp_allocator());
                ;
            } else {
                pointer __old_start = this->_M_impl._M_start;
                pointer __old_finish = this->_M_impl._M_finish;
                const size_type __len = this->_M_check_len(__n, "vector::_M_default_append");
                pointer __new_start(this->_M_allocate(__len));
                if (_S_use_relocate()) {
                    try {
                        std::__uninitialized_default_n_a(__new_start + __size, __n, _M_get_Tp_allocator());
                    } catch (...) {
                        _M_deallocate(__new_start, __len);
                        throw;
                    }
                    _S_relocate(__old_start, __old_finish, __new_start, _M_get_Tp_allocator());
                } else {
                    pointer __destroy_from = pointer();
                    try {
                        std::__uninitialized_default_n_a(__new_start + __size, __n, _M_get_Tp_allocator());
                        __destroy_from = __new_start + __size;
                        std::__uninitialized_move_if_noexcept_a(__old_start, __old_finish, __new_start, _M_get_Tp_allocator());
                    } catch (...) {
                        if (__destroy_from)
                            std::_Destroy(__destroy_from, __destroy_from + __n, _M_get_Tp_allocator());
                        _M_deallocate(__new_start, __len);
                        throw;
                    }
                    std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
                }
                ;
                _M_deallocate(__old_start, this->_M_impl._M_end_of_storage - __old_start);
                this->_M_impl._M_start = __new_start;
                this->_M_impl._M_finish = __new_start + __size + __n;
                this->_M_impl._M_end_of_storage = __new_start + __len;
            }
        }
    }
    template <typename _Tp, typename _Alloc> constexpr bool vector<_Tp, _Alloc>::_M_shrink_to_fit() {
        if (this->capacity() == this->size())
            return false;
        ;
        return std::__shrink_to_fit_aux<vector<_Tp, _Alloc>>::_S_do_it(*this);
    }
    template <typename _Tp, typename _Alloc> template <typename _InputIterator> constexpr void vector<_Tp, _Alloc>::_M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
        if (__pos == end()) {
            for (; __first != __last; ++__first)
                insert(end(), *__first);
        } else if (__first != __last) {
            vector<_Tp, _Alloc> __tmp(__first, __last, _M_get_Tp_allocator());
            insert(__pos, std::make_move_iterator(__tmp.begin()), std::make_move_iterator(__tmp.end()));
        }
    }
    template <typename _Tp, typename _Alloc> template <typename _ForwardIterator> constexpr void vector<_Tp, _Alloc>::_M_range_insert(iterator __position, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) {
        if (__first != __last) {
            const size_type __n = std::distance(__first, __last);
            if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n) {
                const size_type __elems_after = end() - __position;
                pointer __old_finish(this->_M_impl._M_finish);
                if (__elems_after > __n) {
                    ;
                    std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __n;
                    ;
                    std::move_backward(__position.base(), __old_finish - __n, __old_finish);
                    std::copy(__first, __last, __position);
                } else {
                    _ForwardIterator __mid = __first;
                    std::advance(__mid, __elems_after);
                    ;
                    std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __n - __elems_after;
                    ;
                    std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __elems_after;
                    ;
                    std::copy(__first, __mid, __position);
                }
            } else {
                pointer __old_start = this->_M_impl._M_start;
                pointer __old_finish = this->_M_impl._M_finish;
                const size_type __len = this->_M_check_len(__n, "vector::_M_range_insert");
                pointer __new_start(this->_M_allocate(__len));
                pointer __new_finish(__new_start);
                try {
                    __new_finish = std::__uninitialized_move_if_noexcept_a(__old_start, __position.base(), __new_start, _M_get_Tp_allocator());
                    __new_finish = std::__uninitialized_copy_a(__first, __last, __new_finish, _M_get_Tp_allocator());
                    __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), __old_finish, __new_finish, _M_get_Tp_allocator());
                } catch (...) {
                    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                    _M_deallocate(__new_start, __len);
                    throw;
                }
                std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
                ;
                _M_deallocate(__old_start, this->_M_impl._M_end_of_storage - __old_start);
                this->_M_impl._M_start = __new_start;
                this->_M_impl._M_finish = __new_finish;
                this->_M_impl._M_end_of_storage = __new_start + __len;
            }
        }
    }
    template <typename _Alloc> constexpr void vector<bool, _Alloc>::_M_reallocate(size_type __n) {
        _Bit_pointer __q = this->_M_allocate(__n);
        iterator __start(std::__addressof(*__q), 0);
        iterator __finish(this->_M_copy_aligned(begin(), end(), __start));
        this->_M_deallocate();
        this->_M_impl._M_start = __start;
        this->_M_impl._M_finish = __finish;
        this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }
    template <typename _Alloc> constexpr void vector<bool, _Alloc>::_M_fill_insert(iterator __position, size_type __n, bool __x) {
        if (__n == 0)
            return;
        if (this->capacity() - this->size() >= __n) {
            std::copy_backward(__position, end(), this->_M_impl._M_finish + difference_type(__n));
            std::fill(__position, __position + difference_type(__n), __x);
            this->_M_impl._M_finish += difference_type(__n);
        } else {
            const size_type __len = this->_M_check_len(__n, "vector<bool>::_M_fill_insert");
            _Bit_pointer __q = this->_M_allocate(__len);
            iterator __start(std::__addressof(*__q), 0);
            iterator __i = this->_M_copy_aligned(begin(), __position, __start);
            std::fill(__i, __i + difference_type(__n), __x);
            iterator __finish = std::copy(__position, end(), __i + difference_type(__n));
            this->_M_deallocate();
            this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
            this->_M_impl._M_start = __start;
            this->_M_impl._M_finish = __finish;
        }
    }
    template <typename _Alloc> template <typename _ForwardIterator> constexpr void vector<bool, _Alloc>::_M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) {
        if (__first != __last) {
            size_type __n = std::distance(__first, __last);
            if (this->capacity() - this->size() >= __n) {
                std::copy_backward(__position, end(), this->_M_impl._M_finish + difference_type(__n));
                std::copy(__first, __last, __position);
                this->_M_impl._M_finish += difference_type(__n);
            } else {
                const size_type __len = this->_M_check_len(__n, "vector<bool>::_M_insert_range");
                const iterator __begin = begin(), __end = end();
                _Bit_pointer __q = this->_M_allocate(__len);
                iterator __start(std::__addressof(*__q), 0);
                iterator __i = this->_M_copy_aligned(__begin, __position, __start);
                __i = std::copy(__first, __last, __i);
                iterator __finish = std::copy(__position, __end, __i);
                this->_M_deallocate();
                this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                this->_M_impl._M_start = __start;
                this->_M_impl._M_finish = __finish;
            }
        }
    }
    template <typename _Alloc> constexpr void vector<bool, _Alloc>::_M_insert_aux(iterator __position, bool __x) {
        if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()) {
            std::copy_backward(__position, this->_M_impl._M_finish, this->_M_impl._M_finish + 1);
            * __position = __x;
            ++this->_M_impl._M_finish;
        } else {
            const size_type __len = this->_M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
            _Bit_pointer __q = this->_M_allocate(__len);
            iterator __start(std::__addressof(*__q), 0);
            iterator __i = this->_M_copy_aligned(begin(), __position, __start);
            * __i ++ = __x;
            iterator __finish = std::copy(__position, end(), __i);
            this->_M_deallocate();
            this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
            this->_M_impl._M_start = __start;
            this->_M_impl._M_finish = __finish;
        }
    }
    template <typename _Alloc> constexpr typename vector<bool, _Alloc>::iterator vector<bool, _Alloc>::_M_erase(iterator __position) {
        if (__position + 1 != end())
            std::copy(__position + 1, end(), __position);
        --this->_M_impl._M_finish;
        return __position;
    }
    template <typename _Alloc> constexpr typename vector<bool, _Alloc>::iterator vector<bool, _Alloc>::_M_erase(iterator __first, iterator __last) {
        if (__first != __last)
            this->_M_erase_at_end(std::copy(__last, end(), __first));
        return __first;
    }
    template <typename _Alloc> constexpr bool vector<bool, _Alloc>::_M_shrink_to_fit() {
        if (this->capacity() - this->size() < int(_S_word_bit))
            return false;
        try {
            if (size_type __n = this->size())
                this->_M_reallocate(__n);
            else {
                this->_M_deallocate();
                this->_M_impl._M_reset();
            }
            return true;
        } catch (...) {
            return false;
        }
    }
}
namespace std {
    template <typename _Alloc> size_t hash<std::vector<bool, _Alloc>>::operator()(const std::vector<bool, _Alloc> &__b) const noexcept {
        size_t __hash = 0;
        const size_t __words = __b.size() / _S_word_bit;
        if (__words) {
            const size_t __clength = __words * sizeof(_Bit_type);
            __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
        }
        const size_t __extrabits = __b.size() % _S_word_bit;
        if (__extrabits) {
            _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
            __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
            const size_t __clength = (__extrabits + 8 - 1) / 8;
            if (__words)
                __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
            else
                __hash = std::_Hash_impl::hash(&__hiword, __clength);
        }
        return __hash;
    }
}
namespace std {
    namespace pmr {
        template <typename _Tp> using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
    }
}
namespace std {
    template <typename _Tp, typename _Alloc, typename _Predicate> inline constexpr typename vector<_Tp, _Alloc>::size_type erase_if(vector<_Tp, _Alloc> &__cont, _Predicate __pred) {
        using namespace __gnu_cxx;
        std::vector<_Tp, _Alloc> &__ucont = __cont;
        const auto __osz = __cont.size();
        const auto __end = __ucont.end();
        auto __removed = std::__remove_if(__ucont.begin(), __end, __ops::__pred_iter(std::ref(__pred)));
        if (__removed != __end) {
            __cont.erase(__niter_wrap(__cont.begin(), __removed), __cont.end());
            return __osz - __cont.size();
        }
        return 0;
    }
    template <typename _Tp, typename _Alloc, typename _Up> inline constexpr typename vector<_Tp, _Alloc>::size_type erase(vector<_Tp, _Alloc> &__cont, const _Up &__value) {
        using namespace __gnu_cxx;
        std::vector<_Tp, _Alloc> &__ucont = __cont;
        const auto __osz = __cont.size();
        const auto __end = __ucont.end();
        auto __removed = std::__remove_if(__ucont.begin(), __end, __ops::__iter_equals_val(__value));
        if (__removed != __end) {
            __cont.erase(__niter_wrap(__cont.begin(), __removed), __cont.end());
            return __osz - __cont.size();
        }
        return 0;
    }
}
using namespace poly;
class ChildA;
class ChildB;
class ChildC;
template <class ...Derived> class Base {
public:
    static constexpr cid_t scid = 0 + 1;
    const cid_t cid = scid;
private:
    cid_t rcid = 0;
public:
    template <typename DerivedT, typename ResT, typename ...ArgsT> inline void _call_impl_echo_tag(ResT *res, ArgsT &...args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$echo_tag);
        constexpr bool overrided = static_cast<M>(&B::echo_tag) != static_cast<M>(&DerivedT::echo_tag);
        constexpr bool procedural = std::is_same_v<ResT *, void *>;
        if (overrided && procedural) {
            static_cast<DerivedT *>(this)->echo_tag(args...);
        }
        if (overrided && !procedural) {
            *res = static_cast<DerivedT *>(this)->echo_tag(args...);
        }
        if (!overrided && procedural) {
            this->$echo_tag(args...);
        }
        if (!overrided && !procedural) {
            *res = this->$echo_tag(args...);
        }
    }
    static_assert(true, "");
    template <typename ...Ts> inline auto echo_tag(Ts ...args) {
        if (this->rcid < 0)
            return this->$echo_tag(args...);
        using ResT = decltype(this->$echo_tag(args...));
        if (!std::is_void_v<ResT>) {
            ResT res;
            ((static_cast<Derived *>(this)->cid == Derived::scid ? (_call_impl_echo_tag<Derived>(&res, args...) , this->rcid = Derived::scid) : false) || ...);
            if (this->rcid) {
                return res;
            }
            this->rcid = -1;
            return this->$echo_tag(args...);
        } else {
            ((static_cast<Derived *>(this)->cid == Derived::scid ? (_call_impl_echo_tag<Derived>((void *)0, args...) , this->rcid = Derived::scid) : false) || ...);
            if (!this->rcid) {
                this->rcid = -1;
                this->$echo_tag(args...);
            }
        }
    }
    static_assert(true, "");
public:
    template <typename DerivedT, typename ResT, typename ...ArgsT> inline void _call_impl_div(ResT *res, ArgsT &...args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$div);
        constexpr bool overrided = static_cast<M>(&B::div) != static_cast<M>(&DerivedT::div);
        constexpr bool procedural = std::is_same_v<ResT *, void *>;
        if (overrided && procedural) {
            static_cast<DerivedT *>(this)->div(args...);
        }
        if (overrided && !procedural) {
            *res = static_cast<DerivedT *>(this)->div(args...);
        }
        if (!overrided && procedural) {
            this->$div(args...);
        }
        if (!overrided && !procedural) {
            *res = this->$div(args...);
        }
    }
    static_assert(true, "");
    template <typename ...Ts> inline auto div(Ts ...args) {
        if (this->rcid < 0)
            return this->$div(args...);
        using ResT = decltype(this->$div(args...));
        if (!std::is_void_v<ResT>) {
            ResT res;
            ((static_cast<Derived *>(this)->cid == Derived::scid ? (_call_impl_div<Derived>(&res, args...) , this->rcid = Derived::scid) : false) || ...);
            if (this->rcid) {
                return res;
            }
            this->rcid = -1;
            return this->$div(args...);
        } else {
            ((static_cast<Derived *>(this)->cid == Derived::scid ? (_call_impl_div<Derived>((void *)0, args...) , this->rcid = Derived::scid) : false) || ...);
            if (!this->rcid) {
                this->rcid = -1;
                this->$div(args...);
            }
        }
    }
    static_assert(true, "");
public:
    template <typename DerivedT, typename ResT, typename ...ArgsT> inline void _call_impl_repeat(ResT *res, ArgsT &...args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$repeat);
        constexpr bool overrided = static_cast<M>(&B::repeat) != static_cast<M>(&DerivedT::repeat);
        constexpr bool procedural = std::is_same_v<ResT *, void *>;
        if (overrided && procedural) {
            static_cast<DerivedT *>(this)->repeat(args...);
        }
        if (overrided && !procedural) {
            *res = static_cast<DerivedT *>(this)->repeat(args...);
        }
        if (!overrided && procedural) {
            this->$repeat(args...);
        }
        if (!overrided && !procedural) {
            *res = this->$repeat(args...);
        }
    }
    static_assert(true, "");
    template <typename ...Ts> inline auto repeat(Ts ...args) {
        if (this->rcid < 0)
            return this->$repeat(args...);
        using ResT = decltype(this->$repeat(args...));
        if (!std::is_void_v<ResT>) {
            ResT res;
            ((static_cast<Derived *>(this)->cid == Derived::scid ? (_call_impl_repeat<Derived>(&res, args...) , this->rcid = Derived::scid) : false) || ...);
            if (this->rcid) {
                return res;
            }
            this->rcid = -1;
            return this->$repeat(args...);
        } else {
            ((static_cast<Derived *>(this)->cid == Derived::scid ? (_call_impl_repeat<Derived>((void *)0, args...) , this->rcid = Derived::scid) : false) || ...);
            if (!this->rcid) {
                this->rcid = -1;
                this->$repeat(args...);
            }
        }
    }
    static_assert(true, "");
public:
    template <typename DerivedT, typename ResT, typename ...ArgsT> inline void _call_impl_mul(ResT *res, ArgsT &...args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$mul);
        constexpr bool overrided = static_cast<M>(&B::mul) != static_cast<M>(&DerivedT::mul);
        constexpr bool procedural = std::is_same_v<ResT *, void *>;
        if (overrided && procedural) {
            static_cast<DerivedT *>(this)->mul(args...);
        }
        if (overrided && !procedural) {
            *res = static_cast<DerivedT *>(this)->mul(args...);
        }
        if (!overrided && procedural) {
            this->$mul(args...);
        }
        if (!overrided && !procedural) {
            *res = this->$mul(args...);
        }
    }
    static_assert(true, "");
    template <typename ...Ts> inline auto mul(Ts ...args) {
        if (this->rcid < 0)
            return this->$mul(args...);
        using ResT = decltype(this->$mul(args...));
        if (!std::is_void_v<ResT>) {
            ResT res;
            ((static_cast<Derived *>(this)->cid == Derived::scid ? (_call_impl_mul<Derived>(&res, args...) , this->rcid = Derived::scid) : false) || ...);
            if (this->rcid) {
                return res;
            }
            this->rcid = -1;
            return this->$mul(args...);
        } else {
            ((static_cast<Derived *>(this)->cid == Derived::scid ? (_call_impl_mul<Derived>((void *)0, args...) , this->rcid = Derived::scid) : false) || ...);
            if (!this->rcid) {
                this->rcid = -1;
                this->$mul(args...);
            }
        }
    }
    static_assert(true, "");
private:
    void $echo_tag() {
        std::cout << __FUNCTION__ << std::endl;
    }
    float $div(int a, int b) {
        std::cout << __FUNCTION__ << std::endl;
        return a / b;
    }
    std::vector<int> $repeat(int a) {
        std::cout << __FUNCTION__ << std::endl;
        auto a_ = static_cast<int>(a);
        return {a_, a_};
    }
    float $mul(int a [[maybe_unused]], int b [[maybe_unused]]) [[maybe_unused]] {
        throw std::logic_error(std::string("Calling the interface \"") + __PRETTY_FUNCTION__ + "\" is prohibited");
        return float{};
    }
    static_assert(true, "");
};
template<> class Base<<ChildA, ChildB, ChildC>> {
public:
    static constexpr cid_t scid = 0 + 1;
    const cid_t cid = scid;
private:
    cid_t rcid = 0;
public:
    template <typename DerivedT, typename ResT, typename ...ArgsT> inline void _call_impl_echo_tag(ResT *res, ArgsT &...args) requires has_cid<DerivedT>;
    template<> inline void _call_impl_echo_tag<ChildC, void, <>>(void *res) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$echo_tag);
        constexpr bool overrided = static_cast<M>(&B::echo_tag) != static_cast<M>(&ChildC::echo_tag);
        constexpr bool procedural = std::is_same_v<void *, void *>;
        if (overrided && procedural) {
            static_cast<ChildC *>(this)->echo_tag();
        }
        if (overrided && !procedural)
            ;
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_echo_tag<ChildB, void, <>>(void *res) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$echo_tag);
        constexpr bool overrided = static_cast<M>(&B::echo_tag) != static_cast<M>(&ChildB::echo_tag);
        constexpr bool procedural = std::is_same_v<void *, void *>;
        if (overrided && procedural) {
            static_cast<ChildB *>(this)->echo_tag();
        }
        if (overrided && !procedural)
            ;
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_echo_tag<ChildA, void, <>>(void *res) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$echo_tag);
        constexpr bool overrided = static_cast<M>(&B::echo_tag) != static_cast<M>(&ChildA::echo_tag);
        constexpr bool procedural = std::is_same_v<void *, void *>;
        if (overrided && procedural) {
            static_cast<ChildA *>(this)->echo_tag();
        }
        if (overrided && !procedural)
            ;
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    static_assert(true, "");
    template <typename ...Ts> inline auto echo_tag(Ts ...args);
    template<> inline void echo_tag<<>>() {
        if (this->rcid < 0)
            return this->$echo_tag();
        using ResT = decltype(this->$echo_tag());
        if (!std::is_void_v<ResT>)
            ;
        else {
            (static_cast<ChildA *>(this)->cid == ChildA::scid ? (this->_call_impl_echo_tag<ChildA>((void *)0) , this->rcid = ChildA::scid) : false) || (static_cast<ChildB *>(this)->cid == ChildB::scid ? (this->_call_impl_echo_tag<ChildB>((void *)0) , this->rcid = ChildB::scid) : false) || (static_cast<ChildC *>(this)->cid == ChildC::scid ? (this->_call_impl_echo_tag<ChildC>((void *)0) , this->rcid = ChildC::scid) : false);
            if (!this->rcid) {
                this->rcid = -1;
                this->$echo_tag();
            }
        }
    }
;
    static_assert(true, "");
public:
    template <typename DerivedT, typename ResT, typename ...ArgsT> inline void _call_impl_div(ResT *res, ArgsT &...args) requires has_cid<DerivedT>;
    template<> inline void _call_impl_div<ChildC, float, <int, int>>(float *res, int &args, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$div);
        constexpr bool overrided = static_cast<M>(&B::div) != static_cast<M>(&ChildC::div);
        constexpr bool procedural = std::is_same_v<float *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildC *>(this)->div(args, args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_div<ChildB, float, <int, int>>(float *res, int &args, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$div);
        constexpr bool overrided = static_cast<M>(&B::div) != static_cast<M>(&ChildB::div);
        constexpr bool procedural = std::is_same_v<float *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildB *>(this)->div(args, args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_div<ChildA, float, <int, int>>(float *res, int &args, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$div);
        constexpr bool overrided = static_cast<M>(&B::div) != static_cast<M>(&ChildA::div);
        constexpr bool procedural = std::is_same_v<float *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildA *>(this)->div(args, args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    static_assert(true, "");
    template <typename ...Ts> inline auto div(Ts ...args);
    template<> inline float div<<int, int>>(int args, int args) {
        if (this->rcid < 0)
            return this->$div(args, args);
        using ResT = decltype(this->$div(args, args));
        if (!std::is_void_v<ResT>) {
            ResT res;
            (static_cast<ChildA *>(this)->cid == ChildA::scid ? (this->_call_impl_div<ChildA>(&res, args, args) , this->rcid = ChildA::scid) : false) || (static_cast<ChildB *>(this)->cid == ChildB::scid ? (this->_call_impl_div<ChildB>(&res, args, args) , this->rcid = ChildB::scid) : false) || (static_cast<ChildC *>(this)->cid == ChildC::scid ? (this->_call_impl_div<ChildC>(&res, args, args) , this->rcid = ChildC::scid) : false);
            if (this->rcid) {
                return res;
            }
            this->rcid = -1;
            return this->$div(args, args);
        }
    }
;
    static_assert(true, "");
public:
    template <typename DerivedT, typename ResT, typename ...ArgsT> inline void _call_impl_repeat(ResT *res, ArgsT &...args) requires has_cid<DerivedT>;
    template<> inline void _call_impl_repeat<ChildC, std::vector<int>, <unsigned int>>(std::vector<int> *res, unsigned int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$repeat);
        constexpr bool overrided = static_cast<M>(&B::repeat) != static_cast<M>(&ChildC::repeat);
        constexpr bool procedural = std::is_same_v<std::vector<int> *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildC *>(this)->repeat(args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_repeat<ChildB, std::vector<int>, <unsigned int>>(std::vector<int> *res, unsigned int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$repeat);
        constexpr bool overrided = static_cast<M>(&B::repeat) != static_cast<M>(&ChildB::repeat);
        constexpr bool procedural = std::is_same_v<std::vector<int> *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildB *>(this)->repeat(args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_repeat<ChildA, std::vector<int>, <unsigned int>>(std::vector<int> *res, unsigned int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$repeat);
        constexpr bool overrided = static_cast<M>(&B::repeat) != static_cast<M>(&ChildA::repeat);
        constexpr bool procedural = std::is_same_v<std::vector<int> *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildA *>(this)->repeat(args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_repeat<ChildC, std::vector<int>, <int>>(std::vector<int> *res, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$repeat);
        constexpr bool overrided = static_cast<M>(&B::repeat) != static_cast<M>(&ChildC::repeat);
        constexpr bool procedural = std::is_same_v<std::vector<int> *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildC *>(this)->repeat(args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_repeat<ChildB, std::vector<int>, <int>>(std::vector<int> *res, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$repeat);
        constexpr bool overrided = static_cast<M>(&B::repeat) != static_cast<M>(&ChildB::repeat);
        constexpr bool procedural = std::is_same_v<std::vector<int> *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildB *>(this)->repeat(args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_repeat<ChildA, std::vector<int>, <int>>(std::vector<int> *res, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$repeat);
        constexpr bool overrided = static_cast<M>(&B::repeat) != static_cast<M>(&ChildA::repeat);
        constexpr bool procedural = std::is_same_v<std::vector<int> *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildA *>(this)->repeat(args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    static_assert(true, "");
    template <typename ...Ts> inline auto repeat(Ts ...args);
    template<> inline std::vector<int> repeat<<unsigned int>>(unsigned int args) {
        if (this->rcid < 0)
            return this->$repeat(args);
        using ResT = decltype(this->$repeat(args));
        if (!std::is_void_v<ResT>) {
            ResT res;
            (static_cast<ChildA *>(this)->cid == ChildA::scid ? (this->_call_impl_repeat<ChildA>(&res, args) , this->rcid = ChildA::scid) : false) || (static_cast<ChildB *>(this)->cid == ChildB::scid ? (this->_call_impl_repeat<ChildB>(&res, args) , this->rcid = ChildB::scid) : false) || (static_cast<ChildC *>(this)->cid == ChildC::scid ? (this->_call_impl_repeat<ChildC>(&res, args) , this->rcid = ChildC::scid) : false);
            if (this->rcid) {
                return res;
            }
            this->rcid = -1;
            return this->$repeat(args);
        }
    }
;
    template<> inline std::vector<int> repeat<<int>>(int args) {
        if (this->rcid < 0)
            return this->$repeat(args);
        using ResT = decltype(this->$repeat(args));
        if (!std::is_void_v<ResT>) {
            ResT res;
            (static_cast<ChildA *>(this)->cid == ChildA::scid ? (this->_call_impl_repeat<ChildA>(&res, args) , this->rcid = ChildA::scid) : false) || (static_cast<ChildB *>(this)->cid == ChildB::scid ? (this->_call_impl_repeat<ChildB>(&res, args) , this->rcid = ChildB::scid) : false) || (static_cast<ChildC *>(this)->cid == ChildC::scid ? (this->_call_impl_repeat<ChildC>(&res, args) , this->rcid = ChildC::scid) : false);
            if (this->rcid) {
                return res;
            }
            this->rcid = -1;
            return this->$repeat(args);
        }
    }
;
    static_assert(true, "");
public:
    template <typename DerivedT, typename ResT, typename ...ArgsT> inline void _call_impl_mul(ResT *res, ArgsT &...args) requires has_cid<DerivedT>;
    template<> inline void _call_impl_mul<ChildC, float, <int, int>>(float *res, int &args, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$mul);
        constexpr bool overrided = static_cast<M>(&B::mul) != static_cast<M>(&ChildC::mul);
        constexpr bool procedural = std::is_same_v<float *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildC *>(this)->mul(args, args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_mul<ChildB, float, <int, int>>(float *res, int &args, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$mul);
        constexpr bool overrided = static_cast<M>(&B::mul) != static_cast<M>(&ChildB::mul);
        constexpr bool procedural = std::is_same_v<float *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildB *>(this)->mul(args, args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    template<> inline void _call_impl_mul<ChildA, float, <int, int>>(float *res, int &args, int &args) requires has_cid<DerivedT> {
        using B = typename std::remove_reference<decltype(*this)>::type;
        using M = decltype(&B::$mul);
        constexpr bool overrided = static_cast<M>(&B::mul) != static_cast<M>(&ChildA::mul);
        constexpr bool procedural = std::is_same_v<float *, void *>;
        if (overrided && procedural)
            ;
        if (overrided && !procedural) {
            *res = static_cast<ChildA *>(this)->mul(args, args);
        }
        if (!overrided && procedural)
            ;
        if (!overrided && !procedural)
            ;
    }
;
    static_assert(true, "");
    template <typename ...Ts> inline auto mul(Ts ...args);
    template<> inline float mul<<int, int>>(int args, int args) {
        if (this->rcid < 0)
            return this->$mul(args, args);
        using ResT = decltype(this->$mul(args, args));
        if (!std::is_void_v<ResT>) {
            ResT res;
            (static_cast<ChildA *>(this)->cid == ChildA::scid ? (this->_call_impl_mul<ChildA>(&res, args, args) , this->rcid = ChildA::scid) : false) || (static_cast<ChildB *>(this)->cid == ChildB::scid ? (this->_call_impl_mul<ChildB>(&res, args, args) , this->rcid = ChildB::scid) : false) || (static_cast<ChildC *>(this)->cid == ChildC::scid ? (this->_call_impl_mul<ChildC>(&res, args, args) , this->rcid = ChildC::scid) : false);
            if (this->rcid) {
                return res;
            }
            this->rcid = -1;
            return this->$mul(args, args);
        }
    }
;
    static_assert(true, "");
private:
    void $echo_tag() {
        std::cout << __FUNCTION__ << std::endl;
    }
    float $div(int a, int b) {
        std::cout << __FUNCTION__ << std::endl;
        return a / b;
    }
    std::vector<int> $repeat(int a) {
        std::cout << __FUNCTION__ << std::endl;
        auto a_ = static_cast<int>(a);
        return {a_, a_};
    }
    float $mul(int a [[maybe_unused]], int b [[maybe_unused]]) [[maybe_unused]] {
        throw std::logic_error(std::string("Calling the interface \"") + __PRETTY_FUNCTION__ + "\" is prohibited");
        return float{};
    }
    static_assert(true, "");
};
class ChildA : public Base<ChildA, ChildB, ChildC> {
public:
    static constexpr cid_t scid = 1 + 1;
    const cid_t cid = scid;
public:
    void echo_tag(int i) {
        std::cout << __PRETTY_FUNCTION__ << i << std::endl;
    }
    void echo_tag() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }
    void echo_tag(float i) {
        std::cout << __PRETTY_FUNCTION__ << i << std::endl;
    }
    float div(int a, int b) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return a / b;
    }
    std::vector<int> repeat(int a) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return {a, a, a};
    }
    float mul(int a, int b) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return a * b;
    }
};
class ChildB : public Base<ChildA, ChildB, ChildC> {
public:
    static constexpr cid_t scid = 2 + 1;
    const cid_t cid = scid;
public:
    void echo_tag() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }
    float div(int a, int b) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return static_cast<float>(a) / b;
    }
    std::vector<int> repeat(int a) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return {a, a, a, a};
    }
    float mul(int a, int b) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return a * b;
    }
};
class ChildC : public Base<ChildA, ChildB, ChildC> {
public:
    static constexpr cid_t scid = 3 + 1;
    const cid_t cid = scid;
public:
    void echo_tag() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }
    float div(int a, int b) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return static_cast<double>(a) / b;
    }
    std::vector<int> repeat(int a) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return {a, a, a, a, a};
    }
    float mul(int a, int b) {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
        return a * b;
    }
};
int main() {
    using Base = Base<ChildA, ChildB, ChildC>;
    auto base = new Base();
    auto child_a = new ChildA();
    auto child_b = new ChildB();
    auto child_c = new ChildC();
    std::vector<Base *> pack = {base, (static_cast<Base *>(child_a)), (static_cast<Base *>(child_c)), (static_cast<Base *>(child_b))};
    for (auto obj : pack) {
        obj->echo_tag();
    }
    child_a->echo_tag(111);
    std::cout << std::endl;
    for (auto obj : pack) {
        std::cout << obj->div(111, 222) << std::endl;
    }
    std::cout << std::endl;
    for (unsigned int i = 0; i < pack.size(); ++i) {
        auto v = pack[i]->repeat(i);
        for (auto a : v)
            std::cout << a << " ";
        std::cout << std::endl;
    }
    std::cout << std::endl;
    std::cout << pack[1]->mul(111, 222) << std::endl;
    std::cout << pack[2]->mul(111, 222) << std::endl;
    std::cout << pack[3]->mul(111, 222) << std::endl;
    std::cout << std::endl << pack[0]->mul(111, 222) << std::endl;
    return 0;
}
